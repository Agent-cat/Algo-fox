{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/sql-converter.ts"],"sourcesContent":["export function convertToSQLite(sql: string): string {\n    if (!sql || !sql.trim()) {\n        return sql;\n    }\n\n    let converted = sql;\n\n    // 1. Convert AUTO_INCREMENT to AUTOINCREMENT (SQLite syntax - one word, no underscore)\n    // This must be done first before other conversions\n    converted = converted.replace(/\\bAUTO_INCREMENT\\b/gi, 'AUTOINCREMENT');\n\n    // 2. Convert INT PRIMARY KEY AUTOINCREMENT to INTEGER PRIMARY KEY AUTOINCREMENT\n    // SQLite requires INTEGER (not INT) for PRIMARY KEY with AUTOINCREMENT\n    converted = converted.replace(/\\bINT\\s+PRIMARY\\s+KEY\\s+AUTOINCREMENT\\b/gi, 'INTEGER PRIMARY KEY AUTOINCREMENT');\n    converted = converted.replace(/\\bINT\\s+AUTOINCREMENT\\s+PRIMARY\\s+KEY\\b/gi, 'INTEGER PRIMARY KEY AUTOINCREMENT');\n\n    // 3. Convert INT PRIMARY KEY to INTEGER PRIMARY KEY (SQLite requires INTEGER for PRIMARY KEY)\n    // This handles cases without AUTOINCREMENT\n    converted = converted.replace(/\\bINT\\s+PRIMARY\\s+KEY\\b/gi, 'INTEGER PRIMARY KEY');\n\n    // 4. Convert INT AUTOINCREMENT to INTEGER AUTOINCREMENT (for non-PRIMARY KEY cases)\n    converted = converted.replace(/\\bINT\\s+AUTOINCREMENT\\b/gi, 'INTEGER AUTOINCREMENT');\n\n    // 5. Convert MySQL backticks to SQLite double quotes (optional, SQLite accepts both)\n    // But we'll keep backticks as SQLite 3.3+ supports them\n\n    // 6. Convert MySQL/PostgreSQL LIMIT syntax if needed\n    // SQLite supports: LIMIT n OFFSET m (same as MySQL)\n    // No conversion needed for LIMIT/OFFSET\n\n    // 7. Convert string concatenation\n    // MySQL: CONCAT(a, b) -> SQLite: a || b\n    // Handle nested CONCAT calls\n    converted = convertConcatToConcatOperator(converted);\n\n    // 8. Convert boolean handling\n    // MySQL: TRUE/FALSE -> SQLite: 1/0 (SQLite doesn't have native boolean)\n    converted = converted.replace(/\\bTRUE\\b/gi, '1');\n    converted = converted.replace(/\\bFALSE\\b/gi, '0');\n\n    // 9. Convert date functions (common differences)\n    // MySQL: NOW() -> SQLite: datetime('now')\n    converted = converted.replace(/\\bNOW\\(\\)\\b/gi, \"datetime('now')\");\n    // MySQL: CURDATE() -> SQLite: date('now')\n    converted = converted.replace(/\\bCURDATE\\(\\)\\b/gi, \"date('now')\");\n    // MySQL: CURTIME() -> SQLite: time('now')\n    converted = converted.replace(/\\bCURTIME\\(\\)\\b/gi, \"time('now')\");\n\n    // 10. Convert IFNULL to COALESCE (SQLite supports both, but COALESCE is standard)\n    // Actually, SQLite supports IFNULL, so no conversion needed\n\n    // 11. Remove MySQL-specific ENGINE and CHARSET clauses\n    converted = converted.replace(/\\s+ENGINE\\s*=\\s*\\w+/gi, '');\n    converted = converted.replace(/\\s+CHARSET\\s*=\\s*\\w+/gi, '');\n    converted = converted.replace(/\\s+COLLATE\\s*=\\s*\\w+/gi, '');\n\n    // 12. Convert MySQL-specific data types\n    // TINYINT -> INTEGER\n    converted = converted.replace(/\\bTINYINT\\b/gi, 'INTEGER');\n    // MEDIUMINT -> INTEGER\n    converted = converted.replace(/\\bMEDIUMINT\\b/gi, 'INTEGER');\n    // BIGINT -> INTEGER (SQLite stores all integers as INTEGER)\n    // Actually, keep BIGINT as SQLite handles it\n    // VARCHAR(n) -> TEXT (SQLite doesn't enforce length)\n    // Keep VARCHAR as SQLite accepts it\n    // TEXT -> TEXT (same)\n    // DATETIME -> TEXT (SQLite stores dates as TEXT)\n    // Keep DATETIME as SQLite accepts it\n\n    // 13. Remove MySQL-specific UNSIGNED keyword\n    converted = converted.replace(/\\bUNSIGNED\\b/gi, '');\n\n    // 14. Convert MySQL-specific ON DUPLICATE KEY UPDATE to SQLite INSERT OR REPLACE\n    // This is complex, so we'll handle it separately if needed\n    // For now, keep as is and let SQLite handle errors\n\n    // 15. Clean up extra whitespace and semicolons\n    converted = converted.trim();\n\n    return converted;\n}\n\n/**\n * Converts CONCAT() function calls to SQLite's || concatenation operator\n * Handles nested CONCAT calls efficiently with iterative approach\n */\nfunction convertConcatToConcatOperator(sql: string): string {\n    // Early return if no CONCAT found\n    if (!/\\bCONCAT\\s*\\(/i.test(sql)) {\n        return sql;\n    }\n\n    let result = sql;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 20; // Prevent infinite loops\n\n    // Process CONCAT calls iteratively (handles nesting)\n    while (changed && iterations < maxIterations) {\n        iterations++;\n        changed = false;\n\n        // Find innermost CONCAT call (no nested CONCAT inside)\n        const concatMatch = result.match(/\\bCONCAT\\s*\\(([^()]+)\\)/i);\n\n        if (concatMatch) {\n            changed = true;\n            const args = concatMatch[1];\n            const argsList = splitConcatArgs(args);\n\n            // Join with || operator\n            const converted = argsList.map(arg => arg.trim()).join(' || ');\n\n            // Replace the CONCAT call\n            result = result.replace(concatMatch[0], `(${converted})`);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Splits CONCAT arguments while respecting nested parentheses\n */\nfunction splitConcatArgs(args: string): string[] {\n    const result: string[] = [];\n    let current = '';\n    let depth = 0;\n\n    for (let i = 0; i < args.length; i++) {\n        const char = args[i];\n\n        if (char === '(') {\n            depth++;\n            current += char;\n        } else if (char === ')') {\n            depth--;\n            current += char;\n        } else if (char === ',' && depth === 0) {\n            result.push(current.trim());\n            current = '';\n        } else {\n            current += char;\n        }\n    }\n\n    if (current.trim()) {\n        result.push(current.trim());\n    }\n\n    return result;\n}\n\n/**\n * Optimized batch conversion for multiple SQL statements\n */\nexport function convertBatchToSQLite(sql: string): string {\n    // Split by semicolon but keep them for SQLite\n    const statements = sql.split(';').filter(s => s.trim());\n\n    if (statements.length === 0) {\n        return sql;\n    }\n\n    // Convert each statement\n    const converted = statements.map(stmt => convertToSQLite(stmt.trim()));\n\n    // Join with semicolons\n    return converted.join(';\\n') + (sql.trim().endsWith(';') ? ';' : '');\n}\n\n"],"names":[],"mappings":"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"}}]
}