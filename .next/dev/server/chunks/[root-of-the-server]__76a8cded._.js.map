{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/languages.ts"],"sourcesContent":["\nexport interface Language {\n    id: number; // Judge0 ID\n    name: string;\n    monacoLanguage: string; // Monaco Editor language identifier\n    boilerplate: string;\n}\n\nexport const LANGUAGES: Language[] = [\n    {\n        id: 63,\n        name: \"JavaScript\",\n        monacoLanguage: \"javascript\",\n        boilerplate: `const fs = require(\"fs\");\n\nconst input = fs.readFileSync(0, \"utf8\").trim().split(/\\\\s+/);\n\n// write your code here\n\nconsole.log();`\n    },\n\n    {\n        id: 62,\n        name: \"Java\",\n        monacoLanguage: \"java\",\n        boilerplate: `import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        // write your code here\n\n        \n    }\n}`\n    },\n\n    {\n        id: 71,\n        name: \"Python\",\n        monacoLanguage: \"python\",\n        boilerplate: `import sys\n\ndata = sys.stdin.read().split()\n\n# write your code here\n\nprint()`\n    },\n\n    {\n        id: 50,\n        name: \"C\",\n        monacoLanguage: \"c\",\n        boilerplate: `#include <stdio.h>\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 54,\n        name: \"C++\",\n        monacoLanguage: \"cpp\",\n        boilerplate: `#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 73,\n        name: \"Rust\",\n        monacoLanguage: \"rust\",\n        boilerplate: `use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    // write your code here\n}`\n    },\n\n    {\n        id: 60,\n        name: \"Go\",\n        monacoLanguage: \"go\",\n        boilerplate: `package main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    in := bufio.NewReader(os.Stdin)\n\n    // write your code here\n\n}`\n    },\n    {\n        id: 82,\n        name: \"SQL\",\n        monacoLanguage: \"sql\",\n        boilerplate: `` // Empty boilerplate for SQL\n    }\n];\n\nexport function getLanguageById(id: number): Language | undefined {\n    return LANGUAGES.find(lang => lang.id === id);\n}\n\nexport function getLanguageByName(name: string): Language | undefined {\n    return LANGUAGES.find(lang => lang.name === name);\n}\n\nexport const DEFAULT_LANGUAGE_ID = 63;\n\n"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,YAAwB;IACjC;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;cAMR,CAAC;IACX;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;CASrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;OAMf,CAAC;IACJ;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;CAQrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;;;;CAYrB,CAAC;IACE;IACA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,EAAE,CAAC,4BAA4B;IAChD;CACH;AAEM,SAAS,gBAAgB,EAAU;IACtC,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;AAC9C;AAEO,SAAS,kBAAkB,IAAY;IAC1C,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;AAChD;AAEO,MAAM,sBAAsB"}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,sJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/submission.service.ts"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\nimport { SubmissionResult, TestCaseResult, SubmissionMode } from \"@prisma/client\";\nimport { getLanguageById } from \"@/lib/languages\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport { revalidateTag, updateTag } from \"next/cache\";\nimport redis from \"@/lib/redis\";\n\nconst JUDGE0_URL = process.env.JUDGE0_URL || \"http://localhost:2358\";\n\nexport class SubmissionService {\n    private static languageCache = new Map<number, { id: number; name: string; judge0Id: number }>();\n\n    static async createSubmission(userId: string, problemId: string, judge0Id: number, code: string, mode: SubmissionMode = \"SUBMIT\", contestId?: string) {\n        // Get language info from our language mapping\n        const langInfo = getLanguageById(judge0Id);\n        const languageName = langInfo?.name || `Language_${judge0Id}`;\n\n        // Check cache first\n        let language = this.languageCache.get(judge0Id);\n\n        if (!language) {\n            // Try to find existing language by judge0Id first (primary lookup)\n            const dbLanguage = await prisma.language.findUnique({\n                where: { judge0Id: judge0Id }\n            });\n\n            if (dbLanguage) {\n                language = dbLanguage;\n            } else {\n                // If not found, try to create it\n                try {\n                    language = await prisma.language.create({\n                        data: {\n                            name: languageName,\n                            judge0Id: judge0Id\n                        }\n                    });\n                } catch (error: any) {\n                    // If creation fails due to name conflict, try to find by name\n                    // This handles the case where a language with this name exists but different judge0Id\n                    if (error.code === 'P2002') {\n                        const existingByName = await prisma.language.findUnique({\n                            where: { name: languageName }\n                        });\n                        if (existingByName) {\n                            // Use the existing language even if judge0Id doesn't match\n                            // In production, languages should be pre-seeded to avoid this\n                            language = existingByName;\n                        } else {\n                            // If it's a judge0Id conflict, find by judge0Id\n                            const existingByJudge0Id = await prisma.language.findUnique({\n                                where: { judge0Id: judge0Id }\n                            });\n                            if (!existingByJudge0Id) {\n                                throw new Error(`Could not create or find language with judge0Id ${judge0Id}`);\n                            }\n                            language = existingByJudge0Id;\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n            }\n\n            // Update cache\n            if (language) {\n                this.languageCache.set(judge0Id, language);\n            }\n        }\n\n        return prisma.submission.create({\n            data: {\n                userId,\n                problemId,\n                languageId: language.id, // Use the internal PK\n                code,\n                status: \"PENDING\",\n                mode,\n                contestId,\n            },\n            include: {\n                problem: {\n                    include: {\n                        testCases: true\n                    }\n                },\n                language: true\n            }\n        });\n    }\n\n    static async updateSubmissionStatus(submissionId: string, status: SubmissionResult, time?: number, memory?: number) {\n        await prisma.submission.update({\n            where: { id: submissionId },\n            data: { status, time, memory },\n        });\n\n        try {\n            // Only attempt invalidation, don't crash if it fails (e.g. in worker)\n            revalidateTag(`submission-${submissionId}`,\"max\");\n        } catch (error) {\n            // Silently fail in worker context\n        }\n    }\n\n    static async createTestCases(submissionId: string, testCases: { index: number; judge0TrackingId: string }[]) {\n        // Create DB records for tracking individual test case results\n        await prisma.$transaction(\n            testCases.map(tc => prisma.testCase.create({\n                data: {\n                    submissionId,\n                    index: tc.index,\n                    judge0TrackingId: tc.judge0TrackingId,\n                    status: \"PENDING\"\n                }\n            }))\n        );\n    }\n\n    static async updateTestCaseResult(judge0TrackingId: string, status: TestCaseResult, time: number, memory: number, errorMessage?: string | null, stdout?: string | null) {\n        await prisma.testCase.update({\n            where: { judge0TrackingId },\n            data: {\n                status,\n                time,\n                memory,\n                errorMessage: errorMessage || null,\n                stdout: stdout || null\n            }\n        });\n    }\n\n    static async updateTestCasesBatch(updates: { judge0TrackingId: string, status: TestCaseResult, time: number, memory: number, errorMessage?: string | null, stdout?: string | null }[]) {\n        if (updates.length === 0) return;\n\n        await prisma.$transaction(\n            updates.map(update => prisma.testCase.update({\n                where: { judge0TrackingId: update.judge0TrackingId },\n                data: {\n                    status: update.status,\n                    time: update.time,\n                    memory: update.memory,\n                    errorMessage: update.errorMessage || null,\n                    stdout: update.stdout || null\n                }\n            }))\n        );\n    }\n\n    static async sendToJudge0(languageId: number, code: string, testCases: { input: string; output: string }[]) {\n        // Determine Judge0 Language ID from our DB Language ID (assuming mapping exists or is direct)\n        // For now assuming the passed languageId is the Judge0 ID.\n\n        const encodedCode = Buffer.from(code).toString('base64');\n        const submissions = testCases.map(tc => ({\n            language_id: languageId,\n            source_code: encodedCode,\n            stdin: Buffer.from(tc.input).toString('base64'),\n            expected_output: Buffer.from(tc.output).toString('base64'),\n        }));\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout\n\n        try {\n            const response = await fetch(`${JUDGE0_URL}/submissions/batch?base64_encoded=true`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({ submissions }),\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`Judge0 Error: ${response.statusText}`);\n            }\n\n            const data = await response.json();\n            // data type: { token: string }[] (if params say so, but usually it returns tokens)\n            return data as { token: string }[];\n        } catch (error) {\n            console.error(\"Failed to send to Judge0\", error);\n            throw error;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    static async getBatchResults(tokens: string[]) {\n        if (tokens.length === 0) return [];\n\n        const tokensStr = tokens.join(\",\");\n        // Include compile_output, stderr for error messages, and stdout for user output\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout\n\n        try {\n            const response = await fetch(`${JUDGE0_URL}/submissions/batch?tokens=${tokensStr}&base64_encoded=true&fields=token,status,time,memory,compile_output,stderr,stdout`, {\n                method: \"GET\",\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`Judge0 Batch Fetch Failed: Status ${response.status}`, errorText);\n                throw new Error(`Failed to fetch batch results: ${response.status} - ${errorText}`);\n            }\n\n            const data = await response.json();\n            return (data.submissions as {\n                token: string;\n                status: { id: number; description: string };\n                time: string;\n                memory: number;\n                compile_output: string | null;\n                stderr: string | null;\n                stdout: string | null;\n            }[]).map(sub => ({\n                ...sub,\n                stdout: sub.stdout ? Buffer.from(sub.stdout, 'base64').toString('utf-8') : null,\n                stderr: sub.stderr ? Buffer.from(sub.stderr, 'base64').toString('utf-8') : null,\n                compile_output: sub.compile_output ? Buffer.from(sub.compile_output, 'base64').toString('utf-8') : null,\n            }));\n        } catch (error) {\n            throw error;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    static async incrementProblemSolved(problemId: string, userId: string) {\n        // Use a transaction to atomically check and update\n        // This helps prevent race conditions when multiple submissions are processed concurrently\n        await prisma.$transaction(async (tx) => {\n            // Check if this is the first time the user has solved this problem\n            // Only count SUBMIT mode submissions to avoid double-counting from RUN mode\n            const acceptedCount = await tx.submission.count({\n                where: {\n                    problemId,\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                }\n            });\n\n            // Only increment if this is the first accepted solution (count should be exactly 1, which is the current one)\n            if (acceptedCount === 1) {\n                // Fetch the problem to get its difficulty\n                const problem = await tx.problem.findUnique({\n                    where: { id: problemId },\n                    select: { difficulty: true }\n                });\n\n                if (!problem) {\n                    throw new Error(\"Problem not found\");\n                }\n\n                // Calculate points based on difficulty\n                const points = getPointsForDifficulty(problem.difficulty);\n\n                // Increment problem's solved count\n                await tx.problem.update({\n                    where: { id: problemId },\n                    data: {\n                        solved: {\n                            increment: 1\n                        }\n                    }\n                });\n\n                // Increment user's problemsSolved count and add points based on difficulty\n                // SKIP IF CONCEPT\n                if (problem.difficulty !== \"CONCEPT\") {\n                    await tx.user.update({\n                        where: { id: userId },\n                        data: {\n                            problemsSolved: {\n                                increment: 1\n                            },\n                            totalScore: {\n                                increment: points\n                            }\n                        }\n                    });\n                }\n\n                // Invalidate user score cache and leaderboard cache\n                try {\n                    await redis.del(`user-score-${userId}`);\n                    // Invalidate leaderboard cache so new users appear\n                    await redis.del('leaderboard:global');\n\n                    // Invalidate Next.js cache tags for categories\n                    try {\n                        updateTag('categories-list');\n                        updateTag(`categories-DSA-user-${userId}`);\n                        updateTag(`categories-SQL-user-${userId}`);\n                        updateTag(`user-submissions-${userId}`);\n                        updateTag('problems-list');\n                        updateTag('problems-search');\n                    } catch (e) {\n                        // Ignore if updateTag is not available or fails\n                    }\n                } catch (error) {\n                    // Cache invalidation might fail in worker context, but that's okay\n                    // The cache will expire naturally after 30 seconds (user score) and 10 minutes (leaderboard)\n                    console.error(\"Failed to invalidate cache:\", error);\n                }\n            }\n        });\n    }\n    static async getSubmissionById(id: string) {\n        return prisma.submission.findUnique({\n            where: { id },\n            include: {\n                problem: {\n                    select: {\n                        id: true,\n                        title: true,\n                        slug: true,\n                        difficulty: true,\n                    }\n                },\n                language: {\n                    select: {\n                        id: true,\n                        name: true,\n                    }\n                },\n                testCases: {\n                    orderBy: { index: 'asc' }\n                }\n            }\n        });\n    }\n\n    static async getProblemSubmissions(problemId: string, userId: string, take: number = 20, cursor?: string) {\n        const query: any = {\n            where: {\n                problemId,\n                userId,\n                mode: \"SUBMIT\" // Only show actual submissions, not runs\n            },\n            include: {\n                language: {\n                    select: {\n                        name: true\n                    }\n                }\n            },\n            take,\n            orderBy: {\n                createdAt: 'desc'\n            }\n        };\n\n        if (cursor) {\n            query.cursor = { id: cursor };\n            query.skip = 1;\n        }\n\n        return prisma.submission.findMany(query);\n    }\n    static async invalidateClassroomTracking(userId: string) {\n        try {\n            // Find all classrooms the user is enrolled in where tracking is active\n            const classrooms = await prisma.classroom.findMany({\n                where: {\n                    students: {\n                        some: { id: userId }\n                    },\n                    isTrackingActive: true\n                },\n                select: { id: true }\n            });\n\n            if (classrooms.length > 0) {\n                 // Invalidate live tracking cache for each classroom\n                 const keys = classrooms.map(c => `algofox:live-tracking:${c.id}`);\n                 await redis.del(...keys);\n\n                 // Also invalidate Next.js cache tags for good measure\n                 classrooms.forEach(c => {\n                     // Since we are in a service/worker context, revalidateTag might be tricky if not in a server action/request\n                     // But we can try just in case this service is called from a server action\n                     try {\n                        revalidateTag(`classroom-${c.id}`, \"max\");\n                     } catch (e) {\n                         // Ignore error if outside request context\n                     }\n                 });\n            }\n        } catch (error) {\n            console.error(\"Failed to invalidate classroom tracking cache:\", error);\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 776, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/queues/submission.queue.ts"],"sourcesContent":["import { Queue, Worker, Job } from \"bullmq\";\nimport connection from \"@/lib/redis\";\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { SubmissionResult, TestCaseResult } from \"@prisma/client\";\n\nconst QUEUE_NAME = \"submission-queue\";\n\nexport const submissionQueue = new Queue(QUEUE_NAME, {\n    connection,\n});\n\nexport const addSubmissionJob = async (submissionId: string) => {\n    await submissionQueue.add(\"process-submission\", { submissionId });\n};\n\n// Worker Implementation\n// Note: In Next.js (serverless), workers are tricky. Ideally, this runs in a separate process.\n// For this 'demo' / 'integrated' setup, we might initialize it differently, but here we define it.\n// If this file is imported in the API route, the worker might start multiple times in dev.\n// We'll use a global check or just simple instantiation for now, assuming a long-running server or dedicated worker process.\n\nconst workerName = \"submission-worker\";\n\n// Judge0 Status IDs\nconst JUDGE0_STATUS = {\n    IN_QUEUE: 1,\n    PROCESSING: 2,\n    ACCEPTED: 3,\n    WRONG_ANSWER: 4,\n    TIME_LIMIT_EXCEEDED: 5,\n    COMPILATION_ERROR: 6,\n    RUNTIME_ERROR_SIGSEGV: 7,\n    RUNTIME_ERROR_SIGXFSZ: 8,\n    RUNTIME_ERROR_SIGFPE: 9,\n    RUNTIME_ERROR_SIGABRT: 10,\n    RUNTIME_ERROR_NZEC: 11,\n    RUNTIME_ERROR_OTHER: 12,\n    INTERNAL_ERROR: 13,\n};\n\nconst mapJudge0StatusToDb = (statusId: number): TestCaseResult | null => {\n    if (statusId === JUDGE0_STATUS.ACCEPTED) return \"ACCEPTED\";\n    if (statusId === JUDGE0_STATUS.WRONG_ANSWER) return \"WRONG_ANSWER\";\n    if (statusId === JUDGE0_STATUS.TIME_LIMIT_EXCEEDED) return \"TIME_LIMIT_EXCEEDED\";\n    if (statusId === JUDGE0_STATUS.COMPILATION_ERROR) return \"COMPILE_ERROR\";\n    if (statusId >= 7 && statusId <= 12) return \"RUNTIME_ERROR\";\n    return null; // Pending or Processing\n};\n\nconst worker = new Worker(\n    QUEUE_NAME,\n    async (job: Job<{ submissionId: string }>) => {\n        const { submissionId } = job.data;\n\n        try {\n            // 1. Fetch Submission Data\n            // To avoid circular dep if we construct full object here, we might need a getter in service\n            // For now, let's use the service to get it conceptually or direct prisma if needed.\n            // But we have SubmissionService.\n            const { prisma } = await import(\"@/lib/prisma\"); // Lazy import to avoid init issues\n\n            const submission = await prisma.submission.findUnique({\n                where: { id: submissionId },\n                include: {\n                    problem: {\n                        include: {\n                            testCases: true,\n                            functionTemplates: true // Include function templates for DSA\n                        }\n                    },\n                    language: true\n                }\n            });\n\n            if (!submission) throw new Error(\"Submission not found\");\n            if (!submission.problem) throw new Error(\"Problem not found\");\n\n            const { code, language, problem, mode } = submission;\n            const allTestCases = problem.testCases;\n\n            // Filter test cases based on mode:\n            // RUN mode: only public (non-hidden) test cases\n            // SUBMIT mode: all test cases (public + hidden)\n            let testCasesToEvaluate: typeof allTestCases;\n            if (mode === \"RUN\") {\n                testCasesToEvaluate = allTestCases.filter(tc => !tc.hidden);\n            } else {\n                testCasesToEvaluate = allTestCases;\n            }\n\n            if (testCasesToEvaluate.length === 0) {\n                await SubmissionService.updateSubmissionStatus(submissionId, \"ACCEPTED\", 0, 0);\n                return;\n            }\n\n            // Build the code to execute\n            let codeToExecute = code;\n\n            // For SQL problems, prepend hiddenQuery and convert to SQLite\n            if (problem.domain === \"SQL\") {\n                // Prepend hiddenQuery if exists\n                if (problem.hiddenQuery) {\n                    codeToExecute = problem.hiddenQuery.trim() + \"\\n\" + code;\n                }\n\n                // Convert SQL to SQLite-compatible syntax\n                const { convertBatchToSQLite } = await import(\"@/lib/sql-converter\");\n                codeToExecute = convertBatchToSQLite(codeToExecute);\n            }\n            // For DSA problems with function templates, combine driver code + user's function\n            else if (problem.domain === \"DSA\" && problem.useFunctionTemplate && problem.functionTemplates?.length) {\n                const template = problem.functionTemplates.find(\n                    t => t.languageId === language.judge0Id\n                );\n\n                if (template?.driverCode) {\n                    const langId = language.judge0Id;\n\n                    // Check if driver code uses placeholder for user code insertion\n                    if (template.driverCode.includes(\"{{USER_CODE}}\")) {\n                        // Replace placeholder with user's code\n                        codeToExecute = template.driverCode.replace(\"{{USER_CODE}}\", code);\n                    }\n                    // Go (60), Rust (73): Driver first (package/imports/fn main), then user function\n                    else if (langId === 60 || langId === 73) {\n                        codeToExecute = template.driverCode + \"\\n\\n\" + code;\n                    }\n                    // JavaScript (63), Python (71): User code first, then driver\n                    else if (langId === 63 || langId === 71) {\n                        codeToExecute = code + \"\\n\\n\" + template.driverCode;\n                    }\n                    // Java (62), C (50), C++ (54): Need placeholder - warn if missing\n                    else if (langId === 62 || langId === 50 || langId === 54) {\n                        // For structured languages, assume user code goes inside class/before main\n                        // If no placeholder, try driver first (for cases where main is at end)\n                        codeToExecute = template.driverCode.replace(/}\\s*$/, code + \"\\n}\");\n                    }\n                    // Default: user code first, then driver\n                    else {\n                        codeToExecute = code + \"\\n\\n\" + template.driverCode;\n                    }\n                }\n            }\n\n            // 2. Send Batch to Judge0\n            const judge0Tokens = await SubmissionService.sendToJudge0(\n                language.judge0Id,\n                codeToExecute,\n                testCasesToEvaluate.map(tc => ({ input: tc.input, output: tc.output }))\n            );\n\n            // 3. Store Tokens in DB (TestCase records)\n            const testCaseRecords = testCasesToEvaluate.map((tc, idx) => ({\n                index: allTestCases.findIndex(orig => orig.id === tc.id),\n                judge0TrackingId: judge0Tokens[idx].token,\n                processed: false, // Track local completion state\n                processingUpdateSent: false // Track if we've already broadcasted the \"Processing\" state\n            }));\n            await SubmissionService.createTestCases(submissionId, testCaseRecords);\n\n            // 4. Poll and Incremental Update\n            let isComplete = false;\n            let attempts = 0;\n            // Adaptive Polling:\n            // First 5 seconds: Poll every 100ms (fast feedback)\n            // Next 25 seconds: Poll every 500ms\n            // Remaining time: Poll every 1000ms\n            const MAX_TOTAL_TIME_MS = 60000; // 60 seconds hard timeout\n            const START_TIME = Date.now();\n\n            // Track overall stats\n            let totalTime = 0;\n            let maxMemory = 0;\n            let finalStatus: SubmissionResult = \"ACCEPTED\";\n            let globalErrorMessage: string | null = null;\n            let compilationError = false;\n\n            while (!isComplete && (Date.now() - START_TIME) < MAX_TOTAL_TIME_MS) {\n                const elapsedMs = Date.now() - START_TIME;\n                let pollInterval = 1000;\n                if (elapsedMs < 5000) pollInterval = 150;\n                else if (elapsedMs < 30000) pollInterval = 500;\n\n                await new Promise(r => setTimeout(r, pollInterval));\n                attempts++;\n\n                const pendingRecords = testCaseRecords.filter(tc => !tc.processed);\n                if (pendingRecords.length === 0) {\n                    isComplete = true;\n                    break;\n                }\n\n                const pendingTokens = pendingRecords.map(tc => tc.judge0TrackingId);\n                const batchResults = await SubmissionService.getBatchResults(pendingTokens);\n\n                // Check for global compilation error (only once)\n                if (!compilationError && batchResults.length > 0) {\n                    const firstResult = batchResults[0];\n                    const firstStatus = mapJudge0StatusToDb(firstResult.status.id);\n                    if (firstStatus === \"COMPILE_ERROR\") {\n                        compilationError = true;\n                        finalStatus = \"COMPILE_ERROR\";\n                        globalErrorMessage = firstResult.compile_output || firstResult.stderr || \"Compilation Error\";\n                    }\n                }\n\n                let pendingCount = 0;\n                const updatesToApply: { judge0TrackingId: string, status: TestCaseResult, time: number, memory: number, errorMessage: string | null, stdout: string | null }[] = [];\n                const publishedUpdates: any[] = [];\n\n                for (let i = 0; i < batchResults.length; i++) {\n                    const result = batchResults[i];\n                    // Match result back to the correct record by token\n                    const localRecord = pendingRecords.find(r => r.judge0TrackingId === result.token);\n                    if (!localRecord) continue;\n\n                    // Identify completion (not In Queue and not Processing)\n                    const isFinished =\n                        result.status.id !== JUDGE0_STATUS.IN_QUEUE &&\n                        result.status.id !== JUDGE0_STATUS.PROCESSING;\n\n                    if (!isFinished) {\n                        // If it's processing, broadcast this to the user (once)\n                        if (result.status.id === JUDGE0_STATUS.PROCESSING && !localRecord.processingUpdateSent) {\n                             localRecord.processingUpdateSent = true;\n                             publishedUpdates.push({\n                                 index: localRecord.index,\n                                 status: \"PROCESSING\",\n                                 judge0TrackingId: result.token\n                             });\n                        }\n                        pendingCount++;\n                        continue;\n                    }\n\n                    // If finished but not yet marked processed, update DB\n                    if (!localRecord.processed) {\n                        localRecord.processed = true;\n\n                        const time = parseFloat(result.time || \"0\");\n                        const memory = result.memory || 0;\n                        const status = mapJudge0StatusToDb(result.status.id);\n\n                        \n                        let errorMessage: string | null = null;\n                        if (compilationError) {\n                            errorMessage = globalErrorMessage;\n                        } else if (status === \"COMPILE_ERROR\") {\n                            errorMessage = result.compile_output || result.stderr || \"Compilation Error\";\n                        } else if (status === \"RUNTIME_ERROR\") {\n                            const description = result.status.description || \"Runtime Error\";\n                            const stderr = result.stderr?.trim();\n                            errorMessage = stderr ? `${description}\\n\\n${stderr}` : description;\n                            if (description.includes(\"SIGSEGV\")) errorMessage += \"\\n\\nPossible causes:\\n- Accessing array out of bounds\\n- Null pointer\";\n                            if (description.includes(\"SIGFPE\")) errorMessage += \"\\n\\nPossible causes:\\n- Division by zero\";\n                        } else if (status === \"TIME_LIMIT_EXCEEDED\") {\n                            errorMessage = \"Time Limit Exceeded\";\n                        } else if (status === \"MEMORY_LIMIT_EXCEEDED\") {\n                            errorMessage = \"Memory Limit Exceeded\";\n                        } else if (result.stderr && status !== \"ACCEPTED\") {\n                            errorMessage = result.stderr;\n                        }\n\n                         if (!errorMessage && result.compile_output && status !== \"ACCEPTED\") {\n                            errorMessage = result.compile_output;\n                        }\n\n                        if ((status === \"RUNTIME_ERROR\" || status === \"COMPILE_ERROR\") && !errorMessage) {\n                            errorMessage = \"Unknown Error Occurred\";\n                        }\n\n                        const statusToUse = compilationError ? \"COMPILE_ERROR\" : (status || \"RUNTIME_ERROR\");\n\n                        // Add to batch\n                        const updateData = {\n                            judge0TrackingId: result.token,\n                            status: statusToUse,\n                            time,\n                            memory,\n                            errorMessage,\n                            stdout: result.stdout\n                        };\n                        updatesToApply.push(updateData);\n\n                        // Prepare for Redis Publish\n                         publishedUpdates.push({\n                            ...updateData,\n                            index: localRecord.index\n                        });\n\n                        // Accumulate stats\n                        totalTime += time;\n                        maxMemory = Math.max(maxMemory, memory);\n\n                        // Determine Submission Status\n                        if (!compilationError && status !== \"ACCEPTED\") {\n                            if (finalStatus === \"ACCEPTED\") {\n                                if (status === \"WRONG_ANSWER\") finalStatus = \"WRONG_ANSWER\";\n                                else if (status === \"TIME_LIMIT_EXCEEDED\") finalStatus = \"TIME_LIMIT_EXCEEDED\";\n                                else finalStatus = \"RUNTIME_ERROR\";\n                            }\n                        }\n                    }\n                }\n\n                if (updatesToApply.length > 0) {\n                    await SubmissionService.updateTestCasesBatch(updatesToApply);\n\n                    // Publish incremental updates to Redis\n                    // Using connection (ioredis) from imports\n                    // We publish the entire list of new updates\n                    if (publishedUpdates.length > 0) {\n                         await connection.publish(`submission:${submissionId}`, JSON.stringify({\n                             type: \"CASE_UPDATE\",\n                             data: publishedUpdates\n                         }));\n                    }\n                }\n\n                if (pendingCount === 0) {\n                    isComplete = true;\n                }\n            }\n\n            if (isComplete) {\n                const avgTime = totalTime / testCaseRecords.length;\n                await SubmissionService.updateSubmissionStatus(submissionId, finalStatus, avgTime, maxMemory);\n\n                // Publish Completion Event\n                await connection.publish(`submission:${submissionId}`, JSON.stringify({\n                    type: \"COMPLETE\",\n                    data: {\n                        status: finalStatus,\n                        time: avgTime,\n                        memory: maxMemory\n                    }\n                }));\n\n                if (finalStatus === \"ACCEPTED\" && submission.mode === \"SUBMIT\") {\n                    await SubmissionService.incrementProblemSolved(problem.id, submission.userId);\n                }\n\n                // Invalidate Live Tracking Cache\n                await SubmissionService.invalidateClassroomTracking(submission.userId);\n            } else {\n                await SubmissionService.updateSubmissionStatus(submissionId, \"TIME_LIMIT_EXCEEDED\");\n                 await connection.publish(`submission:${submissionId}`, JSON.stringify({\n                    type: \"COMPLETE\",\n                    data: {\n                        status: \"TIME_LIMIT_EXCEEDED\",\n                        time: 0,\n                        memory: 0\n                    }\n                }));\n\n                // Invalidate Live Tracking Cache (Timeout)\n                await SubmissionService.invalidateClassroomTracking(submission.userId);\n            }\n\n        } catch (error) {\n            console.error(`Error processing submission ${submissionId}`, error);\n            await SubmissionService.updateSubmissionStatus(submissionId, \"RUNTIME_ERROR\");\n             await connection.publish(`submission:${submissionId}`, JSON.stringify({\n                    type: \"COMPLETE\",\n                    data: {\n                        status: \"RUNTIME_ERROR\",\n                        time: 0,\n                        memory: 0\n                    }\n                }));\n        }\n    },\n    {\n        connection,\n        concurrency: 10, // Process up to 10 submissions in parallel\n        limiter: {\n            max: 50,\n            duration: 1000\n        }\n    }\n);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1106, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/app/api/submissions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { addSubmissionJob } from \"@/core/queues/submission.queue\";\nimport { authClient } from \"@/lib/auth-client\"; // Assuming auth helper exists or we use prisma session\nimport { prisma } from \"@/lib/prisma\"; // Direct access for session check if needed\n\nexport async function GET(req: NextRequest) {\n    const { searchParams } = new URL(req.url);\n    const userId = searchParams.get(\"userId\");\n    const problemId = searchParams.get(\"problemId\");\n    const contestId = searchParams.get(\"contestId\");\n\n    if (!userId || !problemId) {\n        return NextResponse.json({ error: \"Missing params\" }, { status: 400 });\n    }\n\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n        const submissions = await prisma.submission.findMany({\n            where: {\n                userId,\n                problemId,\n                contestId: contestId || null,\n                mode: \"SUBMIT\"\n            },\n            orderBy: { createdAt: 'desc' },\n            take: 20,\n            include: {\n                language: true\n            }\n        });\n\n        return NextResponse.json(submissions);\n    } catch (error) {\n        return NextResponse.json({ error: \"Internal Server Error\" }, { status: 500 });\n    }\n}\n\nexport async function POST(req: NextRequest) {\n    try {\n        const body = await req.json();\n        const { userId, problemId, languageId, code, mode = \"SUBMIT\", contestId } = body;\n\n        if (!userId || !problemId || !languageId || !code) {\n            return NextResponse.json({ error: \"Missing required fields\" }, { status: 400 });\n        }\n\n        // CONTEST SECURITY CHECKS\n        if (contestId) {\n            const contest = await prisma.contest.findUnique({\n                where: { id: contestId },\n                select: { endTime: true }\n            });\n\n            if (!contest) {\n                return NextResponse.json({ error: \"Contest not found\" }, { status: 404 });\n            }\n\n            if (new Date() > contest.endTime) {\n                return NextResponse.json({ error: \"Contest has already ended\" }, { status: 403 });\n            }\n\n            const participation = await prisma.contestParticipation.findUnique({\n                where: {\n                    userId_contestId: {\n                        userId,\n                        contestId\n                    }\n                }\n            });\n\n            if (participation?.isFinished) {\n                return NextResponse.json({ error: \"You have already ended your contest session\" }, { status: 403 });\n            }\n        }\n\n\n\n        // 1. Create Submission in DB (SUBMIT MODE)\n        const submission = await SubmissionService.createSubmission(userId, problemId, languageId, code, mode, contestId);\n\n        // Invalidate Tracking Cache so teachers see \"Pending\" immediately\n        await SubmissionService.invalidateClassroomTracking(userId);\n\n        // 2. Add to Queue\n        await addSubmissionJob(submission.id);\n\n        return NextResponse.json({ submissionId: submission.id }, { status: 201 });\n\n    } catch (error) {\n        console.error(\"Submission API Error:\", error);\n        return NextResponse.json({ error: \"Internal Server Error\" }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AAEA,mMAAuC,4CAA4C;;;;;;AAE5E,eAAe,IAAI,GAAgB;IACtC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;IACxC,MAAM,SAAS,aAAa,GAAG,CAAC;IAChC,MAAM,YAAY,aAAa,GAAG,CAAC;IACnC,MAAM,YAAY,aAAa,GAAG,CAAC;IAEnC,IAAI,CAAC,UAAU,CAAC,WAAW;QACvB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACxE;IAEA,IAAI;QACA,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,MAAM,cAAc,MAAM,OAAO,UAAU,CAAC,QAAQ,CAAC;YACjD,OAAO;gBACH;gBACA;gBACA,WAAW,aAAa;gBACxB,MAAM;YACV;YACA,SAAS;gBAAE,WAAW;YAAO;YAC7B,MAAM;YACN,SAAS;gBACL,UAAU;YACd;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ;AAEO,eAAe,KAAK,GAAgB;IACvC,IAAI;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,OAAO,QAAQ,EAAE,SAAS,EAAE,GAAG;QAE5E,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,cAAc,CAAC,MAAM;YAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjF;QAEA,0BAA0B;QAC1B,IAAI,WAAW;YACX,MAAM,UAAU,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAC5C,OAAO;oBAAE,IAAI;gBAAU;gBACvB,QAAQ;oBAAE,SAAS;gBAAK;YAC5B;YAEA,IAAI,CAAC,SAAS;gBACV,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAAoB,GAAG;oBAAE,QAAQ;gBAAI;YAC3E;YAEA,IAAI,IAAI,SAAS,QAAQ,OAAO,EAAE;gBAC9B,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAA4B,GAAG;oBAAE,QAAQ;gBAAI;YACnF;YAEA,MAAM,gBAAgB,MAAM,yHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;gBAC/D,OAAO;oBACH,kBAAkB;wBACd;wBACA;oBACJ;gBACJ;YACJ;YAEA,IAAI,eAAe,YAAY;gBAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAA8C,GAAG;oBAAE,QAAQ;gBAAI;YACrG;QACJ;QAIA,2CAA2C;QAC3C,MAAM,aAAa,MAAM,gKAAiB,CAAC,gBAAgB,CAAC,QAAQ,WAAW,YAAY,MAAM,MAAM;QAEvG,kEAAkE;QAClE,MAAM,gKAAiB,CAAC,2BAA2B,CAAC;QAEpD,kBAAkB;QAClB,MAAM,IAAA,2JAAgB,EAAC,WAAW,EAAE;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,cAAc,WAAW,EAAE;QAAC,GAAG;YAAE,QAAQ;QAAI;IAE5E,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}}]
}