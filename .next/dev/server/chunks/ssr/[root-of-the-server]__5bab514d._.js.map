{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { admin } from \"better-auth/plugins\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"./prisma\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n    disableSignUp: true,\n  },\n  socialProviders: {\n    google: {\n      enabled: true,\n      clientId: process.env.GOOGLE_CLIENT_ID as string,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n    microsoft: {\n      enabled: true,\n      clientId: process.env.MICROSOFT_CLIENT_ID as string,\n      clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"STUDENT\",\n      },\n      institutionId: {\n        type: \"string\",\n        required: false,\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n\n  plugins: [\n    admin({\n      adminRoles: [\"ADMIN\"],\n      defaultRole: \"STUDENT\",\n      adminUserIds: [\"jvp0LDpaCm0Y2VpUVP75vCNQnDioEdpm\"], // vishnu\n    }),\n  ],\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEO,MAAM,OAAO,IAAA,qKAAU,EAAC;IAC7B,UAAU,IAAA,8MAAa,EAAC,uHAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;QACT,eAAe;IACjB;IACA,iBAAiB;QACf,QAAQ;YACN,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;QACA,WAAW;YACT,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;YAChB;YACA,eAAe;gBACb,MAAM;gBACN,UAAU;YACZ;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IAEA,SAAS;QACP,IAAA,6KAAK,EAAC;YACJ,YAAY;gBAAC;aAAQ;YACrB,aAAa;YACb,cAAc;gBAAC;aAAmC;QACpD;KACD;AACH"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/cache-utils.ts"],"sourcesContent":["import redis from \"./redis\";\n\n/**\n * Cache configuration for different data types\n */\nexport const CACHE_CONFIG = {\n  // Short-lived cache for frequently changing data\n  SHORT: { ttl: 30, stale: 15 },\n  // Medium cache for moderately changing data\n  MEDIUM: { ttl: 120, stale: 60 },\n  // Long cache for rarely changing data\n  LONG: { ttl: 600, stale: 300 },\n  // Very long cache for static-ish data\n  STATIC: { ttl: 3600, stale: 1800 },\n} as const;\n\n/**\n * Generate a consistent cache key\n */\nexport function cacheKey(prefix: string, ...parts: (string | number)[]): string {\n  return `algofox:${prefix}:${parts.join(\":\")}`;\n}\n\n/**\n * Get data from Redis cache with automatic JSON parsing\n */\nexport async function getFromCache<T>(key: string): Promise<T | null> {\n  try {\n    const data = await redis.get(key);\n    if (!data) return null;\n    return JSON.parse(data) as T;\n  } catch (error) {\n    console.error(\"[Cache] Get error:\", error);\n    return null;\n  }\n}\n\n/**\n * Set data in Redis cache with automatic JSON serialization\n */\nexport async function setInCache<T>(\n  key: string,\n  data: T,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<void> {\n  try {\n    await redis.setex(key, ttlSeconds, JSON.stringify(data));\n  } catch (error) {\n    console.error(\"[Cache] Set error:\", error);\n  }\n}\n\n/**\n * Delete a cache key\n */\nexport async function deleteFromCache(key: string): Promise<void> {\n  try {\n    await redis.del(key);\n  } catch (error) {\n    console.error(\"[Cache] Delete error:\", error);\n  }\n}\n\n/**\n * Delete multiple cache keys by pattern\n */\nexport async function deleteByPattern(pattern: string): Promise<void> {\n  try {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  } catch (error) {\n    console.error(\"[Cache] Delete pattern error:\", error);\n  }\n}\n\n/**\n * Get or set pattern - tries cache first, falls back to fetcher\n */\nexport async function cachedFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<T> {\n  // Try cache first\n  const cached = await getFromCache<T>(key);\n  if (cached !== null) {\n    return cached;\n  }\n\n  // Fetch fresh data\n  const data = await fetcher();\n\n  // Cache the result (don't await to not block response)\n  setInCache(key, data, ttlSeconds).catch(() => {});\n\n  return data;\n}\n\n/**\n * Invalidate cache keys for an entity\n */\nexport async function invalidateCache(\n  prefix: string,\n  ...ids: (string | number)[]\n): Promise<void> {\n  const pattern = `algofox:${prefix}:${ids.length > 0 ? ids.join(\":\") : \"*\"}`;\n  await deleteByPattern(pattern);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AAKO,MAAM,eAAe;IAC1B,iDAAiD;IACjD,OAAO;QAAE,KAAK;QAAI,OAAO;IAAG;IAC5B,4CAA4C;IAC5C,QAAQ;QAAE,KAAK;QAAK,OAAO;IAAG;IAC9B,sCAAsC;IACtC,MAAM;QAAE,KAAK;QAAK,OAAO;IAAI;IAC7B,sCAAsC;IACtC,QAAQ;QAAE,KAAK;QAAM,OAAO;IAAK;AACnC;AAKO,SAAS,SAAS,MAAc,EAAE,GAAG,KAA0B;IACpE,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,MAAM,IAAI,CAAC,MAAM;AAC/C;AAKO,eAAe,aAAgB,GAAW;IAC/C,IAAI;QACF,MAAM,OAAO,MAAM,uHAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,MAAM,OAAO;QAClB,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO;IACT;AACF;AAKO,eAAe,WACpB,GAAW,EACX,IAAO,EACP,aAAqB,aAAa,MAAM,CAAC,GAAG;IAE5C,IAAI;QACF,MAAM,uHAAK,CAAC,KAAK,CAAC,KAAK,YAAY,KAAK,SAAS,CAAC;IACpD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;IACtC;AACF;AAKO,eAAe,gBAAgB,GAAW;IAC/C,IAAI;QACF,MAAM,uHAAK,CAAC,GAAG,CAAC;IAClB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;IACzC;AACF;AAKO,eAAe,gBAAgB,OAAe;IACnD,IAAI;QACF,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;QAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;YACnB,MAAM,uHAAK,CAAC,GAAG,IAAI;QACrB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;IACjD;AACF;AAKO,eAAe,YACpB,GAAW,EACX,OAAyB,EACzB,aAAqB,aAAa,MAAM,CAAC,GAAG;IAE5C,kBAAkB;IAClB,MAAM,SAAS,MAAM,aAAgB;IACrC,IAAI,WAAW,MAAM;QACnB,OAAO;IACT;IAEA,mBAAmB;IACnB,MAAM,OAAO,MAAM;IAEnB,uDAAuD;IACvD,WAAW,KAAK,MAAM,YAAY,KAAK,CAAC,KAAO;IAE/C,OAAO;AACT;AAKO,eAAe,gBACpB,MAAc,EACd,GAAG,GAAwB;IAE3B,MAAM,UAAU,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,IAAI,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,OAAO,KAAK;IAC3E,MAAM,gBAAgB;AACxB"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/assignment.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheKey, cachedFetch, CACHE_CONFIG } from \"@/lib/cache-utils\";\n\n/**\n * Get all assignments for a specific classroom (CACHED with pagination)\n */\nexport async function getClassroomAssignments(\n    classroomId: string,\n    page: number = 1,\n    limit: number = 20\n) {\n    // Filter out assignments older than 3 weeks\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n    const skip = (page - 1) * limit;\n\n    const fetchAssignments = unstable_cache(\n        async () => {\n            const [assignments, total] = await Promise.all([\n                prisma.assignment.findMany({\n                    where: {\n                        classroomId,\n                        createdAt: { gte: threeWeeksAgo }\n                    },\n                    include: {\n                        _count: {\n                            select: { problems: true }\n                        }\n                    },\n                    orderBy: { createdAt: \"desc\" },\n                    skip,\n                    take: limit,\n                }),\n                prisma.assignment.count({\n                    where: {\n                        classroomId,\n                        createdAt: { gte: threeWeeksAgo }\n                    }\n                })\n            ]);\n\n            return { assignments, total };\n        },\n        [`classroom-assignments-${classroomId}-page-${page}`],\n        { tags: [`assignments-classroom-${classroomId}`, 'assignments-all'], revalidate: 60 }\n    );\n\n    const { assignments, total } = await fetchAssignments();\n\n    return {\n        assignments,\n        pagination: {\n            total,\n            pages: Math.ceil(total / limit),\n            current: page,\n            limit\n        }\n    };\n}\n\n/**\n * Get all assignments for a specific classroom (UNCACHED)\n * Use this for refetching after mutations to get fresh data\n */\nexport async function refreshClassroomAssignments(classroomId: string) {\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n\n    return await prisma.assignment.findMany({\n        where: {\n            classroomId,\n            createdAt: { gte: threeWeeksAgo }\n        },\n        include: {\n            _count: {\n                select: { problems: true }\n            }\n        },\n        orderBy: { createdAt: \"desc\" }\n    });\n}\n\n/**\n * Create a new assignment for a classroom\n */\nexport async function createAssignment(\n    classroomId: string,\n    data: {\n        title: string;\n        description?: string;\n        dueDate?: Date;\n        problemIds: string[];\n    }\n) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Verify teacher owns the classroom\n        const classroom = await prisma.classroom.findUnique({\n            where: { id: classroomId },\n            select: { teacherId: true }\n        });\n\n        if (!classroom || classroom.teacherId !== session.user.id) {\n            return { success: false, error: \"Unauthorized access to classroom\" };\n        }\n\n        const assignment = await prisma.assignment.create({\n            data: {\n                title: data.title,\n                description: data.description,\n                dueDate: data.dueDate,\n                classroomId,\n                problems: {\n                    create: data.problemIds.map((id, index) => ({\n                        problemId: id,\n                        order: index\n                    }))\n                }\n            }\n        });\n\n        // Revalidate classroom-specific and global assignment caches\n        revalidateTag(`assignments-classroom-${classroomId}`, \"max\");\n        revalidateTag('assignments-all', \"max\"); // Invalidate student assignments cache\n\n        return { success: true, assignmentId: assignment.id };\n    } catch (error) {\n        console.error(\"Create assignment error:\", error);\n        return { success: false, error: \"Failed to create assignment\" };\n    }\n}\n\n/**\n * Get details of a specific assignment, including problems (CACHED)\n */\nexport async function getAssignmentDetails(assignmentId: string) {\n    const fetchDetails = unstable_cache(\n        async () => {\n            return await prisma.assignment.findUnique({\n                where: { id: assignmentId },\n                include: {\n                    problems: {\n                        include: {\n                            problem: {\n                                select: {\n                                    id: true,\n                                    title: true,\n                                    slug: true,\n                                    difficulty: true,\n                                    type: true,\n                                    domain: true,\n                                }\n                            }\n                        },\n                        orderBy: { order: \"asc\" }\n                    },\n                    classroom: {\n                        select: {\n                            name: true,\n                            id: true\n                        }\n                    }\n                }\n            });\n        },\n        [`assignment-details-${assignmentId}`],\n        { tags: [`assignment-${assignmentId}`], revalidate: 3600 } // Cache for 1 hour\n    );\n\n    return await fetchDetails();\n}\n\n/**\n * Get all assignments for the current student across all enrolled classrooms (CACHED with pagination)\n */\nexport async function getStudentAssignments(page: number = 1, limit: number = 20) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) return { assignments: [], pagination: null };\n\n    // Filter out assignments older than 3 weeks\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n    const skip = (page - 1) * limit;\n    const userId = session.user.id;\n\n    const fetchStudentAssignments = unstable_cache(\n        async () => {\n            // First get enrolled classrooms\n            const user = await prisma.user.findUnique({\n                where: { id: userId },\n                select: {\n                    enrolledClassrooms: {\n                        select: { id: true }\n                    }\n                }\n            });\n\n            if (!user || user.enrolledClassrooms.length === 0) {\n                return { assignments: [], total: 0 };\n            }\n\n            const classroomIds = user.enrolledClassrooms.map(c => c.id);\n\n            // Fetch assignments for these classrooms with count\n            const [assignments, total] = await Promise.all([\n                prisma.assignment.findMany({\n                    where: {\n                        classroomId: { in: classroomIds },\n                        createdAt: { gte: threeWeeksAgo }\n                    },\n                    include: {\n                        classroom: {\n                            select: { name: true }\n                        },\n                        _count: {\n                            select: { problems: true }\n                        }\n                    },\n                    orderBy: { dueDate: \"asc\" }, // Due soonest first\n                    skip,\n                    take: limit,\n                }),\n                prisma.assignment.count({\n                    where: {\n                        classroomId: { in: classroomIds },\n                        createdAt: { gte: threeWeeksAgo }\n                    }\n                })\n            ]);\n\n            return { assignments, total };\n        },\n        [`student-assignments-${userId}-page-${page}`],\n        { tags: [`student-assignments-${userId}`, 'assignments-all'], revalidate: 60 }\n    );\n\n    const { assignments, total } = await fetchStudentAssignments();\n\n    return {\n        assignments,\n        pagination: total > 0 ? {\n            total,\n            pages: Math.ceil(total / limit),\n            current: page,\n            limit\n        } : null\n    };\n}\n\n/**\n * Check completion status of problems in an assignment for a specific user (CACHED short-term)\n */\nexport async function getAssignmentProgress(assignmentId: string, userId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    const targetUserId = userId || session?.user?.id;\n    if (!targetUserId) return null;\n\n    // Get assignment problems (cached)\n    const assignment = await getAssignmentDetails(assignmentId);\n    if (!assignment) return null;\n\n    const problemIds = assignment.problems.map(p => p.problemId);\n\n    // Use Redis cache for progress (short TTL since submissions update frequently)\n    const progressCacheKey = cacheKey(\"assignment-progress\", assignmentId, targetUserId);\n\n    const progress = await cachedFetch(\n        progressCacheKey,\n        async () => {\n            // Fetch successful submissions for these problems by the user\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: targetUserId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\"\n                },\n                select: {\n                    problemId: true\n                },\n                distinct: [\"problemId\"]\n            });\n\n            const solvedProblemIds = new Set(submissions.map(s => s.problemId));\n\n            const progressMap: Record<string, boolean> = {};\n            let completedCount = 0;\n\n            assignment.problems.forEach(p => {\n                const isSolved = solvedProblemIds.has(p.problemId);\n                progressMap[p.problemId] = isSolved;\n                if (isSolved) completedCount++;\n            });\n\n            return {\n                total: assignment.problems.length,\n                completed: completedCount,\n                progressMap\n            };\n        },\n        CACHE_CONFIG.SHORT.ttl // 30 seconds cache\n    );\n\n    return progress;\n}\n\n/**\n * Teacher Analytics: Get progress of all students in a classroom for a specific assignment (CACHED)\n */\nexport async function getTeacherAssignmentAnalytics(\n    assignmentId: string,\n    classroomId: string,\n    page: number = 1,\n    limit: number = 50\n) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const skip = (page - 1) * limit;\n    const analyticsCacheKey = cacheKey(\"assignment-analytics\", assignmentId, classroomId, String(page));\n\n    const analytics = await cachedFetch(\n        analyticsCacheKey,\n        async () => {\n            // Parallel fetch for better performance\n            const [classroom, assignment, totalStudents] = await Promise.all([\n                prisma.classroom.findUnique({\n                    where: { id: classroomId },\n                    select: {\n                        students: {\n                            select: {\n                                id: true,\n                                name: true,\n                                image: true,\n                                email: true\n                            },\n                            skip,\n                            take: limit,\n                        }\n                    }\n                }),\n                prisma.assignment.findUnique({\n                    where: { id: assignmentId },\n                    include: {\n                        problems: {\n                            select: { problemId: true }\n                        }\n                    }\n                }),\n                prisma.user.count({\n                    where: {\n                        enrolledClassrooms: {\n                            some: { id: classroomId }\n                        }\n                    }\n                })\n            ]);\n\n            if (!classroom || !assignment) return null;\n\n            const studentIds = classroom.students.map(s => s.id);\n            const problemIds = assignment.problems.map(p => p.problemId);\n\n            // Get all accepted submissions in one query\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: { in: studentIds },\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\"\n                },\n                select: {\n                    userId: true,\n                    problemId: true\n                }\n            });\n\n            // Build submission index for O(1) lookup\n            const submissionIndex = new Map<string, Set<string>>();\n            submissions.forEach(s => {\n                if (!submissionIndex.has(s.userId)) {\n                    submissionIndex.set(s.userId, new Set());\n                }\n                submissionIndex.get(s.userId)!.add(s.problemId);\n            });\n\n            // Build analytics\n            const studentAnalytics = classroom.students.map(student => {\n                const solvedSet = submissionIndex.get(student.id) || new Set();\n\n                return {\n                    student,\n                    completedCount: solvedSet.size,\n                    totalCount: problemIds.length,\n                    completionPercentage: problemIds.length > 0\n                        ? (solvedSet.size / problemIds.length) * 100\n                        : 0,\n                    hasCompletedAll: solvedSet.size === problemIds.length\n                };\n            });\n\n            return {\n                analytics: studentAnalytics,\n                pagination: {\n                    total: totalStudents,\n                    pages: Math.ceil(totalStudents / limit),\n                    current: page,\n                    limit\n                }\n            };\n        },\n        CACHE_CONFIG.MEDIUM.ttl // 2 minutes cache\n    );\n\n    return analytics;\n}\n\n/**\n * Delete an assignment\n */\nexport async function deleteAssignment(assignmentId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const assignment = await prisma.assignment.findUnique({\n            where: { id: assignmentId },\n            include: {\n                classroom: {\n                    select: { teacherId: true, id: true }\n                }\n            }\n        });\n\n        if (!assignment || assignment.classroom.teacherId !== session.user.id) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        // Delete assignment problems first, then assignment\n        await prisma.$transaction([\n            prisma.assignmentProblem.deleteMany({\n                where: { assignmentId }\n            }),\n            prisma.assignment.delete({\n                where: { id: assignmentId }\n            })\n        ]);\n\n        // Invalidate caches\n        revalidateTag(`assignment-${assignmentId}`, \"max\");\n        revalidateTag(`assignments-classroom-${assignment.classroom.id}`, \"max\");\n        revalidateTag('assignments-all', \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Delete assignment error:\", error);\n        return { success: false, error: \"Failed to delete assignment\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/my-assignments/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {refreshClassroomAssignments as '402d498415f6e7ce5e7b14101bd742a174c034fe89'} from 'ACTIONS_MODULE1'\nexport {deleteAssignment as '40633f0898d1f332fe16478be0d6f967b6ba4e7381'} from 'ACTIONS_MODULE1'\nexport {getAssignmentDetails as '40e471d809bf7114dcf724015755368fdab0ef103b'} from 'ACTIONS_MODULE1'\nexport {createAssignment as '604eabe0422d89d8eae28e459c0dae2ed6d7bab8fe'} from 'ACTIONS_MODULE1'\nexport {getAssignmentProgress as '6091a52b809a6452039e9aff921f36e5551e76d7f8'} from 'ACTIONS_MODULE1'\nexport {getStudentAssignments as '60bed825b9a6fa3bbf4a6def13537d7d61c2fa396a'} from 'ACTIONS_MODULE1'\nexport {getClassroomAssignments as '70b22c8ab63d11fc3b25b267ea271300db7487dcaa'} from 'ACTIONS_MODULE1'\nexport {getTeacherAssignmentAnalytics as '78073ece8699c8e6f210ef2e8915c5f3d914d87a4a'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAEA"}}]
}