{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { admin } from \"better-auth/plugins\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"./prisma\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n    disableSignUp: true,\n  },\n  socialProviders: {\n    google: {\n      enabled: true,\n      clientId: process.env.GOOGLE_CLIENT_ID as string,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n    microsoft: {\n      enabled: true,\n      clientId: process.env.MICROSOFT_CLIENT_ID as string,\n      clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"STUDENT\",\n      },\n      institutionId: {\n        type: \"string\",\n        required: false,\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n\n  plugins: [\n    admin({\n      adminRoles: [\"ADMIN\"],\n      defaultRole: \"STUDENT\",\n      adminUserIds: [\"jvp0LDpaCm0Y2VpUVP75vCNQnDioEdpm\"], // vishnu\n    }),\n  ],\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEO,MAAM,OAAO,IAAA,qKAAU,EAAC;IAC7B,UAAU,IAAA,8MAAa,EAAC,uHAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;QACT,eAAe;IACjB;IACA,iBAAiB;QACf,QAAQ;YACN,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;QACA,WAAW;YACT,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;YAChB;YACA,eAAe;gBACb,MAAM;gBACN,UAAU;YACZ;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IAEA,SAAS;QACP,IAAA,6KAAK,EAAC;YACJ,YAAY;gBAAC;aAAQ;YACrB,aAAa;YACb,cAAc;gBAAC;aAAmC;QACpD;KACD;AACH"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/category.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { ProblemDomain, Difficulty } from \"@prisma/client\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 300; // 5 minutes\n\n// CACHE KEY HELPERS\nconst getCategoriesCacheKey = (domain?: ProblemDomain) =>\n    domain ? `categories:${domain}:all` : \"categories:all\";\nconst getCategoryCacheKey = (slug: string) => `category:${slug}`;\nconst getCategoryProblemsCacheKey = (categoryId: string, page: number) =>\n    `category:${categoryId}:problems:page:${page}`;\n\nexport class CategoryService {\n    // GETTING ALL CATEGORIES\n    static async getCategories(domain: ProblemDomain = \"DSA\", userId?: string) {\n        try {\n            // ONLY CACHING THE BASE CATEGORIES STRUCTURE, NOT USER-SPECIFIC SOLVED COUNTS\n\n            const cacheKey = getCategoriesCacheKey(domain);\n            let categories: any[];\n\n            // GETTING CACHE FOR BASE CATEGORIES\n\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                categories = JSON.parse(cached).categories;\n            } else {\n                categories = await prisma.category.findMany({\n                    where: {\n                        domain\n                    },\n                    orderBy: { order: \"asc\" },\n                    select: {\n                        id: true,\n                        name: true,\n                        description: true,\n                        slug: true,\n                        order: true,\n                        domain: true,\n                        _count: {\n                            select: { categoryProblems: true }\n                        }\n                    }\n                });\n\n                // CACHING THE BASE CATEGORIES STRUCTURE IF NOT CACHED\n\n                await redis.setex(cacheKey, CACHE_TTL, JSON.stringify({ categories }));\n            }\n\n            // IF USER IS LOGGED IN, CALCULATING SOLVED COUNT PER CATEGORY\n\n            if (userId) {\n\n                // USING RAW QUERY FOR PERFORMANCE - 30X FASTER THAN FETCHING ALL ROWS\n\n                const solvedCountsRaw = await prisma.$queryRaw<any[]>`\n           SELECT\n             cp.\"categoryId\",\n             CAST(COUNT(DISTINCT cp.\"problemId\") AS INTEGER) as \"count\"\n           FROM \"CategoryProblem\" cp\n           JOIN \"Submission\" s ON cp.\"problemId\" = s.\"problemId\"\n           WHERE s.\"userId\" = ${userId}\n             AND s.\"status\" = 'ACCEPTED'::\"SubmissionResult\"\n             AND s.\"mode\" = 'SUBMIT'::\"SubmissionMode\"\n           GROUP BY cp.\"categoryId\"\n         `;\n\n                // CREATING A MAP OF SOLVED COUNT PER CATEGORY\n\n                const solvedMap = new Map<string, number>();\n                solvedCountsRaw.forEach((row: any) => {\n                    solvedMap.set(row.categoryId, row.count);\n                });\n\n                // MERGING INTO CATEGORIES\n                categories = categories.map((cat: any) => ({\n                    ...cat,\n                    solvedCount: solvedMap.get(cat.id) || 0\n                }));\n            } else {\n                // IF USER IS NOT LOGGED IN, SETTING SOLVED COUNT TO 0\n\n                categories = categories.map((cat: any) => ({\n                    ...cat,\n                    solvedCount: 0\n                }));\n            }\n\n            // RETURNING THE CATEGORIES\n\n            return { categories };\n        } catch (error) {\n            console.error(\"Failed to fetch categories:\", error);\n            return { categories: [] };\n        }\n    }\n\n    // GETTING A CATEGORY BY SLUG\n    static async getCategoryBySlug(slug: string) {\n        try {\n            const cacheKey = getCategoryCacheKey(slug);\n\n            // GETTING CACHE FOR CATEGORY\n\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                // RETURNING THE CACHE IF CACHED\n\n\n                return JSON.parse(cached);\n            }\n\n            // GETTING CATEGORY FROM DATABASE IF NOT CACHED\n\n            const category = await prisma.category.findUnique({\n                where: { slug },\n                include: {\n                    _count: {\n                        select: { categoryProblems: true }\n                    }\n                }\n            });\n\n            // IF CATEGORY IS NOT FOUND, RETURNING AN ERROR\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // CACHING THE CATEGORY\n\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(category));\n\n            return { success: true, category: category };\n        } catch (error) {\n            console.error(\"Failed to fetch category:\", error);\n            return { success: false, error: \"Failed to fetch category: \" + error };\n        }\n    }\n\n    // GETTING A CATEGORY BY ID --> NO CACHING\n    static async getCategoryById(id: string) {\n        try {\n            const category = await prisma.category.findUnique({\n                where: { id },\n                include: {\n                    _count: {\n                        select: { categoryProblems: true }\n                    }\n                }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            return { success: true, category };\n        } catch (error) {\n            console.error(\"Failed to fetch category:\", error);\n            return { success: false, error: \"Failed to fetch category\" };\n        }\n    }\n\n    // GETTING CATEGORY PROBLEMS\n    static async getCategoryProblems(\n        categoryId: string,\n        page: number = 1,\n        pageSize: number = 10,\n        userId?: string,\n        cursor?: string\n    ) {\n        try {\n            const cacheKey = cursor\n                ? `category:${categoryId}:problems:cursor:${cursor}`\n                : getCategoryProblemsCacheKey(categoryId, page);\n\n            // GETTING CACHE FOR CATEGORY PROBLEMS IF NOT CACHED\n            if (!userId || (page === 1 && !cursor)) {\n                const cached = await redis.get(cacheKey);\n                if (cached) {\n\n                    const parsed = JSON.parse(cached);\n                    // IF USER IS AUTHENTICATED, WE NEED TO CHECK SOLVED STATUS\n                    if (userId) {\n                        const problemIds = parsed.problems.map((p: any) => p.id);\n                        const solvedProblems = await prisma.submission.findMany({\n                            where: {\n                                userId,\n                                problemId: { in: problemIds },\n                                status: \"ACCEPTED\",\n                                mode: \"SUBMIT\"\n                            },\n                            select: { problemId: true },\n                            distinct: [\"problemId\"]\n                        });\n                        const solvedSet = new Set(solvedProblems.map(s => s.problemId));\n                        parsed.problems = parsed.problems.map((p: any) => ({\n                            ...p,\n                            isSolved: solvedSet.has(p.id)\n                        }));\n                    }\n                    return parsed;\n                }\n            }\n\n            const [categoryProblems, total] = await Promise.all([\n                prisma.categoryProblem.findMany({\n                    where: { categoryId },\n                    take: pageSize,\n                    orderBy: { order: \"asc\" },\n                    skip: cursor ? 1 : (page - 1) * pageSize,\n                    ...(cursor ? { cursor: { id: cursor } } : {}),\n                    include: {\n                        problem: {\n                            include: {\n                                _count: { select: { submissions: true } },\n                                ...(userId ? {\n                                    submissions: {\n                                        where: {\n                                            userId,\n                                            status: \"ACCEPTED\",\n                                            mode: \"SUBMIT\"\n                                        },\n                                        take: 1,\n                                        select: { id: true }\n                                    }\n                                } : {})\n                            }\n                        }\n                    }\n                }),\n                prisma.categoryProblem.count({ where: { categoryId } })\n            ]);\n\n            const problems = categoryProblems.map((cp) => {\n                const p = cp.problem;\n                const isSolved = (p as any).submissions?.length > 0;\n                return {\n                    ...p,\n                    isSolved,\n                    acceptance: p._count.submissions > 0\n                        ? ((p.solved || 0) / p._count.submissions) * 100\n                        : 0,\n                    submissions: undefined\n                };\n            });\n\n            const result = {\n                problems,\n                totalPages: Math.ceil(total / pageSize),\n                currentPage: page,\n                total\n            };\n\n            // Cache result (only for first page or cursor and non-authenticated)\n            if (!userId || (page === 1 && !cursor)) {\n                await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n            }\n\n            return result;\n        } catch (error) {\n            console.error(\"Failed to fetch category problems:\", error);\n            return { problems: [], totalPages: 0, currentPage: page, total: 0 };\n        }\n    }\n\n    // CREATING A CATEGORY\n    static async createCategory(data: {\n        name: string;\n        description?: string;\n        slug: string;\n        order?: number;\n        domain?: ProblemDomain;\n    }) {\n        try {\n            // CREATING THE CATEGORY\n\n            const category = await prisma.category.create({\n                data: {\n                    name: data.name,\n                    description: data.description,\n                    slug: data.slug,\n                    order: data.order ?? 0,\n                    domain: data.domain || \"DSA\"\n                }\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            // RETURNING THE SUCCESS AND THE CATEGORY\n            return { success: true, category: category };\n\n        } catch (error: any) {\n            console.error(\"Failed to create category:\", error);\n            return {\n                success: false,\n                error: error.code === \"P2002\" ? \"Slug already exists\" : \"Failed to create category\"\n            };\n        }\n    }\n\n    // UPDATING A CATEGORY\n    static async updateCategory(id: string, data: { name?: string; description?: string; slug?: string; order?: number; }) {\n        try {\n            const category = await prisma.category.update({\n                where: { id },\n                data\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            await redis.del(getCategoryCacheKey(category.slug));\n\n            return { success: true, category };\n        } catch (error) {\n            console.error(\"Failed to update category:\", error);\n            return { success: false, error: \"Failed to update category\" };\n        }\n    }\n\n    // DELETING A CATEGORY\n    static async deleteCategory(id: string) {\n        try {\n            const category = await prisma.category.findUnique({\n                where: { id },\n                select: { slug: true }\n            });\n\n            await prisma.category.delete({\n                where: { id }\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            // INVALIDATING THE CACHE FOR THE CATEGORY IF IT EXISTS\n            if (category) {\n                await redis.del(getCategoryCacheKey(category.slug));\n            }\n\n            return { success: true, slug: category?.slug };\n        } catch (error) {\n            console.error(\"Failed to delete category:\", error);\n            return { success: false, error: \"Failed to delete category\" };\n        }\n    }\n\n    // ADDING A PROBLEM TO A CATEGORY\n    static async addProblemToCategory(\n        categoryId: string,\n        problemId: string,\n        order?: number\n    ) {\n        try {\n            // GETTING THE CATEGORY TO GET ITS DOMAIN\n            const category = await prisma.category.findUnique({\n                where: { id: categoryId },\n                select: { domain: true, slug: true }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // UPDATING THE PROBLEM TO BE OF TYPE LEARN AND MATCH CATEGORY DOMAIN\n\n            await prisma.problem.update({\n                where: { id: problemId },\n                data: {\n                    type: \"LEARN\",\n                    domain: category.domain\n                }\n            });\n\n            // CREATING THE CATEGORY PROBLEM\n\n            const categoryProblem = await prisma.categoryProblem.create({\n                data: {\n                    categoryId,\n                    problemId,\n                    order: order ?? 0\n                },\n                include: {\n                    problem: true,\n                    category: true\n                }\n            });\n\n            // INVALIDATING THE CACHE FOR THE CATEGORY PROBLEMS\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n            await redis.del(getCategoryCacheKey(categoryProblem.category.slug));\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            return { success: true, categoryProblem };\n        } catch (error: any) {\n            console.error(\"Failed to add problem to category:\", error);\n            if (error.code === \"P2002\") {\n                return { success: false, error: \"Problem already in category\" };\n            }\n            return { success: false, error: \"Failed to add problem to category\" };\n        }\n    }\n\n    // REMOVING A PROBLEM FROM A CATEGORY\n    static async removeProblemFromCategory(\n        categoryId: string,\n        problemId: string\n    ) {\n        try {\n\n            // DELETING THE CATEGORY PROBLEM\n\n            await prisma.categoryProblem.delete({\n                where: {\n                    categoryId_problemId: {\n                        categoryId,\n                        problemId\n                    }\n                }\n            });\n\n            // INVALIDATING THE CACHE FOR THE CATEGORY PROBLEMS\n\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to remove problem from category:\", error);\n            return { success: false, error: \"Failed to remove problem from category\" };\n        }\n    }\n\n    // CREATING A PROBLEM AND ADDING IT TO A CATEGORY\n    static async createProblemAndAddToCategory(\n        categoryId: string,\n        data: {\n            title: string;\n            description: string;\n            difficulty: Difficulty;\n            slug: string;\n            hidden: boolean;\n            hiddenQuery?: string | null;\n            testCases?: { input: string; output: string; hidden?: boolean }[];\n        }\n    ) {\n        try {\n            // GETTING THE CATEGORY TO GET ITS DOMAIN\n            const category = await prisma.category.findUnique({\n                where: { id: categoryId },\n                select: { domain: true, slug: true }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // CREATING THE PROBLEM AS TYPE LEARN WITH CATEGORY DOMAIN\n            const problem = await prisma.problem.create({\n                data: {\n                    title: data.title,\n                    description: data.description,\n                    difficulty: data.difficulty,\n                    slug: data.slug,\n                    score: data.difficulty === \"CONCEPT\" ? 0 : 10,\n                    hidden: data.hidden,\n                    hiddenQuery: data.hiddenQuery || null,\n                    type: \"LEARN\",\n                    domain: category.domain,\n                    testCases: {\n                        create: data.testCases?.map(tc => ({\n                            input: tc.input,\n                            output: tc.output,\n                            hidden: tc.hidden ?? false\n                        })) || []\n                    }\n                },\n            });\n\n            // ADDING THE PROBLEM TO THE CATEGORY\n            await prisma.categoryProblem.create({\n                data: {\n                    categoryId,\n                    problemId: problem.id,\n                    order: 0\n                }\n            });\n\n            // INVALIDATING THE CACHE\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n            await redis.del(getCategoryCacheKey(category.slug));\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            // INVALIDATING PROBLEM CACHES\n            const problemCachePattern = \"problems:*\";\n            const problemKeys = await redis.keys(problemCachePattern);\n            if (problemKeys.length > 0) {\n                await redis.del(...problemKeys);\n            }\n\n            return { success: true, problem };\n        } catch (error: any) {\n            console.error(\"Failed to create problem and add to category:\", error);\n            if (error.code === \"P2002\") {\n                return { success: false, error: \"Problem slug already exists\" };\n            }\n            return { success: false, error: error.message || \"Failed to create problem and add to category\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AAEA;;;AAEA,MAAM,YAAY,KAAK,YAAY;AAEnC,oBAAoB;AACpB,MAAM,wBAAwB,CAAC,SAC3B,SAAS,CAAC,WAAW,EAAE,OAAO,IAAI,CAAC,GAAG;AAC1C,MAAM,sBAAsB,CAAC,OAAiB,CAAC,SAAS,EAAE,MAAM;AAChE,MAAM,8BAA8B,CAAC,YAAoB,OACrD,CAAC,SAAS,EAAE,WAAW,eAAe,EAAE,MAAM;AAE3C,MAAM;IACT,yBAAyB;IACzB,aAAa,cAAc,SAAwB,KAAK,EAAE,MAAe,EAAE;QACvE,IAAI;YACA,8EAA8E;YAE9E,MAAM,WAAW,sBAAsB;YACvC,IAAI;YAEJ,oCAAoC;YAEpC,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,aAAa,KAAK,KAAK,CAAC,QAAQ,UAAU;YAC9C,OAAO;gBACH,aAAa,MAAM,uHAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;oBACxC,OAAO;wBACH;oBACJ;oBACA,SAAS;wBAAE,OAAO;oBAAM;oBACxB,QAAQ;wBACJ,IAAI;wBACJ,MAAM;wBACN,aAAa;wBACb,MAAM;wBACN,OAAO;wBACP,QAAQ;wBACR,QAAQ;4BACJ,QAAQ;gCAAE,kBAAkB;4BAAK;wBACrC;oBACJ;gBACJ;gBAEA,sDAAsD;gBAEtD,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,KAAK,SAAS,CAAC;oBAAE;gBAAW;YACvE;YAEA,8DAA8D;YAE9D,IAAI,QAAQ;gBAER,sEAAsE;gBAEtE,MAAM,kBAAkB,MAAM,uHAAM,CAAC,SAAS,AAAO,CAAC;;;;;;8BAMxC,EAAE,OAAO;;;;SAI9B,CAAC;gBAEM,8CAA8C;gBAE9C,MAAM,YAAY,IAAI;gBACtB,gBAAgB,OAAO,CAAC,CAAC;oBACrB,UAAU,GAAG,CAAC,IAAI,UAAU,EAAE,IAAI,KAAK;gBAC3C;gBAEA,0BAA0B;gBAC1B,aAAa,WAAW,GAAG,CAAC,CAAC,MAAa,CAAC;wBACvC,GAAG,GAAG;wBACN,aAAa,UAAU,GAAG,CAAC,IAAI,EAAE,KAAK;oBAC1C,CAAC;YACL,OAAO;gBACH,sDAAsD;gBAEtD,aAAa,WAAW,GAAG,CAAC,CAAC,MAAa,CAAC;wBACvC,GAAG,GAAG;wBACN,aAAa;oBACjB,CAAC;YACL;YAEA,2BAA2B;YAE3B,OAAO;gBAAE;YAAW;QACxB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;gBAAE,YAAY,EAAE;YAAC;QAC5B;IACJ;IAEA,6BAA6B;IAC7B,aAAa,kBAAkB,IAAY,EAAE;QACzC,IAAI;YACA,MAAM,WAAW,oBAAoB;YAErC,6BAA6B;YAE7B,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,gCAAgC;gBAGhC,OAAO,KAAK,KAAK,CAAC;YACtB;YAEA,+CAA+C;YAE/C,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE;gBAAK;gBACd,SAAS;oBACL,QAAQ;wBACJ,QAAQ;4BAAE,kBAAkB;wBAAK;oBACrC;gBACJ;YACJ;YAEA,+CAA+C;YAE/C,IAAI,CAAC,UAAU;gBACX,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAAqB;YACzD;YAEA,uBAAuB;YAEvB,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,KAAK,SAAS,CAAC;YAEtD,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAS;QAC/C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO,+BAA+B;YAAM;QACzE;IACJ;IAEA,0CAA0C;IAC1C,aAAa,gBAAgB,EAAU,EAAE;QACrC,IAAI;YACA,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE;gBAAG;gBACZ,SAAS;oBACL,QAAQ;wBACJ,QAAQ;4BAAE,kBAAkB;wBAAK;oBACrC;gBACJ;YACJ;YAEA,IAAI,CAAC,UAAU;gBACX,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAAqB;YACzD;YAEA,OAAO;gBAAE,SAAS;gBAAM;YAAS;QACrC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;IACJ;IAEA,4BAA4B;IAC5B,aAAa,oBACT,UAAkB,EAClB,OAAe,CAAC,EAChB,WAAmB,EAAE,EACrB,MAAe,EACf,MAAe,EACjB;QACE,IAAI;YACA,MAAM,WAAW,SACX,CAAC,SAAS,EAAE,WAAW,iBAAiB,EAAE,QAAQ,GAClD,4BAA4B,YAAY;YAE9C,oDAAoD;YACpD,IAAI,CAAC,UAAW,SAAS,KAAK,CAAC,QAAS;gBACpC,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;gBAC/B,IAAI,QAAQ;oBAER,MAAM,SAAS,KAAK,KAAK,CAAC;oBAC1B,2DAA2D;oBAC3D,IAAI,QAAQ;wBACR,MAAM,aAAa,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAW,EAAE,EAAE;wBACvD,MAAM,iBAAiB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;4BACpD,OAAO;gCACH;gCACA,WAAW;oCAAE,IAAI;gCAAW;gCAC5B,QAAQ;gCACR,MAAM;4BACV;4BACA,QAAQ;gCAAE,WAAW;4BAAK;4BAC1B,UAAU;gCAAC;6BAAY;wBAC3B;wBACA,MAAM,YAAY,IAAI,IAAI,eAAe,GAAG,CAAC,CAAA,IAAK,EAAE,SAAS;wBAC7D,OAAO,QAAQ,GAAG,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAW,CAAC;gCAC/C,GAAG,CAAC;gCACJ,UAAU,UAAU,GAAG,CAAC,EAAE,EAAE;4BAChC,CAAC;oBACL;oBACA,OAAO;gBACX;YACJ;YAEA,MAAM,CAAC,kBAAkB,MAAM,GAAG,MAAM,QAAQ,GAAG,CAAC;gBAChD,uHAAM,CAAC,eAAe,CAAC,QAAQ,CAAC;oBAC5B,OAAO;wBAAE;oBAAW;oBACpB,MAAM;oBACN,SAAS;wBAAE,OAAO;oBAAM;oBACxB,MAAM,SAAS,IAAI,CAAC,OAAO,CAAC,IAAI;oBAChC,GAAI,SAAS;wBAAE,QAAQ;4BAAE,IAAI;wBAAO;oBAAE,IAAI,CAAC,CAAC;oBAC5C,SAAS;wBACL,SAAS;4BACL,SAAS;gCACL,QAAQ;oCAAE,QAAQ;wCAAE,aAAa;oCAAK;gCAAE;gCACxC,GAAI,SAAS;oCACT,aAAa;wCACT,OAAO;4CACH;4CACA,QAAQ;4CACR,MAAM;wCACV;wCACA,MAAM;wCACN,QAAQ;4CAAE,IAAI;wCAAK;oCACvB;gCACJ,IAAI,CAAC,CAAC;4BACV;wBACJ;oBACJ;gBACJ;gBACA,uHAAM,CAAC,eAAe,CAAC,KAAK,CAAC;oBAAE,OAAO;wBAAE;oBAAW;gBAAE;aACxD;YAED,MAAM,WAAW,iBAAiB,GAAG,CAAC,CAAC;gBACnC,MAAM,IAAI,GAAG,OAAO;gBACpB,MAAM,WAAW,AAAC,EAAU,WAAW,EAAE,SAAS;gBAClD,OAAO;oBACH,GAAG,CAAC;oBACJ;oBACA,YAAY,EAAE,MAAM,CAAC,WAAW,GAAG,IAC7B,AAAC,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,WAAW,GAAI,MAC3C;oBACN,aAAa;gBACjB;YACJ;YAEA,MAAM,SAAS;gBACX;gBACA,YAAY,KAAK,IAAI,CAAC,QAAQ;gBAC9B,aAAa;gBACb;YACJ;YAEA,qEAAqE;YACrE,IAAI,CAAC,UAAW,SAAS,KAAK,CAAC,QAAS;gBACpC,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,KAAK,SAAS,CAAC;YAC1D;YAEA,OAAO;QACX,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,sCAAsC;YACpD,OAAO;gBAAE,UAAU,EAAE;gBAAE,YAAY;gBAAG,aAAa;gBAAM,OAAO;YAAE;QACtE;IACJ;IAEA,sBAAsB;IACtB,aAAa,eAAe,IAM3B,EAAE;QACC,IAAI;YACA,wBAAwB;YAExB,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;gBAC1C,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,aAAa,KAAK,WAAW;oBAC7B,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,KAAK,IAAI;oBACrB,QAAQ,KAAK,MAAM,IAAI;gBAC3B;YACJ;YAEA,yBAAyB;YAEzB,MAAM,uHAAK,CAAC,GAAG,CAAC;YAChB,MAAM,uHAAK,CAAC,GAAG,CAAC,sBAAsB,SAAS,MAAM;YAErD,yCAAyC;YACzC,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAS;QAE/C,EAAE,OAAO,OAAY;YACjB,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO;gBACH,SAAS;gBACT,OAAO,MAAM,IAAI,KAAK,UAAU,wBAAwB;YAC5D;QACJ;IACJ;IAEA,sBAAsB;IACtB,aAAa,eAAe,EAAU,EAAE,IAA6E,EAAE;QACnH,IAAI;YACA,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;gBAC1C,OAAO;oBAAE;gBAAG;gBACZ;YACJ;YAEA,yBAAyB;YAEzB,MAAM,uHAAK,CAAC,GAAG,CAAC;YAChB,MAAM,uHAAK,CAAC,GAAG,CAAC,oBAAoB,SAAS,IAAI;YAEjD,OAAO;gBAAE,SAAS;gBAAM;YAAS;QACrC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA4B;QAChE;IACJ;IAEA,sBAAsB;IACtB,aAAa,eAAe,EAAU,EAAE;QACpC,IAAI;YACA,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE;gBAAG;gBACZ,QAAQ;oBAAE,MAAM;gBAAK;YACzB;YAEA,MAAM,uHAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;gBACzB,OAAO;oBAAE;gBAAG;YAChB;YAEA,yBAAyB;YAEzB,MAAM,uHAAK,CAAC,GAAG,CAAC;YAChB,uDAAuD;YACvD,IAAI,UAAU;gBACV,MAAM,uHAAK,CAAC,GAAG,CAAC,oBAAoB,SAAS,IAAI;YACrD;YAEA,OAAO;gBAAE,SAAS;gBAAM,MAAM,UAAU;YAAK;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA4B;QAChE;IACJ;IAEA,iCAAiC;IACjC,aAAa,qBACT,UAAkB,EAClB,SAAiB,EACjB,KAAc,EAChB;QACE,IAAI;YACA,yCAAyC;YACzC,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE,IAAI;gBAAW;gBACxB,QAAQ;oBAAE,QAAQ;oBAAM,MAAM;gBAAK;YACvC;YAEA,IAAI,CAAC,UAAU;gBACX,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAAqB;YACzD;YAEA,qEAAqE;YAErE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxB,OAAO;oBAAE,IAAI;gBAAU;gBACvB,MAAM;oBACF,MAAM;oBACN,QAAQ,SAAS,MAAM;gBAC3B;YACJ;YAEA,gCAAgC;YAEhC,MAAM,kBAAkB,MAAM,uHAAM,CAAC,eAAe,CAAC,MAAM,CAAC;gBACxD,MAAM;oBACF;oBACA;oBACA,OAAO,SAAS;gBACpB;gBACA,SAAS;oBACL,SAAS;oBACT,UAAU;gBACd;YACJ;YAEA,mDAAmD;YACnD,MAAM,eAAe,CAAC,SAAS,EAAE,WAAW,WAAW,CAAC;YACxD,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;YAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;gBACjB,MAAM,uHAAK,CAAC,GAAG,IAAI;YACvB;YACA,MAAM,uHAAK,CAAC,GAAG,CAAC,oBAAoB,gBAAgB,QAAQ,CAAC,IAAI;YACjE,MAAM,uHAAK,CAAC,GAAG,CAAC,sBAAsB,SAAS,MAAM;YAErD,OAAO;gBAAE,SAAS;gBAAM;YAAgB;QAC5C,EAAE,OAAO,OAAY;YACjB,QAAQ,KAAK,CAAC,sCAAsC;YACpD,IAAI,MAAM,IAAI,KAAK,SAAS;gBACxB,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAA8B;YAClE;YACA,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoC;QACxE;IACJ;IAEA,qCAAqC;IACrC,aAAa,0BACT,UAAkB,EAClB,SAAiB,EACnB;QACE,IAAI;YAEA,gCAAgC;YAEhC,MAAM,uHAAM,CAAC,eAAe,CAAC,MAAM,CAAC;gBAChC,OAAO;oBACH,sBAAsB;wBAClB;wBACA;oBACJ;gBACJ;YACJ;YAEA,mDAAmD;YAEnD,MAAM,eAAe,CAAC,SAAS,EAAE,WAAW,WAAW,CAAC;YACxD,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;YAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;gBACjB,MAAM,uHAAK,CAAC,GAAG,IAAI;YACvB;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,2CAA2C;YACzD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAyC;QAC7E;IACJ;IAEA,iDAAiD;IACjD,aAAa,8BACT,UAAkB,EAClB,IAQC,EACH;QACE,IAAI;YACA,yCAAyC;YACzC,MAAM,WAAW,MAAM,uHAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE,IAAI;gBAAW;gBACxB,QAAQ;oBAAE,QAAQ;oBAAM,MAAM;gBAAK;YACvC;YAEA,IAAI,CAAC,UAAU;gBACX,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAAqB;YACzD;YAEA,0DAA0D;YAC1D,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxC,MAAM;oBACF,OAAO,KAAK,KAAK;oBACjB,aAAa,KAAK,WAAW;oBAC7B,YAAY,KAAK,UAAU;oBAC3B,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,UAAU,KAAK,YAAY,IAAI;oBAC3C,QAAQ,KAAK,MAAM;oBACnB,aAAa,KAAK,WAAW,IAAI;oBACjC,MAAM;oBACN,QAAQ,SAAS,MAAM;oBACvB,WAAW;wBACP,QAAQ,KAAK,SAAS,EAAE,IAAI,CAAA,KAAM,CAAC;gCAC/B,OAAO,GAAG,KAAK;gCACf,QAAQ,GAAG,MAAM;gCACjB,QAAQ,GAAG,MAAM,IAAI;4BACzB,CAAC,MAAM,EAAE;oBACb;gBACJ;YACJ;YAEA,qCAAqC;YACrC,MAAM,uHAAM,CAAC,eAAe,CAAC,MAAM,CAAC;gBAChC,MAAM;oBACF;oBACA,WAAW,QAAQ,EAAE;oBACrB,OAAO;gBACX;YACJ;YAEA,yBAAyB;YACzB,MAAM,eAAe,CAAC,SAAS,EAAE,WAAW,WAAW,CAAC;YACxD,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;YAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;gBACjB,MAAM,uHAAK,CAAC,GAAG,IAAI;YACvB;YACA,MAAM,uHAAK,CAAC,GAAG,CAAC,oBAAoB,SAAS,IAAI;YACjD,MAAM,uHAAK,CAAC,GAAG,CAAC,sBAAsB,SAAS,MAAM;YAErD,8BAA8B;YAC9B,MAAM,sBAAsB;YAC5B,MAAM,cAAc,MAAM,uHAAK,CAAC,IAAI,CAAC;YACrC,IAAI,YAAY,MAAM,GAAG,GAAG;gBACxB,MAAM,uHAAK,CAAC,GAAG,IAAI;YACvB;YAEA,OAAO;gBAAE,SAAS;gBAAM;YAAQ;QACpC,EAAE,OAAO,OAAY;YACjB,QAAQ,KAAK,CAAC,iDAAiD;YAC/D,IAAI,MAAM,IAAI,KAAK,SAAS;gBACxB,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAA8B;YAClE;YACA,OAAO;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO,IAAI;YAA+C;QACpG;IACJ;AACJ"}},
    {"offset": {"line": 1304, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/category.action.ts"],"sourcesContent":["\"use server\";\n\nimport { CategoryService } from \"@/core/services/category.service\";\nimport { ProblemDomain, Difficulty } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING ALL CATEGORIES\n\nexport async function getCategories(domain: ProblemDomain = \"DSA\") {\n  \"use cache: private\"; // Must be at top - allows headers() inside\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const userId = session?.user?.id;\n\n  cacheTag(`categories-${domain}${userId ? `-user-${userId}` : ''}`, 'categories-list');\n\n  return CategoryService.getCategories(domain, userId);\n}\n\n// GETTING A CATEGORY BY SLUG\n\nexport async function getCategory(slug: string) {\n  \"use cache\";\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  cacheTag(`category-${slug}`, 'categories-list');\n\n  return CategoryService.getCategoryBySlug(slug);\n}\n\n// GETTING A CATEGORY BY ID --> NO CACHING\n\nexport async function getCategoryById(id: string) {\n  return CategoryService.getCategoryById(id);\n}\n\n// GETTING CATEGORY PROBLEMS\n\nexport async function getCategoryProblems(\n  categoryId: string,\n  page: number = 1,\n  pageSize: number = 10,\n  cursor?: string\n) {\n  \"use cache: private\"; // Must be at top - allows headers() inside\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const userId = session?.user?.id;\n\n  const tagKey = `category-problems-${categoryId}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n  cacheTag(tagKey, `category-${categoryId}`, 'categories-list');\n\n  return CategoryService.getCategoryProblems(categoryId, page, pageSize, userId, cursor);\n}\n\n\n// CREATING A CATEGORY --> ADMIN ONLY\n\nexport async function createCategory(data: {\n  name: string;\n  description?: string;\n  slug: string;\n  order?: number;\n  domain?: ProblemDomain;\n}) {\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.createCategory(data);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n  }\n\n  return result;\n}\n\n// UPDATING A CATEGORY --> ADMIN ONLY\n\nexport async function updateCategory(id: string, data: { name?: string; description?: string; slug?: string; order?: number; }) {\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.updateCategory(id, data);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS --> PROBLEMS AND ADMIN CATEGORIES\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n    if (data.slug) {\n      updateTag(`category-${data.slug}`);\n    }\n  }\n\n  return result;\n}\n\n// DELETING A CATEGORY --> ADMIN ONLY\n\nexport async function deleteCategory(id: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.deleteCategory(id);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS --> PROBLEMS AND ADMIN CATEGORIES\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n    if (result.slug) {\n      updateTag(`category-${result.slug}`);\n    }\n  }\n\n  return result;\n}\n\n\n// ADDING A PROBLEM TO A CATEGORY --> ADMIN ONLY\n\nexport async function addProblemToCategory(\n  categoryId: string,\n  problemId: string,\n  order?: number\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.addProblemToCategory(categoryId, problemId, order);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n    revalidatePath(`/admin/dsa/categories/${categoryId}`);\n    revalidatePath(`/admin/sql/categories/${categoryId}`);\n    updateTag(`category-${categoryId}`);\n    updateTag('categories-list');\n  }\n\n  return result;\n}\n\n\n// REMOVING A PROBLEM FROM A CATEGORY --> ADMIN ONLY\n\nexport async function removeProblemFromCategory(\n  categoryId: string,\n  problemId: string\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.removeProblemFromCategory(categoryId, problemId);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n  }\n\n  return result;\n}\n\n// CREATING A PROBLEM AND ADDING IT TO A CATEGORY --> ADMIN ONLY\n\nexport async function createProblemAndAddToCategory(\n  categoryId: string,\n  data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    testCases?: { input: string; output: string; hidden?: boolean }[];\n  }\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.createProblemAndAddToCategory(categoryId, data);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n    revalidatePath(`/admin/dsa/categories/${categoryId}`);\n    revalidatePath(`/admin/sql/categories/${categoryId}`);\n    revalidatePath(\"/admin/problems\");\n    revalidatePath(\"/admin/dsa/problems\");\n    revalidatePath(\"/admin/sql/problems\");\n  }\n\n  return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1544, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28main%29/admin/dsa/categories/%5Bid%5D/edit/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE1'\nexport {getCategoryById as '403eb3bc9aea3dcf45bb95c52ceaca0a531010fb54'} from 'ACTIONS_MODULE2'\nexport {updateCategory as '607f577dab8934db5f4e4e7801195ec96d7d899a06'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AAEA;AACA"}}]
}