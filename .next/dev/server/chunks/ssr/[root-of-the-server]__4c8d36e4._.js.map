{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { admin } from \"better-auth/plugins\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"./prisma\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n    disableSignUp: true,\n  },\n  socialProviders: {\n    google: {\n      enabled: true,\n      clientId: process.env.GOOGLE_CLIENT_ID as string,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n    microsoft: {\n      enabled: true,\n      clientId: process.env.MICROSOFT_CLIENT_ID as string,\n      clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"STUDENT\",\n      },\n      institutionId: {\n        type: \"string\",\n        required: false,\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n\n  plugins: [\n    admin({\n      adminRoles: [\"ADMIN\"],\n      defaultRole: \"STUDENT\",\n      adminUserIds: [\"jvp0LDpaCm0Y2VpUVP75vCNQnDioEdpm\"], // vishnu\n    }),\n  ],\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEO,MAAM,OAAO,IAAA,qKAAU,EAAC;IAC7B,UAAU,IAAA,8MAAa,EAAC,uHAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;QACT,eAAe;IACjB;IACA,iBAAiB;QACf,QAAQ;YACN,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;QACA,WAAW;YACT,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;YAChB;YACA,eAAe;gBACb,MAAM;gBACN,UAAU;YACZ;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IAEA,SAAS;QACP,IAAA,6KAAK,EAAC;YACJ,YAAY;gBAAC;aAAQ;YACrB,aAAa;YACb,cAAc;gBAAC;aAAmC;QACpD;KACD;AACH"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/problem.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 300; // 5 minutes\nconst PROBLEM_CACHE_TTL = 3600; // 1 hour\n\n// CACHE KEY HELPERS\nconst getProblemsCacheKey = (type: ProblemType, domain: ProblemDomain, page: number, diff?: Difficulty, tags: string[] = []) =>\n    `problems:list:${domain}:${type}:page:${page}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`;\nconst getAdminProblemsCacheKey = (domain: string | undefined, page: number) =>\n    `admin:problems:${domain || 'all'}:page:${page}`;\nconst getProblemCacheKey = (slug: string) => `problem:${slug}`;\n\nexport class ProblemService {\n\n    // CACHED FETCHER FOR PUBLIC PROBLEM LIST\n    private static async getCachedProblems(page: number, pageSize: number, type: ProblemType, domain: ProblemDomain = \"DSA\", diff?: Difficulty, tags: string[] = [], cursor?: string) {\n        // We use page for cache key primarily, but if cursor is used, it's for infinite scroll which often is bypass-cache or unique key\n        const cacheKey = cursor\n            ? `problems:list:${domain}:${type}:cursor:${cursor}:pageSize:${pageSize}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`\n            : getProblemsCacheKey(type, domain, page, diff, tags);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const query: any = {\n            where: {\n                type,\n                domain,\n                difficulty: diff,\n                hidden: false,\n                tags: tags.length > 0 ? {\n                    some: {\n                        slug: { in: tags }\n                    }\n                } : undefined\n            },\n            take: pageSize,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        };\n\n        if (cursor) {\n            query.cursor = { id: cursor };\n            query.skip = 1; // Skip the item already fetched\n        } else {\n            query.skip = (page - 1) * pageSize;\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany(query),\n            prisma.problem.count({\n                where: {\n                    type,\n                    domain,\n                    difficulty: diff,\n                    hidden: false,\n                    tags: tags.length > 0 ? {\n                        some: {\n                            slug: { in: tags }\n                        }\n                    } : undefined\n                }\n            })\n        ]);\n\n        const result = { problems, total };\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // GETTING PUBLIC PROBLEMS\n    static async getProblems(\n        page: number = 1,\n        pageSize: number = 10,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string,\n        diff?: Difficulty,\n        tags: string[] = [],\n        cursor?: string\n    ) {\n        // FETCHING PUBLIC DATA (CACHED)\n        const { problems, total } = await this.getCachedProblems(page, pageSize, type, domain, diff, tags, cursor);\n\n        // IF USER IS LOGGED IN, FETCHING THEIR SOLVED STATUS FOR THESE SPECIFIC PROBLEMS\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map((p: any) => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        // MERGING DATA\n        const problemsWithStats = problems.map((p: any) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return {\n            problems: problemsWithStats,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n    }\n\n    // GETTING ADMIN PROBLEMS\n    static async getAdminProblems(\n        page: number = 1,\n        pageSize: number = 50,\n        domain?: ProblemDomain,\n        excludeDifficulty?: Difficulty,\n        type?: ProblemType\n    ) {\n        const cacheKey = getAdminProblemsCacheKey(domain, page);\n        // Note: cache key doesn't include excludeDifficulty which could be an issue if we vary it often,\n        // but for now only one usage pattern exists per page.\n        // Ideally we should append it to cache key but let's keep it simple as per plan.\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n                // If we have cached data, we might need to filter it manually if the cache key doesn't support variations\n                // But for now let's assume cache key strategy needs update if we want perfect caching.\n                // However, user just wants filtering. Let's bypass cache if we have specific filter or update cache key.\n                // Actually, let's just proceed with fetching fresh if we use filters or rely on the query.\n                // Given the current cache implementation is simple, let's just do the query.\n\n                // return JSON.parse(cached); // Disabling cache return for filtered requests for safety or we update key\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const skip = (page - 1) * pageSize;\n        const where: any = domain ? { domain } : {};\n\n        if (type) {\n            where.type = type;\n        } else {\n            where.type = { not: \"CONTEST\" };\n        }\n\n        if (excludeDifficulty) {\n            where.difficulty = { not: excludeDifficulty };\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany({\n                where,\n                skip,\n                take: pageSize,\n                orderBy: { createdAt: 'desc' },\n                select: {\n                    id: true,\n                    title: true,\n                    slug: true,\n                    difficulty: true,\n                    hidden: true,\n                    score: true,\n                    type: true,\n                    domain: true,\n                    createdAt: true,\n                    updatedAt: true,\n                }\n            }),\n            prisma.problem.count({ where })\n        ]);\n\n        const result = {\n            problems,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // SEARCHING FOR PROBLEMS\n    static async searchProblems(\n        term: string,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string\n    ) {\n        const problems = await prisma.problem.findMany({\n            where: {\n                type,\n                domain,\n                hidden: false,\n                title: {\n                    contains: term,\n                    mode: 'insensitive'\n                }\n            },\n            take: 10,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        });\n\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map(p => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        const problemsWithStats = problems.map((p) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return { problems: problemsWithStats };\n    }\n\n    // CACHED FETCHER FOR SINGLE PROBLEM\n    private static async getCachedProblem(slug: string) {\n        const cacheKey = getProblemCacheKey(slug);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const problem = await prisma.problem.findUnique({\n            where: { slug },\n            include: {\n                testCases: true,\n                user: { select: { name: true, image: true } },\n                tags: { select: { name: true, slug: true } },\n                functionTemplates: true // Include for DSA function template boilerplates\n            }\n        });\n\n        if (problem) {\n            try {\n                await redis.setex(cacheKey, PROBLEM_CACHE_TTL, JSON.stringify(problem));\n            } catch (error) {\n                console.error(\"Redis set error:\", error);\n            }\n        }\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY SLUG CACHED\n    static async getProblem(slug: string) {\n        const problem = await this.getCachedProblem(slug);\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY ID\n    static async getProblemById(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({\n                where: { id },\n                include: {\n                    testCases: true,\n                    tags: { select: { name: true, slug: true } },\n                    functionTemplates: true\n                }\n            });\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to get problem by id:\", error);\n            return { success: false, error: \"Failed to get problem by id\" };\n        }\n    }\n\n    // GETTING NEXT PROBLEM\n    static async getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const nextProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        lt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'desc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return nextProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get next problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING PREVIOUS PROBLEM\n    static async getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const prevProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        gt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'asc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return prevProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get previous problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING RANDOM PROBLEM\n    static async getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n        try {\n           // efficient random selection using raw query or count-based skip\n           const count = await prisma.problem.count({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               }\n           });\n\n           if (count === 0) return null;\n\n           const skip = Math.floor(Math.random() * count);\n           const randomProblem = await prisma.problem.findFirst({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               },\n               skip,\n               select: {\n                   slug: true\n               }\n           });\n\n           return randomProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get random problem:\", error);\n            return null;\n        }\n    }\n\n    // CREATING A PROBLEM\n    static async createProblem(data: {\n        title: string;\n        description: string;\n        difficulty: Difficulty;\n        slug: string;\n        hidden: boolean;\n        hiddenQuery?: string | null;\n        domain?: ProblemDomain;\n        testCases: { input: string; output: string; hidden?: boolean }[];\n        tags?: string[];\n        useFunctionTemplate?: boolean;\n        functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n        solution?: string | null;\n    }) {\n        try {\n            const problem = await prisma.problem.create({\n                data: {\n                    title: data.title,\n                    description: data.description,\n                    difficulty: data.difficulty,\n                    slug: data.slug,\n                    score: 10,\n                    hidden: data.hidden,\n                    hiddenQuery: data.hiddenQuery || null,\n                    domain: data.domain || \"DSA\",\n                    useFunctionTemplate: data.useFunctionTemplate || false,\n                    solution: data.solution || null,\n                    testCases: {\n                        create: data.testCases.map(tc => ({\n                            input: tc.input,\n                            output: tc.output,\n                            hidden: tc.hidden ?? false\n                        }))\n                    },\n                    tags: data.tags ? {\n                        connect: data.tags.map(slug => ({ slug }))\n                    } : undefined,\n                    // Create function templates if provided and enabled\n                    functionTemplates: data.useFunctionTemplate && data.functionTemplates?.length ? {\n                        create: data.functionTemplates.map(ft => ({\n                            languageId: ft.languageId,\n                            functionTemplate: ft.functionTemplate,\n                            driverCode: ft.driverCode,\n                        }))\n                    } : undefined\n                },\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n\n            return { success: true, problem };\n        } catch (error) {\n            console.error(\"Failed to create problem:\", error);\n            return { success: false, error: \"Failed to create problem\" };\n        }\n    }\n\n    // UPDATING A PROBLEM\n    static async updateProblem(id: string, data: any) {\n        try {\n            const { testCases, tags, functionTemplates, ...problemData } = data;\n\n            const updateData: any = { ...problemData };\n            if (testCases) {\n                updateData.testCases = {\n                    deleteMany: {},\n                    create: testCases.map((tc: any) => ({\n                        input: tc.input,\n                        output: tc.output,\n                        hidden: tc.hidden ?? false\n                    }))\n                };\n            }\n\n            if (tags) {\n                updateData.tags = {\n                    set: [], // Disconnect all existing\n                    connect: tags.map((slug: string) => ({ slug }))\n                };\n            }\n\n            // Handle function templates\n            if (functionTemplates !== undefined) {\n                updateData.functionTemplates = {\n                    deleteMany: {}, // Delete all existing templates\n                    create: functionTemplates.map((ft: any) => ({\n                        languageId: ft.languageId,\n                        functionTemplate: ft.functionTemplate,\n                        driverCode: ft.driverCode,\n                    }))\n                };\n            }\n\n            // UPDATING THE PROBLEM\n            const problem = await prisma.problem.update({\n                where: { id },\n                data: updateData\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            await redis.del(getProblemCacheKey(problem.slug));\n            // Also invalidate function template cache\n            await redis.del(`problem-templates:${id}`);\n\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to update problem:\", error);\n            return { success: false, error: \"Failed to update problem\" };\n        }\n    }\n\n    // DELETING A PROBLEM\n    static async deleteProblem(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({ where: { id }, select: { slug: true } });\n\n            await prisma.problem.delete({\n                where: { id }\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            if (problem) {\n                await redis.del(getProblemCacheKey(problem.slug));\n            }\n\n            // RETURNING THE SUCCESS\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to delete problem:\", error);\n            return { success: false, error: \"Failed to delete problem\" };\n        }\n    }\n\n    private static async invalidateProblemCaches() {\n        const cachePattern = \"problems:list:*\";\n        const keys = await redis.keys(cachePattern);\n        if (keys.length > 0) {\n            await redis.del(...keys);\n        }\n        const adminCachePattern = \"admin:problems:*\";\n        const adminKeys = await redis.keys(adminCachePattern);\n        if (adminKeys.length > 0) {\n            await redis.del(...adminKeys);\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AAEA;;;AAEA,MAAM,YAAY,KAAK,YAAY;AACnC,MAAM,oBAAoB,MAAM,SAAS;AAEzC,oBAAoB;AACpB,MAAM,sBAAsB,CAAC,MAAmB,QAAuB,MAAc,MAAmB,OAAiB,EAAE,GACvH,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE,KAAK,MAAM,EAAE,KAAK,MAAM,EAAE,QAAQ,MAAM,MAAM,EAAE,KAAK,IAAI,GAAG,IAAI,CAAC,MAAM;AACtG,MAAM,2BAA2B,CAAC,QAA4B,OAC1D,CAAC,eAAe,EAAE,UAAU,MAAM,MAAM,EAAE,MAAM;AACpD,MAAM,qBAAqB,CAAC,OAAiB,CAAC,QAAQ,EAAE,MAAM;AAEvD,MAAM;IAET,yCAAyC;IACzC,aAAqB,kBAAkB,IAAY,EAAE,QAAgB,EAAE,IAAiB,EAAE,SAAwB,KAAK,EAAE,IAAiB,EAAE,OAAiB,EAAE,EAAE,MAAe,EAAE;QAC9K,iIAAiI;QACjI,MAAM,WAAW,SACX,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE,KAAK,QAAQ,EAAE,OAAO,UAAU,EAAE,SAAS,MAAM,EAAE,QAAQ,MAAM,MAAM,EAAE,KAAK,IAAI,GAAG,IAAI,CAAC,MAAM,GAC3H,oBAAoB,MAAM,QAAQ,MAAM,MAAM;QAEpD,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,KAAK,KAAK,CAAC;YACtB;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,QAAa;YACf,OAAO;gBACH;gBACA;gBACA,YAAY;gBACZ,QAAQ;gBACR,MAAM,KAAK,MAAM,GAAG,IAAI;oBACpB,MAAM;wBACF,MAAM;4BAAE,IAAI;wBAAK;oBACrB;gBACJ,IAAI;YACR;YACA,MAAM;YACN,SAAS;gBAAE,WAAW;YAAO;YAC7B,QAAQ;gBACJ,IAAI;gBACJ,OAAO;gBACP,MAAM;gBACN,YAAY;gBACZ,OAAO;gBACP,QAAQ;gBACR,WAAW;gBACX,MAAM;gBACN,QAAQ;oBACJ,QAAQ;wBAAE,aAAa;oBAAK;gBAChC;gBACA,MAAM;oBACF,QAAQ;wBACJ,MAAM;wBACN,MAAM;oBACV;gBACJ;YACJ;QACJ;QAEA,IAAI,QAAQ;YACR,MAAM,MAAM,GAAG;gBAAE,IAAI;YAAO;YAC5B,MAAM,IAAI,GAAG,GAAG,gCAAgC;QACpD,OAAO;YACH,MAAM,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI;QAC9B;QAEA,MAAM,CAAC,UAAU,MAAM,GAAG,MAAM,QAAQ,GAAG,CAAC;YACxC,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YACxB,uHAAM,CAAC,OAAO,CAAC,KAAK,CAAC;gBACjB,OAAO;oBACH;oBACA;oBACA,YAAY;oBACZ,QAAQ;oBACR,MAAM,KAAK,MAAM,GAAG,IAAI;wBACpB,MAAM;4BACF,MAAM;gCAAE,IAAI;4BAAK;wBACrB;oBACJ,IAAI;gBACR;YACJ;SACH;QAED,MAAM,SAAS;YAAE;YAAU;QAAM;QACjC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,KAAK,SAAS,CAAC;QAC1D,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QACA,OAAO;IACX;IAEA,0BAA0B;IAC1B,aAAa,YACT,OAAe,CAAC,EAChB,WAAmB,EAAE,EACrB,OAAoB,UAAU,EAC9B,SAAwB,KAAK,EAC7B,MAAe,EACf,IAAiB,EACjB,OAAiB,EAAE,EACnB,MAAe,EACjB;QACE,gCAAgC;QAChC,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,UAAU,MAAM,QAAQ,MAAM,MAAM;QAEnG,iFAAiF;QACjF,IAAI,YAAY,IAAI;QACpB,IAAI,UAAU,SAAS,MAAM,GAAG,GAAG;YAC/B,MAAM,aAAa,SAAS,GAAG,CAAC,CAAC,IAAW,EAAE,EAAE;YAChD,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,WAAW;wBAAE,IAAI;oBAAW;oBAC5B,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBAAE,WAAW;gBAAK;gBAC1B,UAAU;oBAAC;iBAAY;YAC3B;YACA,YAAY,IAAI,IAAI,kBAAkB,GAAG,CAAC,CAAA,IAAK,EAAE,SAAS;QAC9D;QAEA,eAAe;QACf,MAAM,oBAAoB,SAAS,GAAG,CAAC,CAAC;YACpC,OAAO;gBACH,GAAG,CAAC;gBACJ,UAAU,UAAU,GAAG,CAAC,EAAE,EAAE;gBAC5B,YAAY,EAAE,MAAM,CAAC,WAAW,GAAG,IAC7B,AAAC,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,WAAW,GAAI,MAC3C;YACV;QACJ;QAEA,OAAO;YACH,UAAU;YACV,YAAY,KAAK,IAAI,CAAC,QAAQ;YAC9B,aAAa;YACb;QACJ;IACJ;IAEA,yBAAyB;IACzB,aAAa,iBACT,OAAe,CAAC,EAChB,WAAmB,EAAE,EACrB,MAAsB,EACtB,iBAA8B,EAC9B,IAAkB,EACpB;QACE,MAAM,WAAW,yBAAyB,QAAQ;QAClD,iGAAiG;QACjG,sDAAsD;QACtD,iFAAiF;QAEjF,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;YACR,0GAA0G;YAC1G,uFAAuF;YACvF,yGAAyG;YACzG,2FAA2F;YAC3F,6EAA6E;YAE7E,yGAAyG;YAC7G;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;QAC1B,MAAM,QAAa,SAAS;YAAE;QAAO,IAAI,CAAC;QAE1C,IAAI,MAAM;YACN,MAAM,IAAI,GAAG;QACjB,OAAO;YACH,MAAM,IAAI,GAAG;gBAAE,KAAK;YAAU;QAClC;QAEA,IAAI,mBAAmB;YACnB,MAAM,UAAU,GAAG;gBAAE,KAAK;YAAkB;QAChD;QAEA,MAAM,CAAC,UAAU,MAAM,GAAG,MAAM,QAAQ,GAAG,CAAC;YACxC,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;gBACpB;gBACA;gBACA,MAAM;gBACN,SAAS;oBAAE,WAAW;gBAAO;gBAC7B,QAAQ;oBACJ,IAAI;oBACJ,OAAO;oBACP,MAAM;oBACN,YAAY;oBACZ,QAAQ;oBACR,OAAO;oBACP,MAAM;oBACN,QAAQ;oBACR,WAAW;oBACX,WAAW;gBACf;YACJ;YACA,uHAAM,CAAC,OAAO,CAAC,KAAK,CAAC;gBAAE;YAAM;SAChC;QAED,MAAM,SAAS;YACX;YACA,YAAY,KAAK,IAAI,CAAC,QAAQ;YAC9B,aAAa;YACb;QACJ;QAEA,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,KAAK,SAAS,CAAC;QAC1D,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QACA,OAAO;IACX;IAEA,yBAAyB;IACzB,aAAa,eACT,IAAY,EACZ,OAAoB,UAAU,EAC9B,SAAwB,KAAK,EAC7B,MAAe,EACjB;QACE,MAAM,WAAW,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBACH;gBACA;gBACA,QAAQ;gBACR,OAAO;oBACH,UAAU;oBACV,MAAM;gBACV;YACJ;YACA,MAAM;YACN,SAAS;gBAAE,WAAW;YAAO;YAC7B,QAAQ;gBACJ,IAAI;gBACJ,OAAO;gBACP,MAAM;gBACN,YAAY;gBACZ,OAAO;gBACP,QAAQ;gBACR,WAAW;gBACX,MAAM;gBACN,QAAQ;oBACJ,QAAQ;wBAAE,aAAa;oBAAK;gBAChC;gBACA,MAAM;oBACF,QAAQ;wBACJ,MAAM;wBACN,MAAM;oBACV;gBACJ;YACJ;QACJ;QAEA,IAAI,YAAY,IAAI;QACpB,IAAI,UAAU,SAAS,MAAM,GAAG,GAAG;YAC/B,MAAM,aAAa,SAAS,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;YACzC,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,WAAW;wBAAE,IAAI;oBAAW;oBAC5B,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBAAE,WAAW;gBAAK;gBAC1B,UAAU;oBAAC;iBAAY;YAC3B;YACA,YAAY,IAAI,IAAI,kBAAkB,GAAG,CAAC,CAAA,IAAK,EAAE,SAAS;QAC9D;QAEA,MAAM,oBAAoB,SAAS,GAAG,CAAC,CAAC;YACpC,OAAO;gBACH,GAAG,CAAC;gBACJ,UAAU,UAAU,GAAG,CAAC,EAAE,EAAE;gBAC5B,YAAY,EAAE,MAAM,CAAC,WAAW,GAAG,IAC7B,AAAC,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,WAAW,GAAI,MAC3C;YACV;QACJ;QAEA,OAAO;YAAE,UAAU;QAAkB;IACzC;IAEA,oCAAoC;IACpC,aAAqB,iBAAiB,IAAY,EAAE;QAChD,MAAM,WAAW,mBAAmB;QAEpC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,KAAK,KAAK,CAAC;YACtB;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE;YAAK;YACd,SAAS;gBACL,WAAW;gBACX,MAAM;oBAAE,QAAQ;wBAAE,MAAM;wBAAM,OAAO;oBAAK;gBAAE;gBAC5C,MAAM;oBAAE,QAAQ;wBAAE,MAAM;wBAAM,MAAM;oBAAK;gBAAE;gBAC3C,mBAAmB,KAAK,iDAAiD;YAC7E;QACJ;QAEA,IAAI,SAAS;YACT,IAAI;gBACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,mBAAmB,KAAK,SAAS,CAAC;YAClE,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,oBAAoB;YACtC;QACJ;QACA,OAAO;IACX;IAEA,mCAAmC;IACnC,aAAa,WAAW,IAAY,EAAE;QAClC,MAAM,UAAU,MAAM,IAAI,CAAC,gBAAgB,CAAC;QAC5C,OAAO;IACX;IAEA,0BAA0B;IAC1B,aAAa,eAAe,EAAU,EAAE;QACpC,IAAI;YACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAC5C,OAAO;oBAAE;gBAAG;gBACZ,SAAS;oBACL,WAAW;oBACX,MAAM;wBAAE,QAAQ;4BAAE,MAAM;4BAAM,MAAM;wBAAK;oBAAE;oBAC3C,mBAAmB;gBACvB;YACJ;YACA,OAAO;gBAAE,SAAS;gBAAM,MAAM;YAAQ;QAC1C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA8B;QAClE;IACJ;IAEA,uBAAuB;IACvB,aAAa,eAAe,gBAAsB,EAAE,MAAqB,EAAE,IAAiB,EAAE;QAC1F,IAAI;YACA,MAAM,cAAc,MAAM,uHAAM,CAAC,OAAO,CAAC,SAAS,CAAC;gBAC/C,OAAO;oBACH;oBACA;oBACA,QAAQ;oBACR,WAAW;wBACP,IAAI;oBACR;gBACJ;gBACA,SAAS;oBACL,WAAW;gBACf;gBACA,QAAQ;oBACJ,MAAM;gBACV;YACJ;YACA,OAAO,aAAa,QAAQ;QAChC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;QACX;IACJ;IAEA,2BAA2B;IAC3B,aAAa,mBAAmB,gBAAsB,EAAE,MAAqB,EAAE,IAAiB,EAAE;QAC9F,IAAI;YACA,MAAM,cAAc,MAAM,uHAAM,CAAC,OAAO,CAAC,SAAS,CAAC;gBAC/C,OAAO;oBACH;oBACA;oBACA,QAAQ;oBACR,WAAW;wBACP,IAAI;oBACR;gBACJ;gBACA,SAAS;oBACL,WAAW;gBACf;gBACA,QAAQ;oBACJ,MAAM;gBACV;YACJ;YACA,OAAO,aAAa,QAAQ;QAChC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,mCAAmC;YACjD,OAAO;QACX;IACJ;IAEA,yBAAyB;IACzB,aAAa,iBAAiB,MAAqB,EAAE,IAAiB,EAAE;QACpE,IAAI;YACD,iEAAiE;YACjE,MAAM,QAAQ,MAAM,uHAAM,CAAC,OAAO,CAAC,KAAK,CAAC;gBACrC,OAAO;oBACH;oBACA;oBACA,QAAQ;gBACZ;YACJ;YAEA,IAAI,UAAU,GAAG,OAAO;YAExB,MAAM,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;YACxC,MAAM,gBAAgB,MAAM,uHAAM,CAAC,OAAO,CAAC,SAAS,CAAC;gBACjD,OAAO;oBACH;oBACA;oBACA,QAAQ;gBACZ;gBACA;gBACA,QAAQ;oBACJ,MAAM;gBACV;YACJ;YAEA,OAAO,eAAe,QAAQ;QACjC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO;QACX;IACJ;IAEA,qBAAqB;IACrB,aAAa,cAAc,IAa1B,EAAE;QACC,IAAI;YACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxC,MAAM;oBACF,OAAO,KAAK,KAAK;oBACjB,aAAa,KAAK,WAAW;oBAC7B,YAAY,KAAK,UAAU;oBAC3B,MAAM,KAAK,IAAI;oBACf,OAAO;oBACP,QAAQ,KAAK,MAAM;oBACnB,aAAa,KAAK,WAAW,IAAI;oBACjC,QAAQ,KAAK,MAAM,IAAI;oBACvB,qBAAqB,KAAK,mBAAmB,IAAI;oBACjD,UAAU,KAAK,QAAQ,IAAI;oBAC3B,WAAW;wBACP,QAAQ,KAAK,SAAS,CAAC,GAAG,CAAC,CAAA,KAAM,CAAC;gCAC9B,OAAO,GAAG,KAAK;gCACf,QAAQ,GAAG,MAAM;gCACjB,QAAQ,GAAG,MAAM,IAAI;4BACzB,CAAC;oBACL;oBACA,MAAM,KAAK,IAAI,GAAG;wBACd,SAAS,KAAK,IAAI,CAAC,GAAG,CAAC,CAAA,OAAQ,CAAC;gCAAE;4BAAK,CAAC;oBAC5C,IAAI;oBACJ,oDAAoD;oBACpD,mBAAmB,KAAK,mBAAmB,IAAI,KAAK,iBAAiB,EAAE,SAAS;wBAC5E,QAAQ,KAAK,iBAAiB,CAAC,GAAG,CAAC,CAAA,KAAM,CAAC;gCACtC,YAAY,GAAG,UAAU;gCACzB,kBAAkB,GAAG,gBAAgB;gCACrC,YAAY,GAAG,UAAU;4BAC7B,CAAC;oBACL,IAAI;gBACR;YACJ;YAEA,yBAAyB;YACzB,MAAM,IAAI,CAAC,uBAAuB;YAElC,OAAO;gBAAE,SAAS;gBAAM;YAAQ;QACpC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;IACJ;IAEA,qBAAqB;IACrB,aAAa,cAAc,EAAU,EAAE,IAAS,EAAE;QAC9C,IAAI;YACA,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,iBAAiB,EAAE,GAAG,aAAa,GAAG;YAE/D,MAAM,aAAkB;gBAAE,GAAG,WAAW;YAAC;YACzC,IAAI,WAAW;gBACX,WAAW,SAAS,GAAG;oBACnB,YAAY,CAAC;oBACb,QAAQ,UAAU,GAAG,CAAC,CAAC,KAAY,CAAC;4BAChC,OAAO,GAAG,KAAK;4BACf,QAAQ,GAAG,MAAM;4BACjB,QAAQ,GAAG,MAAM,IAAI;wBACzB,CAAC;gBACL;YACJ;YAEA,IAAI,MAAM;gBACN,WAAW,IAAI,GAAG;oBACd,KAAK,EAAE;oBACP,SAAS,KAAK,GAAG,CAAC,CAAC,OAAiB,CAAC;4BAAE;wBAAK,CAAC;gBACjD;YACJ;YAEA,4BAA4B;YAC5B,IAAI,sBAAsB,WAAW;gBACjC,WAAW,iBAAiB,GAAG;oBAC3B,YAAY,CAAC;oBACb,QAAQ,kBAAkB,GAAG,CAAC,CAAC,KAAY,CAAC;4BACxC,YAAY,GAAG,UAAU;4BACzB,kBAAkB,GAAG,gBAAgB;4BACrC,YAAY,GAAG,UAAU;wBAC7B,CAAC;gBACL;YACJ;YAEA,uBAAuB;YACvB,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxC,OAAO;oBAAE;gBAAG;gBACZ,MAAM;YACV;YAEA,yBAAyB;YACzB,MAAM,IAAI,CAAC,uBAAuB;YAClC,MAAM,uHAAK,CAAC,GAAG,CAAC,mBAAmB,QAAQ,IAAI;YAC/C,0CAA0C;YAC1C,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,kBAAkB,EAAE,IAAI;YAEzC,OAAO;gBAAE,SAAS;gBAAM,MAAM;YAAQ;QAC1C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;IACJ;IAEA,qBAAqB;IACrB,aAAa,cAAc,EAAU,EAAE;QACnC,IAAI;YACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAAE,OAAO;oBAAE;gBAAG;gBAAG,QAAQ;oBAAE,MAAM;gBAAK;YAAE;YAExF,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxB,OAAO;oBAAE;gBAAG;YAChB;YAEA,yBAAyB;YACzB,MAAM,IAAI,CAAC,uBAAuB;YAClC,IAAI,SAAS;gBACT,MAAM,uHAAK,CAAC,GAAG,CAAC,mBAAmB,QAAQ,IAAI;YACnD;YAEA,wBAAwB;YACxB,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;IACJ;IAEA,aAAqB,0BAA0B;QAC3C,MAAM,eAAe;QACrB,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;QAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;YACjB,MAAM,uHAAK,CAAC,GAAG,IAAI;QACvB;QACA,MAAM,oBAAoB;QAC1B,MAAM,YAAY,MAAM,uHAAK,CAAC,IAAI,CAAC;QACnC,IAAI,UAAU,MAAM,GAAG,GAAG;YACtB,MAAM,uHAAK,CAAC,GAAG,IAAI;QACvB;IACJ;AACJ"}},
    {"offset": {"line": 931, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/problems.ts"],"sourcesContent":["\"use server\";\n\nimport { ProblemService } from \"@/core/services/problem.service\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING PUBLIC PROBLEMS\n\nexport async function getProblems(\n    page: number = 1,\n    pageSize: number = 10,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\",\n    difficulty?: Difficulty,\n    tags?: string[],\n    cursor?: string\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `problems-${domain}-${type}${difficulty ? `-${difficulty}` : ''}${tags && tags.length > 0 ? `-${tags.join('-')}` : ''}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-list', `problems-${domain}-${type}`);\n\n    return ProblemService.getProblems(page, pageSize, type, domain, userId, difficulty, tags || [], cursor);\n}\n\n// GETTING ADMIN PROBLEMS\n\nexport async function getAdminProblems(\n    page: number = 1,\n    pageSize: number = 50,\n    domain?: ProblemDomain,\n    excludeDifficulty?: Difficulty,\n    type?: ProblemType\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const tagKey = `admin-problems-${domain || 'all'}${excludeDifficulty ? `-exclude-${excludeDifficulty}` : ''}${type ? `-type-${type}` : ''}-page-${page}`;\n    cacheTag(tagKey, 'admin-problems-list');\n\n    return ProblemService.getAdminProblems(page, pageSize, domain, excludeDifficulty, type);\n}\n\n// SEARCHING FOR PROBLEMS\n\nexport async function searchProblems(\n    term: string,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\"\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes for search results\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `search-${domain}-${type}-${term.toLowerCase().slice(0, 20)}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-search');\n\n    return ProblemService.searchProblems(term, type, domain, userId);\n}\n\n// GETTING A PROBLEM BY SLUG CACHED\n\nexport async function getProblem(slug: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-${slug}`, 'problems-list');\n\n    return ProblemService.getProblem(slug);\n}\n\n\n// CREATING A PROBLEM --> ADMIN ONLY\n\nexport async function createProblem(data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    domain?: ProblemDomain;\n    testCases: { input: string; output: string; hidden?: boolean }[];\n    tags?: string[];\n    useFunctionTemplate?: boolean;\n    functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n    solution?: string | null;\n}) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.createProblem(data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(\"/admin/problems\");\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag('problems-SQL-PRACTICE');\n        updateTag('problems-DSA-PRACTICE');\n    }\n\n    return result;\n}\n\n\n// GETTING A PROBLEM BY ID\nexport async function getProblemById(id: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-id-${id}`, 'problems-list');\n\n    return ProblemService.getProblemById(id);\n}\n\n// NAVIGATION ACTIONS\n\nexport async function getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getNextProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getPreviousProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n    // No cache for random\n    return ProblemService.getRandomProblem(domain, type);\n}\n\n\n// UPDATING A PROBLEM --> ADMIN ONLY\nexport async function updateProblem(id: string, data: any) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.updateProblem(id, data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag(`problems-${result.data?.domain || 'DSA'}-${result.data?.type || 'PRACTICE'}`);\n        updateTag(`problem-${result.data?.slug}`);\n    }\n\n    return result;\n}\n\n\n// DELETING A PROBLEM --> ADMIN ONLY\nexport async function deleteProblem(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.deleteProblem(id);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n    }\n\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAKA,MAAM,gBAAgB,kLAAC,CAAC,MAAM,CAAC;IAC3B,OAAO,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACzB,aAAa,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,WAAW,kLAAC,CAAC,MAAM,CAAC,IAAI;IACxB,SAAS,kLAAC,CAAC,MAAM,CAAC,IAAI;IACtB,YAAY,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAU;QAAe;KAAY;IACzD,aAAa,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,eAAe,kLAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAC7C,UAAU,kLAAC,CAAC,KAAK,CAAC,kLAAC,CAAC,MAAM,IAAI,GAAG,CAAC,GAAG;IACrC,iBAAiB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACpC,oBAAoB,kLAAC,CAAC,OAAO,GAAG,OAAO,CAAC;AAC5C;AAEA,MAAM,4BAA4B,kLAAC,CAAC,MAAM,CAAC;IACvC,OAAO,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACzB,MAAM,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACxB,aAAa,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,WAAW,kLAAC,CAAC,IAAI;IACjB,SAAS,kLAAC,CAAC,IAAI;IACf,YAAY,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAU;QAAe;KAAY;IACzD,QAAQ,kLAAC,CAAC,OAAO,GAAG,OAAO,CAAC;IAC5B,aAAa,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,eAAe,kLAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAC7C,iBAAiB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACpC,QAAQ,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC3B,OAAO,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,UAAU,kLAAC,CAAC,KAAK,CAAC,kLAAC,CAAC,GAAG;IACvB,iBAAiB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACpC,oBAAoB,kLAAC,CAAC,OAAO,GAAG,OAAO,CAAC;AAC5C;AAEA;;CAEC,GACD;;CAEC,GACD,MAAA,6BAAA,eAAe;IAEX,IAAA,yIAAQ,EAAC;IACT,aAAa;IACb,IAAA,0IAAS,EAAC;IAEV,OAAO,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QAC3B,OAAO;YACH,YAAY;YACZ,QAAQ;QACZ;QACA,SAAS;YACL,QAAQ;gBAAE,QAAQ;oBAAE,UAAU;gBAAK;YAAE;QACzC;QACA,SAAS;YAAE,WAAW;QAAO;IACjC;AACJ;IAhBA,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAqBR,eAAe;IAClB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI;QACA,IAAI,CAAC,SAAS,MAAM;YAChB,MAAM,WAAW,MAAM;YACvB,OAAO;gBAAE,SAAS;gBAAM;YAAS;QACrC;QAEA,MAAM,cAAc,QAAQ,IAAI;QAEhC,IAAI,YAAY,IAAI,KAAK,SAAS;YAC9B,MAAM,WAAW,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;gBAC3C,SAAS;oBACL,QAAQ;wBAAE,QAAQ;4BAAE,UAAU;wBAAK;oBAAE;gBACzC;gBACA,SAAS;oBAAE,WAAW;gBAAO;YACjC;YACA,OAAO;gBAAE,SAAS;gBAAM;YAAS;QACrC;QAEA,MAAM,WAAW,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBACH,IAAI;oBACA;wBAAE,YAAY;oBAAS;oBACvB;wBACI,KAAK;4BACD;gCAAE,YAAY;4BAAc;4BAC5B;gCAAE,eAAe,YAAY,aAAa;4BAAC;yBAC9C;oBACL;oBACA;wBACI,KAAK;4BACD;gCAAE,YAAY;4BAAY;4BAC1B;gCACI,IAAI;oCACA;wCAAE,WAAW;4CAAE,UAAU;gDAAE,MAAM;oDAAE,IAAI,YAAY,EAAE;gDAAC;4CAAE;wCAAE;oCAAE;oCAC5D;wCAAE,WAAW,YAAY,EAAE;oCAAC;iCAC/B;4BACL;yBACH;oBACL;oBACA;wBAAE,WAAW,YAAY,EAAE;oBAAC;iBAC/B;YACL;YACA,SAAS;gBACL,QAAQ;oBAAE,QAAQ;wBAAE,UAAU;oBAAK;gBAAE;YACzC;YACA,SAAS;gBAAE,WAAW;YAAO;QACjC;QAEA,OAAO;YAAE,SAAS;YAAM;QAAS;IACrC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAGA;;CAEC,GACD;;CAEC,GACD;;;CAGC,GACD,MAAA,6BAAA,eAAe,iBAAiB,SAAiB;IAE7C,IAAA,yIAAQ,EAAC,CAAC,QAAQ,EAAE,WAAW;IAC/B,aAAa;IACb,IAAA,0IAAS,EAAC;IAEV,OAAO,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC7B,OAAO;YAAE,IAAI;QAAU;QACvB,SAAS;YACL,QAAQ;gBACJ,QAAQ;oBAAE,UAAU;gBAAK;YAC7B;YACA,UAAU;gBACN,SAAS;oBACL,SAAS;wBACL,QAAQ;4BACJ,IAAI;4BACJ,OAAO;4BACP,YAAY;4BACZ,MAAM;wBACV;oBACJ;gBACJ;gBACA,SAAS;oBAAE,OAAO;gBAAM;YAC5B;QACJ;IACJ;AACJ;IA3BA,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAgCR,eAAe,iBAAiB,SAAiB;IACpD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI;QACA,MAAM,UAAU,MAAM,iBAAiB;QAEvC,IAAI,CAAC,SAAS;YACV,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAoB;QACxD;QAEA,MAAM,cAAc,SAAS;QAC7B,MAAM,gBAAgB,cAAc,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC7E,OAAO;gBACH,kBAAkB;oBACd,QAAQ,YAAY,EAAE;oBACtB,WAAW;gBACf;YACJ;QACJ,KAAK;QAEL,MAAM,MAAM,IAAI;QAChB,MAAM,aAAa,OAAO,QAAQ,SAAS;QAC3C,MAAM,YAAY,aAAa,OAAO,QAAQ,SAAS;QACvD,MAAM,UAAU,aAAa,SAAS;QAEtC,mBAAmB;QACnB,IAAI,eAAe;QACnB,IAAI,QAAQ,UAAU,KAAK,UAAU;YACjC,eAAe;QACnB,OAAO,IAAI,SAAS;YAChB,eAAe;QACnB,OAAO,IAAI,aAAa;YACpB,IAAI,WAAW;gBACX,eAAe;YACnB,OAAO,IAAI,QAAQ,UAAU,KAAK,eAAe;gBAC7C,iDAAiD;gBACjD,eAAe,YAAY,aAAa,IAAI,QAAQ,aAAa;YACrE,OAAO,IAAI,QAAQ,UAAU,KAAK,aAAa;gBAC3C,MAAM,aAAa,MAAM,uHAAM,CAAC,SAAS,CAAC,SAAS,CAAC;oBAChD,OAAO;wBACH,IAAI,QAAQ,WAAW;wBACvB,UAAU;4BAAE,MAAM;gCAAE,IAAI,YAAY,EAAE;4BAAC;wBAAE;oBAC7C;gBACJ;gBACA,eAAe,CAAC,CAAC;YACrB;QACJ;QAEA,IAAI,CAAC,cAAc;YACf,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuC;QAC3E;QAEA,MAAM,iBAAiB,CAAC,cAAc,WAAW,SAAS,KAAK,CAAC,eAAe,iBAAiB,aAAa,OAAO;QAEpH,kFAAkF;QAClF,qDAAqD;QACrD,yDAAyD;QAEzD,MAAM,mBAAmB,CAAC,CAAC,QAAQ,eAAe;QAElD,oDAAoD;QACpD,0EAA0E;QAC1E,IAAI,kBAAkB,iBAAiB,QAAQ,QAAQ,GAAG,EAAE;QAE5D,IAAI,QAAQ,kBAAkB,IAAI,eAAe,gBAAgB,MAAM,GAAG,KAAK,CAAC,WAAW,CAAC,WAAW;YACnG,0CAA0C;YAC1C,MAAM,UAAU,GAAG,YAAY,EAAE,CAAC,CAAC,EAAE,WAAW;YAChD,IAAI,OAAO;YACX,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;gBACrC,OAAO,AAAC,CAAC,QAAQ,CAAC,IAAI,OAAQ,QAAQ,UAAU,CAAC;gBACjD,QAAQ;YACZ;YAEA,wBAAwB;YACxB,kBAAkB;mBAAI;aAAgB,CAAC,IAAI,CAAC,CAAC,GAAG;gBAC5C,MAAM,IAAI,KAAK,GAAG,CAAC,UAAU;gBAC7B,OAAO,AAAC,IAAI,KAAK,KAAK,CAAC,KAAM;YACjC;QACJ;QAEA,gDAAgD;QAChD,MAAM,mBAAmB,IAAI;QAC7B,IAAI,aAAa;YACb,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH,QAAQ,YAAY,EAAE;oBACtB,WAAW;oBACX,QAAQ;oBACR,WAAW;wBACP,IAAI,gBAAgB,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,CAAC,EAAE;oBAC7C;gBACJ;gBACA,QAAQ;oBAAE,WAAW;gBAAK;YAC9B;YACA,kBAAkB,OAAO,CAAC,CAAA,IAAK,iBAAiB,GAAG,CAAC,EAAE,SAAS;QACnE;QAEA,OAAO;YACH,SAAS;YACT,SAAS;gBACL,GAAG,OAAO;gBACV,UAAU,gBAAgB,GAAG,CAAC,CAAA,KAAM,CAAC;wBACjC,GAAG,EAAE;wBACL,UAAU,iBAAiB,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE;oBAChD,CAAC;gBACD;gBACA,UAAU,MAAM,QAAQ,OAAO;gBAC/B,WAAW,WAAW;gBACtB,kBAAkB,eAAe,iBAAiB;gBAClD,YAAY,eAAe,cAAc;gBACzC;gBACA,iBAAiB;gBACjB,WAAW,eAAe,UAAU,kCAAkC;YAC1E;QACJ;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0B;IAC9D;AACJ;AAQO,eAAe,cAAc,IAAmC;IACnE,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,cAAc,QAAQ,IAAI;IAEhC,IAAI,CAAC;QAAC;QAAS;QAAuB;QAAmB;KAAU,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;QAC5F,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,gBAAgB,cAAc,KAAK,CAAC;QAE1C,qCAAqC;QACrC,MAAM,WAAW,cAAc,KAAK,CAAC,WAAW,GAAG,OAAO,CAAC,eAAe,KAAK,OAAO,CAAC,YAAY;QACnG,MAAM,aAAa,GAAG,SAAS,CAAC,EAAE,KAAK,GAAG,IAAI;QAE9C,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YACxC,MAAM;gBACF,OAAO,cAAc,KAAK;gBAC1B,MAAM;gBACN,aAAa,cAAc,WAAW;gBACtC,WAAW,cAAc,SAAS;gBAClC,SAAS,cAAc,OAAO;gBAC9B,YAAY,cAAc,UAAU;gBACpC,eAAe,cAAc,UAAU,KAAK,WAAY,cAAc,aAAa,IAAI,OAAQ;gBAC/F,aAAa,cAAc,UAAU,KAAK,cAAe,cAAc,WAAW,IAAI,OAAQ;gBAC9F,WAAW,YAAY,EAAE;gBACzB,iBAAiB,cAAc,eAAe,IAAI;gBAClD,oBAAoB,cAAc,kBAAkB,IAAI;gBACxD,UAAU;oBACN,QAAQ,cAAc,QAAQ,CAAC,GAAG,CAAC,CAAC,WAAW,QAAU,CAAC;4BACtD;4BACA,OAAO;wBACX,CAAC;gBACL;YACJ;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC;QACf,IAAA,8IAAa,EAAC,YAAY;QAC1B,OAAO;YAAE,SAAS;YAAM,WAAW,QAAQ,EAAE;QAAC;IAClD,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,gCAAgC;QAChC,IAAI,eAAe;QACnB,IAAI,iBAAiB,kLAAC,CAAC,QAAQ,EAAE;YAC5B,eAAe,AAAC,MAAc,MAAM,CAAC,GAAG,CAAC,CAAC,IAAW,EAAE,OAAO,EAAE,IAAI,CAAC;QAC1E,OAAO,IAAI,iBAAiB,OAAO;YAC9B,eAAe,MAAM,OAAO;QACjC;QACA,OAAO;YAAE,SAAS;YAAO,OAAO;QAAa;IACjD;AACA;AAGG,eAAe,0BAA0B,IAA+C;IAC3F,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,cAAc,QAAQ,IAAI;IAEhC,IAAI,CAAC;QAAC;QAAS;QAAuB;QAAmB;KAAU,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;QAC5F,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,gBAAgB,0BAA0B,KAAK,CAAC;QAEtD,MAAM,UAAU,MAAM,uHAAM,CAAC,YAAY,CAAC,OAAO;YAC7C,MAAM,UAAU,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;gBACpC,MAAM;oBACF,OAAO,cAAc,KAAK;oBAC1B,MAAM,cAAc,IAAI;oBACxB,aAAa,cAAc,WAAW;oBACtC,WAAW,cAAc,SAAS;oBAClC,SAAS,cAAc,OAAO;oBAC9B,YAAY,cAAc,UAAU;oBACpC,QAAQ,cAAc,MAAM;oBAC5B,iBAAiB,cAAc,eAAe;oBAC9C,QAAQ,cAAc,MAAM;oBAC5B,OAAO,cAAc,KAAK;oBAC1B,eAAe,cAAc,UAAU,KAAK,WAAY,cAAc,aAAa,IAAI,OAAQ;oBAC/F,aAAa,cAAc,UAAU,KAAK,cAAe,cAAc,WAAW,IAAI,OAAQ;oBAC9F,WAAW,YAAY,EAAE;oBACzB,iBAAiB,cAAc,eAAe,IAAI;oBAClD,oBAAoB,cAAc,kBAAkB,IAAI;gBAC5D;YACJ;YAEA,IAAK,IAAI,IAAI,GAAG,IAAI,cAAc,QAAQ,CAAC,MAAM,EAAE,IAAK;gBACpD,MAAM,IAAI,cAAc,QAAQ,CAAC,EAAE;gBACnC,2DAA2D;gBAC3D,MAAM,aAAa,GAAG,cAAc,IAAI,CAAC,CAAC,EAAE,EAAE,IAAI,IAAI,EAAE,KAAK,CAAC,WAAW,GAAG,OAAO,CAAC,QAAQ,KAAK,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,GAAG;gBACrH,MAAM,UAAU,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;oBACpC,MAAM;wBACF,OAAO,EAAE,KAAK;wBACd,aAAa,EAAE,WAAW;wBAC1B,YAAY,EAAE,UAAU;wBACxB,MAAM;wBACN,OAAO,EAAE,KAAK,IAAI;wBAClB,QAAQ,EAAE,MAAM;wBAChB,MAAM;wBACN,QAAQ;wBACR,WAAW;4BACP,QAAQ,EAAE,SAAS;wBACvB;wBACA,MAAM;4BACF,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,IAAc,CAAC;oCAAE,MAAM;gCAAE,CAAC,MAAM,EAAE;wBAC5D;oBACJ;gBACJ;gBAEA,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC;oBAC3B,MAAM;wBACF,WAAW,QAAQ,EAAE;wBACrB,WAAW,QAAQ,EAAE;wBACrB,OAAO;oBACX;gBACJ;YACJ;YAEA,OAAO;QACX;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC;QACf,IAAA,8IAAa,EAAC,YAAY;QAC1B,OAAO;YAAE,SAAS;YAAM,WAAW,QAAQ,EAAE;QAAC;IAClD,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAEO,eAAe,2BAA2B,aAAqB;IAClE,IAAI;QACA,MAAM,aAAa,MAAM,uHAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;YAC/C,OAAO;gBAAE;YAAc;YACvB,QAAQ;gBAAE,IAAI;gBAAM,MAAM;gBAAM,SAAS;YAAK;QAClD;QACA,OAAO;YAAE,SAAS;YAAM;QAAW;IACvC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA6B;IACjE;AACJ;AAEO,eAAe,sBAAsB,MAAc;IACtD,IAAI;QACA,MAAM,WAAW,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBACH,IAAI;oBACA;wBAAE,OAAO;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACnD;wBAAE,MAAM;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;iBACrD;gBACD,QAAQ;YACZ;YACA,QAAQ;gBAAE,IAAI;gBAAM,OAAO;gBAAM,YAAY;gBAAM,MAAM;YAAK;YAC9D,MAAM;QACV;QACA,OAAO;YAAE,SAAS;YAAM;QAAS;IACrC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAEO,eAAe,mBAAmB,SAAiB;IACtD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,uHAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC;YACrC,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,QAAQ;gBAAE,eAAe;YAAK;YAC9B,QAAQ;gBACJ,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,WAAW;gBACX,eAAe;YACnB;QACJ;QACA,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,WAAW;QACtC,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyB;IAC7D;AACJ;AAEO,eAAe,oBAAoB,SAAiB;IACvD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,uHAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC;YACrC,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,QAAQ;gBACJ,YAAY;gBACZ,YAAY,IAAI;YACpB;YACA,QAAQ;gBACJ,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,WAAW;gBACX,eAAe;gBACf,YAAY;gBACZ,YAAY,IAAI;YACpB;QACJ;QACA,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,WAAW;QACtC,IAAA,+IAAc,EAAC,CAAC,SAAS,CAAC;QAC1B,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAQO,eAAe,gBAAgB,SAAiB;IACnD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,+CAA+C;IAC/C,MAAM,cAAc,QAAQ,IAAI;IAChC,IAAI,CAAC;QAAC;QAAS;QAAmB;QAAuB;KAAU,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;QAC5F,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC3C,OAAO;gBAAE,IAAI;YAAU;YACvB,QAAQ;gBAAE,aAAa;gBAAM,OAAO;YAAK;QAC9C;QAEA,IAAI,CAAC,SAAS,OAAO;YAAE,SAAS;YAAO,OAAO;QAAoB;QAClE,IAAI,QAAQ,WAAW,EAAE,OAAO;YAAE,SAAS;YAAO,OAAO;QAA+B;QAExF,0CAA0C;QAC1C,MAAM,cAAc,MAAM,sBAAsB;QAChD,IAAI,CAAC,YAAY,OAAO,IAAI,CAAC,YAAY,QAAQ,EAAE;YAC/C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA8B;QAClE;QAEA,MAAM,WAAW,YAAY,QAAQ;QAErC,4BAA4B;QAC5B,IAAI,SAAS,MAAM,KAAK,GAAG;YACtB,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBACxB,OAAO;oBAAE,IAAI;gBAAU;gBACvB,MAAM;oBAAE,aAAa;gBAAK;YAC9B;YACA,OAAO;gBAAE,SAAS;gBAAM,SAAS;YAAsC;QAC5E;QAEA,YAAY;QACZ,MAAM,aAAa,QAAQ,CAAC,EAAE,EAAE;QAChC,MAAM,eAAe,QAAQ,CAAC,EAAE,EAAE;QAClC,MAAM,eAAe,QAAQ,CAAC,EAAE,EAAE;QAElC,MAAM,uHAAM,CAAC,YAAY,CAAC,OAAO;YAC7B,aAAa;YACb,IAAI,YAAY;gBACZ,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBACjB,OAAO;wBAAE,IAAI;oBAAW;oBACxB,MAAM;wBAAE,YAAY;4BAAE,WAAW;wBAAE;oBAAE;gBACzC;YACJ;YACA,eAAe;YACf,IAAI,cAAc;gBACd,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBACjB,OAAO;wBAAE,IAAI;oBAAa;oBAC1B,MAAM;wBAAE,cAAc;4BAAE,WAAW;wBAAE;oBAAE;gBAC3C;YACJ;YACA,eAAe;YACf,IAAI,cAAc;gBACd,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBACjB,OAAO;wBAAE,IAAI;oBAAa;oBAC1B,MAAM;wBAAE,cAAc;4BAAE,WAAW;wBAAE;oBAAE;gBAC3C;YACJ;YAEA,iBAAiB;YACjB,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;gBACpB,OAAO;oBAAE,IAAI;gBAAU;gBACvB,MAAM;oBAAE,aAAa;gBAAK;YAC9B;QACJ;QAEA,IAAA,+IAAc,EAAC,CAAC,UAAU,CAAC;QAC3B,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,YAAY;QACvC,IAAG,cAAc,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,cAAc;QAC1D,IAAG,cAAc,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,cAAc;QAC1D,IAAA,+IAAc,EAAC,CAAC,SAAS,EAAE,WAAW;QACtC,IAAA,8IAAa,EAAC,CAAC,QAAQ,EAAE,WAAW,EAAE;QACtC,IAAA,8IAAa,EAAC,CAAC,YAAY,EAAE,WAAW,EAAE;QAE1C,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA6B;IACjE;AACJ;AAKO,eAAe,sBAAsB,SAAiB,EAAE,QAAiB;IAC5E,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE,IAAI;YAAU;YACvB,QAAQ;gBAAE,iBAAiB;YAAK;QACpC;QAEA,IAAI,CAAC,SAAS,OAAO;YAAE,SAAS;YAAO,OAAO;QAAoB;QAElE,IAAI,QAAQ,eAAe,IAAI,QAAQ,eAAe,KAAK,UAAU;YACjE,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;QAEA,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;AACJ;AAMO,eAAe,oBAAoB,SAAiB,EAAE,QAAiB;IAC1E,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE,IAAI;YAAU;YACvB,QAAQ;gBAAE,WAAW;gBAAM,SAAS;gBAAM,iBAAiB;YAAK;QACpE;QAEA,IAAI,CAAC,SAAS,OAAO;YAAE,SAAS;YAAO,OAAO;QAAoB;QAElE,IAAI,QAAQ,eAAe,IAAI,QAAQ,eAAe,KAAK,UAAU;YACjE,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA2B;QAC/D;QAEA,MAAM,MAAM,IAAI;QAEhB,oBAAoB;QACpB,IAAI,MAAM,QAAQ,SAAS,EAAE;YACzB,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA8B;QAClE;QACA,IAAI,MAAM,QAAQ,OAAO,EAAE;YACvB,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA4B;QAChE;QAEA,6BAA6B;QAC7B,MAAM,YAAY,GAAG,QAAQ,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,KAAK,GAAG,IAAI;QAEjE,0DAA0D;QAC1D,MAAM,wBAAwB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YACvE,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;QACJ;QAEA,IAAI,uBAAuB,WAAW;YAClC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA4D;QAChG;QAEA,IAAI,uBAAuB,YAAY;YACnC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAyC;QAC7E;QAEA,kDAAkD;QAClD,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC;YAC3D,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,QAAQ;gBACJ;gBACA,kBAAkB;gBAClB,eAAe;YACnB;YACA,QAAQ;gBACJ,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,WAAW;gBACX;gBACA,kBAAkB;gBAClB,eAAe;YACnB;QACJ;QAEA,OAAO;YACH,SAAS;YACT;YACA,iBAAiB,cAAc,EAAE;YACjC,iBAAiB,cAAc,eAAe;YAC9C,WAAW,cAAc,SAAS;QACtC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkC;IACtE;AACJ;AAKO,eAAe,oBAClB,SAAiB,EACjB,IAAuJ,EACvJ,OAAgB,EAChB,QAA8B;IAE9B,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC/D,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;QACJ;QAEA,IAAI,CAAC,eAAe;YAChB,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;QAEA,uCAAuC;QACvC,MAAM,eAAe;YACjB,YAAY;YACZ,iBAAiB;YACjB,YAAY;YACZ,eAAe;YACf,mBAAmB;YACnB,oBAAoB;YACpB,WAAW;YACX,kBAAkB;QACtB,CAAC,CAAC,KAAK;QAEP,0CAA0C;QAC1C,MAAM,SAAS,MAAM,uHAAM,CAAC,YAAY,CAAC,OAAO;YAC5C,oFAAoF;YACpF,MAAM,gBAAgB,MAAM,GAAG,gBAAgB,CAAC,SAAS,CAAC;gBACtD,OAAO;oBAAE,iBAAiB,cAAc,EAAE;gBAAC;gBAC3C,SAAS;oBAAE,WAAW;gBAAO;YACjC;YAEA,IAAI,eAAe;gBACf,MAAM,WAAW,KAAK,GAAG,KAAK,cAAc,SAAS,CAAC,OAAO;gBAC7D,+DAA+D;gBAC/D,IAAI,WAAW,MAAM;oBACjB,OAAO;wBACH,GAAG,aAAa;wBAChB,WAAW,cAAc,SAAS;wBAClC,WAAW,cAAc,SAAS;wBAClC,iBAAiB,cAAc,eAAe;wBAC9C,oBAAoB,cAAc,kBAAkB;wBACpD,kBAAkB,cAAc,gBAAgB;oBACpD;gBACJ;YACJ;YAEA,0BAA0B;YAC1B,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC;gBAC7B,MAAM;oBACF,iBAAiB,cAAc,EAAE;oBACjC,MAAM;oBACN;oBACA,UAAU,YAAY;gBAC1B;YACJ;YAEA,kDAAkD;YAClD,MAAM,qBAAqB,cAAc,eAAe,GAAG;YAC3D,MAAM,aAAa,sBAAsB;YAEzC,wBAAwB;YACxB,IAAI,mBAAgC;YACpC,IAAI,qBAAqB;YACzB,IAAI,YAAY;YAEhB,IAAI,sBAAsB,GAAG;gBACzB,kCAAkC;gBAClC,qBAAqB;gBACrB,YAAY;YAChB,OAAO,IAAI,sBAAsB,GAAG;gBAChC,uCAAuC;gBACvC,mBAAmB,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,OAAO,YAAY;gBACrE,YAAY;YAChB;YAEA,MAAM,UAAU,MAAM,GAAG,oBAAoB,CAAC,MAAM,CAAC;gBACjD,OAAO;oBAAE,IAAI,cAAc,EAAE;gBAAC;gBAC9B,MAAM;oBACF,CAAC,aAAa,EAAE;wBAAE,WAAW;oBAAE;oBAC/B,iBAAiB;wBAAE,WAAW;oBAAE;oBAChC,WAAW,cAAc,cAAc,SAAS;oBAChD;oBACA;oBACA;gBACJ;YACJ;YAEA,OAAO;QACX;QAEA,OAAO;YACH,SAAS;YACT,iBAAiB,OAAO,eAAe;YACvC,WAAW,OAAO,SAAS;YAC3B,WAAW,OAAO,SAAS;YAC3B,kBAAkB,OAAO,gBAAgB,EAAE,iBAAiB;YAC5D,oBAAoB,OAAO,kBAAkB;QACjD;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0B;IAC9D;AACJ;AAKO,eAAe,uBAAuB,SAAiB,EAAE,SAAiB;IAC7E,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;QAAO,OAAO;IAAe;IAEjF,IAAI;QACA,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC/D,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,SAAS;gBACL,SAAS;oBACL,QAAQ;wBAAE,WAAW;wBAAM,SAAS;oBAAK;gBAC7C;YACJ;QACJ;QAEA,IAAI,CAAC,eAAe;YAChB,OAAO;gBAAE,SAAS;gBAAM,OAAO;gBAAO,QAAQ;YAAyB;QAC3E;QAEA,mBAAmB;QACnB,IAAI,cAAc,SAAS,EAAE;YACzB,OAAO;gBAAE,SAAS;gBAAM,OAAO;gBAAO,QAAQ;YAA4B;QAC9E;QAEA,oBAAoB;QACpB,IAAI,cAAc,UAAU,EAAE;YAC1B,OAAO;gBAAE,SAAS;gBAAM,OAAO;gBAAO,QAAQ;YAA2B;QAC7E;QAEA,yCAAyC;QACzC,IAAI,cAAc,SAAS,KAAK,WAAW;YACvC,0BAA0B;YAC1B,MAAM,oBAAoB,WAAW,aAAa;YAClD,OAAO;gBAAE,SAAS;gBAAM,OAAO;gBAAO,QAAQ;YAA4C;QAC9F;QAEA,oBAAoB;QACpB,MAAM,MAAM,IAAI;QAChB,IAAI,MAAM,cAAc,OAAO,CAAC,OAAO,EAAE;YACrC,OAAO;gBAAE,SAAS;gBAAM,OAAO;gBAAO,QAAQ;YAAoB;QACtE;QAEA,OAAO;YACH,SAAS;YACT,OAAO;YACP,iBAAiB,cAAc,eAAe;YAC9C,WAAW,cAAc,SAAS;QACtC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;YAAO,OAAO;QAA6B;IAC/E;AACJ;AAKO,eAAe,2BAA2B,SAAiB;IAC9D,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,UAAU;QAAO,OAAO;IAAe;IAEpE,IAAI;QACA,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC/D,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,SAAS;gBACL,SAAS;oBACL,QAAQ;wBAAE,WAAW;wBAAM,SAAS;oBAAK;gBAC7C;YACJ;QACJ;QAEA,IAAI,CAAC,eAAe;YAChB,OAAO;gBAAE,UAAU;gBAAO,QAAQ;YAAyB;QAC/D;QAEA,2BAA2B;QAC3B,IAAI,cAAc,SAAS,EAAE;YACzB,OAAO;gBAAE,UAAU;gBAAO,QAAQ;YAAsC;QAC5E;QAEA,IAAI,cAAc,UAAU,EAAE;YAC1B,OAAO;gBAAE,UAAU;gBAAO,QAAQ;YAAyC;QAC/E;QAEA,MAAM,MAAM,IAAI;QAChB,IAAI,MAAM,cAAc,OAAO,CAAC,SAAS,EAAE;YACvC,OAAO;gBAAE,UAAU;gBAAO,QAAQ;YAA0B;QAChE;QAEA,IAAI,MAAM,cAAc,OAAO,CAAC,OAAO,EAAE;YACrC,OAAO;gBAAE,UAAU;gBAAO,QAAQ;YAAoB;QAC1D;QAEA,OAAO;YACH,UAAU;YACV,UAAU,cAAc,SAAS,GAAG;gBAAC;aAA2C,GAAG,EAAE;QACzF;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YAAE,UAAU;YAAO,OAAO;QAA8B;IACnE;AACJ;AAKO,eAAe,uBAAuB,SAAiB;IAC1D,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC/D,OAAO;gBACH,kBAAkB;oBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;oBACvB,WAAW;gBACf;YACJ;YACA,QAAQ;gBACJ,eAAe;gBACf,YAAY;gBACZ,WAAW;gBACX,WAAW;gBACX,iBAAiB;gBACjB,WAAW;gBACX,kBAAkB;gBAClB,oBAAoB;YACxB;QACJ;QAEA,kCAAkC;QAClC,IAAI,eAAe,oBAAoB,IAAI,SAAS,cAAc,gBAAgB,EAAE;YAChF,+BAA+B;YAC/B,MAAM,uHAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC;gBACrC,OAAO;oBACH,kBAAkB;wBACd,QAAQ,QAAQ,IAAI,CAAC,EAAE;wBACvB,WAAW;oBACf;gBACJ;gBACA,MAAM;oBACF,WAAW;oBACX,kBAAkB;gBACtB;YACJ;YAEA,OAAO;gBACH,SAAS;gBACT,eAAe;oBACX,GAAG,aAAa;oBAChB,WAAW;oBACX,kBAAkB;gBACtB;YACJ;QACJ;QAEA,OAAO;YACH,SAAS;YACT,eAAe,iBAAiB;QACpC;IACJ,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAAqC;IACzE;AACJ;AASO,eAAe,uBAAuB,SAAiB;IAC1D,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,MAAM,cAAc,QAAQ,IAAI;IAEhC,2CAA2C;IAC3C,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC5C,OAAO;YAAE,IAAI;QAAU;QACvB,QAAQ;YAAE,WAAW;QAAK;IAC9B;IAEA,IAAI,CAAC,SAAS,OAAO;QAAE,SAAS;QAAO,OAAO;IAAoB;IAElE,MAAM,eACF,YAAY,IAAI,KAAK,WACrB,YAAY,IAAI,KAAK,qBACrB,YAAY,IAAI,KAAK,aACrB,QAAQ,SAAS,KAAK,YAAY,EAAE;IAExC,IAAI,CAAC,cAAc;QACf,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,eAAe,MAAM,uHAAM,CAAC,oBAAoB,CAAC,QAAQ,CAAC;YAC5D,OAAO;gBAAE;YAAU;YACnB,SAAS;gBACL,MAAM;oBACF,QAAQ;wBACJ,IAAI;wBACJ,MAAM;wBACN,OAAO;wBACP,OAAO;oBACX;gBACJ;gBACA,YAAY;oBACR,SAAS;wBAAE,WAAW;oBAAO;oBAC7B,MAAM;gBACV;YACJ;YACA,SAAS;gBACL;oBAAE,oBAAoB;gBAAO;gBAC7B;oBAAE,WAAW;gBAAO;gBACpB;oBAAE,iBAAiB;gBAAO;aAC7B;QACL;QAEA,OAAO;YAAE,SAAS;YAAM;QAAa;IACzC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA6B;IACjE;AACJ;AAKO,eAAe,mBAAmB,SAAiB,EAAE,MAAc;IACtE,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,MAAM,cAAc,QAAQ,IAAI;IAEhC,sBAAsB;IACtB,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC5C,OAAO;YAAE,IAAI;QAAU;QACvB,QAAQ;YAAE,WAAW;QAAK;IAC9B;IAEA,IAAI,CAAC,SAAS,OAAO;QAAE,SAAS;QAAO,OAAO;IAAoB;IAElE,MAAM,eACF,YAAY,IAAI,KAAK,WACrB,YAAY,IAAI,KAAK,qBACrB,YAAY,IAAI,KAAK,aACrB,QAAQ,SAAS,KAAK,YAAY,EAAE;IAExC,IAAI,CAAC,cAAc;QACf,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,uHAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC;YACrC,OAAO;gBACH,kBAAkB;oBACd;oBACA;gBACJ;YACJ;YACA,MAAM;gBACF,WAAW;gBACX,kBAAkB;gBAClB,oBAAoB;gBACpB,iBAAiB;gBACjB,gBAAgB;gBAChB,qBAAqB;gBACrB,gBAAgB;gBAChB,eAAe;gBACf,eAAe;gBACf,iBAAiB;gBACjB,WAAW;gBACX,aAAa,YAAY,EAAE;gBAC3B,aAAa,IAAI;YACrB;QACJ;QAEA,IAAA,+IAAc,EAAC,CAAC,oBAAoB,EAAE,UAAU,aAAa,CAAC;QAC9D,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO;YAAE,SAAS;YAAO,OAAO;QAAgC;IACpE;AACJ;AAKO,eAAe,yBAAyB,SAAiB,EAAE,MAAc;IAC5E,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,MAAM,cAAc,QAAQ,IAAI;IAEhC,sBAAsB;IACtB,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC5C,OAAO;YAAE,IAAI;QAAU;QACvB,QAAQ;YAAE,WAAW;QAAK;IAC9B;IAEA,IAAI,CAAC,SAAS,OAAO;QAAE,SAAS;QAAO,OAAO;IAAoB;IAElE,MAAM,eACF,YAAY,IAAI,KAAK,WACrB,YAAY,IAAI,KAAK,qBACrB,YAAY,IAAI,KAAK,aACrB,QAAQ,SAAS,KAAK,YAAY,EAAE;IAExC,IAAI,CAAC,cAAc;QACf,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,gBAAgB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC;YAC/D,OAAO;gBACH,kBAAkB;oBACd;oBACA;gBACJ;YACJ;YACA,SAAS;gBACL,MAAM;oBACF,QAAQ;wBAAE,IAAI;wBAAM,MAAM;wBAAM,OAAO;oBAAK;gBAChD;gBACA,YAAY;oBACR,SAAS;wBAAE,WAAW;oBAAO;gBACjC;YACJ;QACJ;QAEA,OAAO;YAAE,SAAS;YAAM;QAAc;IAC1C,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAQO,MAAA,6BAAA,eAAe,sBAAsB,SAAiB;IAEzD,IAAA,yIAAQ,EAAC,CAAC,YAAY,EAAE,WAAW;IACnC,aAAa;IACb,IAAA,0IAAS,EAAC;IAEV,IAAI;QACA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,oBAAoB,CAAC,QAAQ,CAAC;YAC9D,OAAO;gBACH;YAEJ;YACA,SAAS;gBACL,MAAM;oBACF,QAAQ;wBACJ,IAAI;wBACJ,MAAM;wBACN,OAAO;oBACX;gBACJ;YACJ;QACJ;QAEA,MAAM,UAAU,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE,IAAI;YAAU;YACvB,SAAS;gBACL,UAAU;oBACN,SAAS;wBACL,SAAS;4BACL,QAAQ;gCACJ,IAAI;gCACJ,OAAO;gCACP,YAAY;gCACZ,MAAM;gCACN,OAAO;4BACX;wBACJ;oBACJ;oBACA,SAAS;wBAAE,OAAO;oBAAM;gBAC5B;YACJ;QACJ;QAEA,IAAI,CAAC,SAAS,OAAO;YAAE,SAAS;YAAO,OAAO;QAAoB;QAElE,MAAM,cAAc,MAAM,QAAQ,GAAG,CAAC,eAAe,GAAG,CAAC,OAAO;YAC5D,sDAAsD;YACtD,MAAM,cAAc,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACjD,OAAO;oBACH,QAAQ,EAAE,MAAM;oBAChB,WAAW;oBACX,WAAW;wBACP,KAAK,QAAQ,SAAS;wBACtB,KAAK,QAAQ,OAAO;oBACxB;gBACJ;gBACA,QAAQ;oBACJ,IAAI;oBACJ,QAAQ;oBACR,WAAW;oBACX,WAAW;oBACX,UAAU;wBACN,QAAQ;4BACJ,IAAI;4BACJ,MAAM;wBACV;oBACJ;gBACJ;YACJ;YAEA,wBAAwB;YACxB,4CAA4C;YAC5C,MAAM,gBAAgB,IAAI;YAC1B,MAAM,oBAAoB,IAAI;YAC9B,MAAM,0BAA0B,IAAI;YACpC,MAAM,yBAAyB,IAAI;YAEnC,YAAY,OAAO,CAAC,CAAA;gBAChB,MAAM,eAAe,wBAAwB,GAAG,CAAC,IAAI,SAAS,KAAK;gBACnE,wBAAwB,GAAG,CAAC,IAAI,SAAS,EAAE,eAAe;gBAE1D,IAAI,IAAI,MAAM,KAAK,YAAY;oBAC3B,MAAM,cAAc,cAAc,GAAG,CAAC,IAAI,SAAS,KAAK;oBACxD,MAAM,aAAa,QAAQ,QAAQ,CAAC,IAAI,CAAC,CAAA,KAAM,GAAG,SAAS,KAAK,IAAI,SAAS;oBAC7E,MAAM,WAAW,YAAY,QAAQ,SAAS;oBAE9C,IAAI,WAAW,aAAa;wBACvB,cAAc,GAAG,CAAC,IAAI,SAAS,EAAE;wBACjC,MAAM,kBAAkB,kBAAkB,GAAG,CAAC,IAAI,SAAS;wBAC3D,IAAI,CAAC,mBAAmB,IAAI,SAAS,GAAG,iBAAiB;4BACrD,kBAAkB,GAAG,CAAC,IAAI,SAAS,EAAE,IAAI,SAAS;4BAClD,uBAAuB,GAAG,CAAC,IAAI,SAAS,EAAE;wBAC9C;oBACL;gBACJ;YACJ;YAEA,IAAI,aAAa;YACjB,IAAI,cAAc;YAElB,cAAc,OAAO,CAAC,CAAC,OAAO;gBAC1B,cAAc;gBACd,MAAM,cAAc,kBAAkB,GAAG,CAAC;gBAC1C,IAAI,aAAa;oBACb,eAAgB,YAAY,OAAO,KAAK,QAAQ,SAAS,CAAC,OAAO;gBACrE;YACJ;YAEA,4CAA4C;YAC5C,MAAM,eAAe,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAA;gBACtC,MAAM,UAAU,uBAAuB,GAAG,CAAC,GAAG,SAAS;gBACvD,OAAO;oBACH,WAAW,GAAG,SAAS;oBACvB,OAAO,GAAG,OAAO,CAAC,KAAK;oBACvB,MAAM,GAAG,OAAO,CAAC,IAAI;oBACrB,OAAO,cAAc,GAAG,CAAC,GAAG,SAAS,KAAK;oBAC1C,UAAU,GAAG,OAAO,CAAC,KAAK;oBAC1B,aAAa,wBAAwB,GAAG,CAAC,GAAG,SAAS,KAAK;oBAC1D,QAAQ,cAAc,GAAG,CAAC,GAAG,SAAS;oBACtC,UAAU,kBAAkB,GAAG,CAAC,GAAG,SAAS;oBAC5C,UAAU,SAAS,UAAU,QAAQ;oBACrC,YAAY,SAAS,UAAU,MAAM;gBACzC;YACJ;YAEA,OAAO;gBACH,GAAG,EAAE,IAAI;gBACT,OAAO;gBACP,WAAW;gBACX,gBAAgB,cAAc,IAAI;gBAClC;YACJ;QACJ;QAEA,8CAA8C;QAC9C,YAAY,IAAI,CAAC,CAAC,GAAG;YACjB,IAAI,EAAE,KAAK,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,GAAG,EAAE,KAAK;YACjD,OAAO,EAAE,SAAS,GAAG,EAAE,SAAS;QACpC;QAEA,OAAO;YACH,SAAS;YACT,UAAU;YACV,aAAa,QAAQ,WAAW;YAChC,UAAU,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAA,KAAM,CAAC;oBAClC,IAAI,GAAG,SAAS;oBAChB,OAAO,GAAG,OAAO,CAAC,KAAK;oBACvB,MAAM,GAAG,OAAO,CAAC,IAAI;oBACrB,UAAU,GAAG,OAAO,CAAC,KAAK;gBAC9B,CAAC;QACL;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO;YAAE,SAAS;YAAO,OAAO;QAAiC;IACrE;AACJ;IA5JO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAiKf,eAAe,kBAAkB,SAAiB;IACrD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,OAAO;QAAE,SAAS;QAAO,OAAO;IAAe;IAEnE,IAAI;QACA,MAAM,SAAS,MAAM,sBAAsB;QAE3C,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,QAAQ,EAAE;YACrC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAwB;QAC5D;QAEA,MAAM,OAAO,OAAO,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAW,EAAE,EAAE,KAAK,QAAQ,IAAI,CAAC,EAAE,IAAI;QAE/E,OAAO;YAAE,SAAS;YAAM,MAAM,OAAO,IAAI,OAAO;QAAK;IACzD,EAAE,OAAO,OAAO;QACX,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC7D;AACJ;;;IAt1CsB;IAuGA;IAiIA;IA8DA;IAqFA;IAaA;IAoBA;IA6BA;IAyCA;IA4FA;IA8BA;IAwFA;IA0HA;IAgEA;IAyDA;IAqEA;IA6DA;IA+DA;IA0NA;;AAl0CA,+OAAA;AAuGA,+OAAA;AAiIA,+OAAA;AA8DA,+OAAA;AAqFA,+OAAA;AAaA,+OAAA;AAoBA,+OAAA;AA6BA,+OAAA;AAyCA,+OAAA;AA4FA,+OAAA;AA8BA,+OAAA;AAwFA,+OAAA;AA0HA,+OAAA;AAgEA,+OAAA;AAyDA,+OAAA;AAqEA,+OAAA;AA6DA,+OAAA;AA+DA,+OAAA;AA0NA,+OAAA"}},
    {"offset": {"line": 2951, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/WorkspaceClientWrapper.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/workspace/WorkspaceClientWrapper.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/workspace/WorkspaceClientWrapper.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAmT,GAChV,iFACA","ignoreList":[0]}},
    {"offset": {"line": 2965, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/WorkspaceClientWrapper.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/workspace/WorkspaceClientWrapper.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/workspace/WorkspaceClientWrapper.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA+R,GAC5T,6DACA","ignoreList":[0]}},
    {"offset": {"line": 2979, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2987, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/problems/ConceptViewer.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/problems/ConceptViewer.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/problems/ConceptViewer.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAyS,GACtU,uEACA","ignoreList":[0]}},
    {"offset": {"line": 3001, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/problems/ConceptViewer.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/problems/ConceptViewer.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/problems/ConceptViewer.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAqR,GAClT,mDACA","ignoreList":[0]}},
    {"offset": {"line": 3015, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 3023, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/app/%28workspace%29/problems/%5Bslug%5D/page.tsx"],"sourcesContent":["import { getProblem, getNextProblem, getPreviousProblem } from \"@/actions/problems\";\nimport { getContestDetail } from \"@/actions/contest\";\n\nimport { notFound, redirect } from \"next/navigation\";\nimport WorkspaceClientWrapper from \"@/components/workspace/WorkspaceClientWrapper\";\nimport { prisma } from \"@/lib/prisma\";\nimport { Laptop2 } from \"lucide-react\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport ConceptViewer from \"@/components/problems/ConceptViewer\";\nimport { Suspense } from \"react\";\n\n// MIGRATED: Removed export const revalidate = 3600 (incompatible with Cache Components)\n// Caching is now handled via \"use cache\" in the getProblem action with cacheLife\n\ninterface PageProps {\n  params: Promise<{ slug: string }>;\n  searchParams: Promise<{ contestId?: string }>;\n}\n\n// GENERATING METADATA FOR THE PROBLEM PAGE (SEO)\nexport async function generateMetadata({ params }: PageProps) {\n  const { slug } = await params;\n  const problem = await getProblem(slug);\n\n  if (!problem) {\n    return {\n      title: \"Problem Not Found\",\n    };\n  }\n\n  return {\n    title: `${problem.title} | Algofox`,\n    description: problem.description.slice(0, 160),\n  };\n}\n\n// Component that handles searchParams AND params access (wrapped in Suspense)\nasync function ProblemContentWithParams({\n  params,\n  searchParams\n}: {\n  params: Promise<{ slug: string }>;\n  searchParams: Promise<{ contestId?: string }>;\n}) {\n  \"use cache: private\";\n  const { slug } = await params;\n  const { contestId } = await searchParams;\n\n  const problem = await getProblem(slug);\n\n  if (!problem) {\n    return notFound();\n  }\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  let isSolved = false;\n  let contestData = null;\n  let solvedProblemIds: string[] = [];\n\n  if (session?.user) {\n    if (contestId) {\n      const contestResponse = await getContestDetail(contestId);\n      if (contestResponse.success) {\n        if ((contestResponse.contest as any).isFinished) {\n          return redirect(`/contest/${contestId}`);\n        }\n        contestData = contestResponse.contest;\n\n        // Contextual Check: Is this problem solved IN THIS SPECIFIC CONTEST?\n        if (session.user.role === \"ADMIN\") {\n             isSolved = true;\n        } else {\n            const contestSubmission = await prisma.submission.findFirst({\n              where: {\n                problemId: problem.id,\n                userId: session.user.id,\n                status: \"ACCEPTED\",\n                mode: \"SUBMIT\",\n                contestId: contestId\n              }\n            });\n            isSolved = !!contestSubmission;\n        }\n\n        // Fetch all solved problems in this contest for the user\n        const contestSolvedSubmissions = await prisma.submission.findMany({\n          where: {\n            userId: session.user.id,\n            status: \"ACCEPTED\",\n            mode: \"SUBMIT\",\n            contestId: contestId,\n            problemId: { in: (contestResponse.contest as any).problems.map((p: any) => p.problem.id) }\n          },\n          select: { problemId: true }\n        });\n        solvedProblemIds = contestSolvedSubmissions.map(s => s.problemId);\n      } else {\n           // Fallback if contest not found\n           if (session.user.role === \"ADMIN\") {\n                isSolved = true;\n            } else {\n                const submission = await prisma.submission.findFirst({\n                    where: {\n                    problemId: problem.id,\n                    userId: session.user.id,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                    }\n                });\n                isSolved = !!submission;\n            }\n      }\n    } else {\n        // Global Check (Not in a contest context)\n        if (session.user.role === \"ADMIN\") {\n            isSolved = true;\n        } else {\n            const submission = await prisma.submission.findFirst({\n                where: {\n                problemId: problem.id,\n                userId: session.user.id,\n                status: \"ACCEPTED\",\n                mode: \"SUBMIT\"\n                }\n            });\n            isSolved = !!submission;\n        }\n\n        // Fetch all solved problems for the user (Global)\n        const allSolved = await prisma.submission.findMany({\n            where: {\n                userId: session.user.id,\n                status: \"ACCEPTED\",\n                mode: \"SUBMIT\"\n            },\n            select: { problemId: true },\n            distinct: ['problemId']\n        });\n        solvedProblemIds = allSolved.map(s => s.problemId);\n    }\n  }\n\n  if (problem.difficulty === \"CONCEPT\") {\n    return (\n      <ConceptViewer problem={problem} isSolved={isSolved} />\n    );\n  }\n\n  return (\n    <>\n      <div className=\"md:hidden flex flex-col items-center justify-center min-h-screen p-8 text-center bg-gray-50 dark:bg-[#0a0a0a]\">\n        <div className=\"w-16 h-16 bg-orange-100 dark:bg-orange-500/20 rounded-2xl flex items-center justify-center mb-6 mx-auto\">\n          <Laptop2 className=\"w-8 h-8 text-orange-600 dark:text-orange-400\" />\n        </div>\n        <h1 className=\"text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2\">Desktop Required</h1>\n        <p className=\"text-gray-600 dark:text-gray-400 max-w-sm mx-auto\">\n          For the best coding experience, please open this problem on a desktop or laptop device.\n        </p>\n      </div>\n      <div className=\"hidden md:block\">\n        <WorkspaceClientWrapper\n          problem={problem}\n          isSolved={isSolved}\n          contestId={contestId}\n          contest={contestData}\n          solvedProblemIds={solvedProblemIds}\n          nextProblemSlug={await getNextProblem(problem.createdAt, problem.domain, problem.type)}\n          prevProblemSlug={await getPreviousProblem(problem.createdAt, problem.domain, problem.type)}\n        />\n      </div>\n    </>\n  );\n}\n\nexport default function ProblemPage({ params, searchParams }: PageProps) {\n  return (\n    <Suspense fallback={\n      <div className=\"min-h-screen bg-white dark:bg-[#0a0a0a] flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-orange-500 mx-auto\"></div>\n          <p className=\"mt-4 text-gray-600 dark:text-gray-400\">Loading problem...</p>\n        </div>\n      </div>\n    }>\n      <ProblemContentWithParams params={params} searchParams={searchParams} />\n    </Suspense>\n  );\n}\n\n\n\n// PRE-GENERATING STATIC PAGES FOR TOP 50 PROBLEMS AT BUILD TIME\n// Note: Contest-specific problems (hidden: true) are not included here but will be handled dynamically\n\nexport async function generateStaticParams() {\n  try {\n    const problems = await prisma.problem.findMany({\n      where: { hidden: false },\n      select: { slug: true },\n      orderBy: { createdAt: 'desc' },\n      take: 50, // PRE-RENDER TOP 50 PROBLEMS\n    });\n\n    // Next.js 16 requires at least one result for Cache Components\n    // If no problems exist, return a placeholder that will be handled by the dynamic route\n    if (problems.length === 0) {\n      return [{ slug: 'placeholder' }];\n    }\n\n    return problems.map((p) => ({\n      slug: p.slug,\n    }));\n  } catch (error) {\n    // Fallback to ensure we always return at least one result\n    console.error(\"Error generating static params for problems:\", error);\n    return [{ slug: 'placeholder' }];\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3344, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/languages.ts"],"sourcesContent":["\nexport interface Language {\n    id: number; // Judge0 ID\n    name: string;\n    monacoLanguage: string; // Monaco Editor language identifier\n    boilerplate: string;\n}\n\nexport const LANGUAGES: Language[] = [\n    {\n        id: 63,\n        name: \"JavaScript\",\n        monacoLanguage: \"javascript\",\n        boilerplate: `const fs = require(\"fs\");\n\nconst input = fs.readFileSync(0, \"utf8\").trim().split(/\\\\s+/);\n\n// write your code here\n\nconsole.log();`\n    },\n\n    {\n        id: 62,\n        name: \"Java\",\n        monacoLanguage: \"java\",\n        boilerplate: `import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        // write your code here\n\n        \n    }\n}`\n    },\n\n    {\n        id: 71,\n        name: \"Python\",\n        monacoLanguage: \"python\",\n        boilerplate: `import sys\n\ndata = sys.stdin.read().split()\n\n# write your code here\n\nprint()`\n    },\n\n    {\n        id: 50,\n        name: \"C\",\n        monacoLanguage: \"c\",\n        boilerplate: `#include <stdio.h>\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 54,\n        name: \"C++\",\n        monacoLanguage: \"cpp\",\n        boilerplate: `#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 73,\n        name: \"Rust\",\n        monacoLanguage: \"rust\",\n        boilerplate: `use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    // write your code here\n}`\n    },\n\n    {\n        id: 60,\n        name: \"Go\",\n        monacoLanguage: \"go\",\n        boilerplate: `package main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    in := bufio.NewReader(os.Stdin)\n\n    // write your code here\n\n}`\n    },\n    {\n        id: 82,\n        name: \"SQL\",\n        monacoLanguage: \"sql\",\n        boilerplate: `` // Empty boilerplate for SQL\n    }\n];\n\nexport function getLanguageById(id: number): Language | undefined {\n    return LANGUAGES.find(lang => lang.id === id);\n}\n\nexport function getLanguageByName(name: string): Language | undefined {\n    return LANGUAGES.find(lang => lang.name === name);\n}\n\nexport const DEFAULT_LANGUAGE_ID = 63;\n\n"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,YAAwB;IACjC;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;cAMR,CAAC;IACX;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;CASrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;OAMf,CAAC;IACJ;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;CAQrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;;;;CAYrB,CAAC;IACE;IACA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,EAAE,CAAC,4BAA4B;IAChD;CACH;AAEM,SAAS,gBAAgB,EAAU;IACtC,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;AAC9C;AAEO,SAAS,kBAAkB,IAAY;IAC1C,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;AAChD;AAEO,MAAM,sBAAsB"}},
    {"offset": {"line": 3470, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 3498, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/submission.service.ts"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\nimport { SubmissionResult, TestCaseResult, SubmissionMode } from \"@prisma/client\";\nimport { getLanguageById } from \"@/lib/languages\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport { revalidateTag, updateTag } from \"next/cache\";\nimport redis from \"@/lib/redis\";\n\nconst JUDGE0_URL = process.env.JUDGE0_URL || \"http://localhost:2358\";\n\nexport class SubmissionService {\n    private static languageCache = new Map<number, { id: number; name: string; judge0Id: number }>();\n\n    static async createSubmission(userId: string, problemId: string, judge0Id: number, code: string, mode: SubmissionMode = \"SUBMIT\", contestId?: string) {\n        // Get language info from our language mapping\n        const langInfo = getLanguageById(judge0Id);\n        const languageName = langInfo?.name || `Language_${judge0Id}`;\n\n        // Check cache first\n        let language = this.languageCache.get(judge0Id);\n\n        if (!language) {\n            // Try to find existing language by judge0Id first (primary lookup)\n            const dbLanguage = await prisma.language.findUnique({\n                where: { judge0Id: judge0Id }\n            });\n\n            if (dbLanguage) {\n                language = dbLanguage;\n            } else {\n                // If not found, try to create it\n                try {\n                    language = await prisma.language.create({\n                        data: {\n                            name: languageName,\n                            judge0Id: judge0Id\n                        }\n                    });\n                } catch (error: any) {\n                    // If creation fails due to name conflict, try to find by name\n                    // This handles the case where a language with this name exists but different judge0Id\n                    if (error.code === 'P2002') {\n                        const existingByName = await prisma.language.findUnique({\n                            where: { name: languageName }\n                        });\n                        if (existingByName) {\n                            // Use the existing language even if judge0Id doesn't match\n                            // In production, languages should be pre-seeded to avoid this\n                            language = existingByName;\n                        } else {\n                            // If it's a judge0Id conflict, find by judge0Id\n                            const existingByJudge0Id = await prisma.language.findUnique({\n                                where: { judge0Id: judge0Id }\n                            });\n                            if (!existingByJudge0Id) {\n                                throw new Error(`Could not create or find language with judge0Id ${judge0Id}`);\n                            }\n                            language = existingByJudge0Id;\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n            }\n\n            // Update cache\n            if (language) {\n                this.languageCache.set(judge0Id, language);\n            }\n        }\n\n        return prisma.submission.create({\n            data: {\n                userId,\n                problemId,\n                languageId: language.id, // Use the internal PK\n                code,\n                status: \"PENDING\",\n                mode,\n                contestId,\n            },\n            include: {\n                problem: {\n                    include: {\n                        testCases: true\n                    }\n                },\n                language: true\n            }\n        });\n    }\n\n    static async updateSubmissionStatus(submissionId: string, status: SubmissionResult, time?: number, memory?: number) {\n        await prisma.submission.update({\n            where: { id: submissionId },\n            data: { status, time, memory },\n        });\n\n        try {\n            // Only attempt invalidation, don't crash if it fails (e.g. in worker)\n            revalidateTag(`submission-${submissionId}`,\"max\");\n        } catch (error) {\n            // Silently fail in worker context\n        }\n    }\n\n    static async createTestCases(submissionId: string, testCases: { index: number; judge0TrackingId: string }[]) {\n        // Create DB records for tracking individual test case results\n        await prisma.$transaction(\n            testCases.map(tc => prisma.testCase.create({\n                data: {\n                    submissionId,\n                    index: tc.index,\n                    judge0TrackingId: tc.judge0TrackingId,\n                    status: \"PENDING\"\n                }\n            }))\n        );\n    }\n\n    static async updateTestCaseResult(judge0TrackingId: string, status: TestCaseResult, time: number, memory: number, errorMessage?: string | null, stdout?: string | null) {\n        await prisma.testCase.update({\n            where: { judge0TrackingId },\n            data: {\n                status,\n                time,\n                memory,\n                errorMessage: errorMessage || null,\n                stdout: stdout || null\n            }\n        });\n    }\n\n    static async updateTestCasesBatch(updates: { judge0TrackingId: string, status: TestCaseResult, time: number, memory: number, errorMessage?: string | null, stdout?: string | null }[]) {\n        if (updates.length === 0) return;\n\n        await prisma.$transaction(\n            updates.map(update => prisma.testCase.update({\n                where: { judge0TrackingId: update.judge0TrackingId },\n                data: {\n                    status: update.status,\n                    time: update.time,\n                    memory: update.memory,\n                    errorMessage: update.errorMessage || null,\n                    stdout: update.stdout || null\n                }\n            }))\n        );\n    }\n\n    static async sendToJudge0(languageId: number, code: string, testCases: { input: string; output: string }[]) {\n        // Determine Judge0 Language ID from our DB Language ID (assuming mapping exists or is direct)\n        // For now assuming the passed languageId is the Judge0 ID.\n\n        const encodedCode = Buffer.from(code).toString('base64');\n        const submissions = testCases.map(tc => ({\n            language_id: languageId,\n            source_code: encodedCode,\n            stdin: Buffer.from(tc.input).toString('base64'),\n            expected_output: Buffer.from(tc.output).toString('base64'),\n        }));\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout\n\n        try {\n            const response = await fetch(`${JUDGE0_URL}/submissions/batch?base64_encoded=true`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({ submissions }),\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`Judge0 Error: ${response.statusText}`);\n            }\n\n            const data = await response.json();\n            // data type: { token: string }[] (if params say so, but usually it returns tokens)\n            return data as { token: string }[];\n        } catch (error) {\n            console.error(\"Failed to send to Judge0\", error);\n            throw error;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    static async getBatchResults(tokens: string[]) {\n        if (tokens.length === 0) return [];\n\n        const tokensStr = tokens.join(\",\");\n        // Include compile_output, stderr for error messages, and stdout for user output\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout\n\n        try {\n            const response = await fetch(`${JUDGE0_URL}/submissions/batch?tokens=${tokensStr}&base64_encoded=true&fields=token,status,time,memory,compile_output,stderr,stdout`, {\n                method: \"GET\",\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`Judge0 Batch Fetch Failed: Status ${response.status}`, errorText);\n                throw new Error(`Failed to fetch batch results: ${response.status} - ${errorText}`);\n            }\n\n            const data = await response.json();\n            return (data.submissions as {\n                token: string;\n                status: { id: number; description: string };\n                time: string;\n                memory: number;\n                compile_output: string | null;\n                stderr: string | null;\n                stdout: string | null;\n            }[]).map(sub => ({\n                ...sub,\n                stdout: sub.stdout ? Buffer.from(sub.stdout, 'base64').toString('utf-8') : null,\n                stderr: sub.stderr ? Buffer.from(sub.stderr, 'base64').toString('utf-8') : null,\n                compile_output: sub.compile_output ? Buffer.from(sub.compile_output, 'base64').toString('utf-8') : null,\n            }));\n        } catch (error) {\n            throw error;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    static async incrementProblemSolved(problemId: string, userId: string) {\n        // Use a transaction to atomically check and update\n        // This helps prevent race conditions when multiple submissions are processed concurrently\n        await prisma.$transaction(async (tx) => {\n            // Check if this is the first time the user has solved this problem\n            // Only count SUBMIT mode submissions to avoid double-counting from RUN mode\n            const acceptedCount = await tx.submission.count({\n                where: {\n                    problemId,\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                }\n            });\n\n            // Only increment if this is the first accepted solution (count should be exactly 1, which is the current one)\n            if (acceptedCount === 1) {\n                // Fetch the problem to get its difficulty\n                const problem = await tx.problem.findUnique({\n                    where: { id: problemId },\n                    select: { difficulty: true }\n                });\n\n                if (!problem) {\n                    throw new Error(\"Problem not found\");\n                }\n\n                // Calculate points based on difficulty\n                const points = getPointsForDifficulty(problem.difficulty);\n\n                // Increment problem's solved count\n                await tx.problem.update({\n                    where: { id: problemId },\n                    data: {\n                        solved: {\n                            increment: 1\n                        }\n                    }\n                });\n\n                // Increment user's problemsSolved count and add points based on difficulty\n                // SKIP IF CONCEPT\n                if (problem.difficulty !== \"CONCEPT\") {\n                    await tx.user.update({\n                        where: { id: userId },\n                        data: {\n                            problemsSolved: {\n                                increment: 1\n                            },\n                            totalScore: {\n                                increment: points\n                            }\n                        }\n                    });\n                }\n\n                // Invalidate user score cache and leaderboard cache\n                try {\n                    await redis.del(`user-score-${userId}`);\n                    // Invalidate leaderboard cache so new users appear\n                    await redis.del('leaderboard:global');\n\n                    // Invalidate Next.js cache tags for categories\n                    try {\n                        updateTag('categories-list');\n                        updateTag(`categories-DSA-user-${userId}`);\n                        updateTag(`categories-SQL-user-${userId}`);\n                        updateTag(`user-submissions-${userId}`);\n                        updateTag('problems-list');\n                        updateTag('problems-search');\n                    } catch (e) {\n                        // Ignore if updateTag is not available or fails\n                    }\n                } catch (error) {\n                    // Cache invalidation might fail in worker context, but that's okay\n                    // The cache will expire naturally after 30 seconds (user score) and 10 minutes (leaderboard)\n                    console.error(\"Failed to invalidate cache:\", error);\n                }\n            }\n        });\n    }\n    static async getSubmissionById(id: string) {\n        return prisma.submission.findUnique({\n            where: { id },\n            include: {\n                problem: {\n                    select: {\n                        id: true,\n                        title: true,\n                        slug: true,\n                        difficulty: true,\n                    }\n                },\n                language: {\n                    select: {\n                        id: true,\n                        name: true,\n                    }\n                },\n                testCases: {\n                    orderBy: { index: 'asc' }\n                }\n            }\n        });\n    }\n\n    static async getProblemSubmissions(problemId: string, userId: string, take: number = 20, cursor?: string) {\n        const query: any = {\n            where: {\n                problemId,\n                userId,\n                mode: \"SUBMIT\" // Only show actual submissions, not runs\n            },\n            include: {\n                language: {\n                    select: {\n                        name: true\n                    }\n                }\n            },\n            take,\n            orderBy: {\n                createdAt: 'desc'\n            }\n        };\n\n        if (cursor) {\n            query.cursor = { id: cursor };\n            query.skip = 1;\n        }\n\n        return prisma.submission.findMany(query);\n    }\n    static async invalidateClassroomTracking(userId: string) {\n        try {\n            // Find all classrooms the user is enrolled in where tracking is active\n            const classrooms = await prisma.classroom.findMany({\n                where: {\n                    students: {\n                        some: { id: userId }\n                    },\n                    isTrackingActive: true\n                },\n                select: { id: true }\n            });\n\n            if (classrooms.length > 0) {\n                 // Invalidate live tracking cache for each classroom\n                 const keys = classrooms.map(c => `algofox:live-tracking:${c.id}`);\n                 await redis.del(...keys);\n\n                 // Also invalidate Next.js cache tags for good measure\n                 classrooms.forEach(c => {\n                     // Since we are in a service/worker context, revalidateTag might be tricky if not in a server action/request\n                     // But we can try just in case this service is called from a server action\n                     try {\n                        revalidateTag(`classroom-${c.id}`, \"max\");\n                     } catch (e) {\n                         // Ignore error if outside request context\n                     }\n                 });\n            }\n        } catch (error) {\n            console.error(\"Failed to invalidate classroom tracking cache:\", error);\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3896, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/submission.action.ts"],"sourcesContent":["\"use server\";\n\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { auth } from \"@/lib/auth\";\n\nimport { revalidatePath, revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { after } from \"next/server\"; // For background tasks\n\nasync function getCachedSubmissionInternal(id: string) {\n    \"use cache\"\n    cacheTag(`submission-${id}`);\n    // @ts-ignore\n    cacheLife(\"default\"); // or \"submission\" if defined\n\n    return SubmissionService.getSubmissionById(id);\n}\n\nexport async function getSubmission(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    const submission = await getCachedSubmissionInternal(id);\n\n    // Security check\n    if (submission && submission.userId !== session.user.id) {\n        return null;\n    }\n\n    return submission;\n}\n\nexport async function getProblemSubmissionsAction(problemId: string, take: number = 20, cursor?: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 60, revalidate: 60 }); // 1 minute default, but we rely on on-demand revalidation ideally\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return [];\n    }\n\n    const userId = session.user.id;\n\n    const tagKey = `problem-submissions-${userId}-${problemId}${cursor ? `-cursor-${cursor}` : \"\"}-take-${take}`;\n    cacheTag(tagKey, `user-submissions-${userId}`, `problem-${problemId}`);\n\n    return SubmissionService.getProblemSubmissions(problemId, userId, take, cursor);\n}\n\nexport async function markConceptAsCompleted(problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    // Use a default language (e.g., JavaScript ID 63) for concept submissions since language doesn't matter\n    const DEFAULT_CONCEPT_LANG_ID = 63;\n\n    try {\n        // Create a submission with ACCEPTED status\n        const submission = await SubmissionService.createSubmission(\n            userId,\n            problemId,\n            DEFAULT_CONCEPT_LANG_ID,\n            \"// CONCEPT COMPLETED\",\n            \"SUBMIT\"\n        );\n\n        // Update status to ACCEPTED\n        await SubmissionService.updateSubmissionStatus(submission.id, \"ACCEPTED\", 0, 0);\n\n        // Move heavy stats updates to background\n        after(async () => {\n             await SubmissionService.incrementProblemSolved(problemId, userId);\n             // Revalidating paths/tags inside after() ensures the next request is fresh,\n             // but current UI might need revalidatePath synchronous if it relies on server reload.\n             // However, separating side-effects is key.\n             // Using revalidateTag inside after works for ISR.\n             revalidateTag(`problem-${problemId}`,\"max\");\n             revalidateTag(`user-submissions-${userId}`,\"max\");\n             revalidateTag(`problem-submissions-${userId}-${problemId}`,\"max\");\n        });\n\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        // These might fail in standard runtime if cache tags aren't updated synchronously?\n        // Actually, revalidating path is enough for UI. Tags are for cached data.\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to mark concept as completed:\", error);\n        return { success: false, error: \"Failed to mark as completed\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4031, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4374, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/analytics.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\n\nexport async function getUserTopicStats(userId?: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const targetUserId = userId || session?.user?.id;\n\n  if (!targetUserId) return null;\n\n  // Fetch all accepted submissions with problem tags\n  const submissions = await prisma.submission.findMany({\n    where: {\n      userId: targetUserId,\n      status: \"ACCEPTED\",\n    },\n    include: {\n      problem: {\n        include: {\n          tags: true,\n        },\n      },\n    },\n  });\n\n  // Aggregate by tag\n  const tagCounts: Record<string, number> = {};\n  const totalSolved = submissions.length;\n\n  submissions.forEach((sub) => {\n    sub.problem.tags.forEach((tag) => {\n      tagCounts[tag.name] = (tagCounts[tag.name] || 0) + 1;\n    });\n  });\n\n  // Convert to array and take top 6\n  const data = Object.entries(tagCounts)\n    .map(([subject, count]) => ({\n      subject, // Tag name\n      A: count, // User's count\n      fullMark: Math.max(count * 1.5, 10), // Arbitrary scaling for chart visual\n    }))\n    .sort((a, b) => b.A - a.A)\n    .slice(0, 6); // Top 6 tags\n\n  return data;\n}\n\nexport async function getUserProgressHistory(userId?: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const targetUserId = userId || session?.user?.id;\n\n  if (!targetUserId) return null;\n\n  const submissions = await prisma.submission.findMany({\n    where: {\n      userId: targetUserId,\n      status: \"ACCEPTED\",\n    },\n    orderBy: {\n      createdAt: \"asc\",\n    },\n    select: {\n      createdAt: true,\n    },\n  });\n\n  // Group by date (cumulative)\n  const history: { date: string; count: number }[] = [];\n  let cumulative = 0;\n  const map = new Map<string, number>();\n\n  submissions.forEach((sub) => {\n    const date = sub.createdAt.toISOString().split(\"T\")[0]; // YYYY-MM-DD\n    map.set(date, (map.get(date) || 0) + 1);\n  });\n\n  // Create cumulative data points\n  // We can just pick every accepted submission as a point, or group by day\n  // Grouping by day is cleaner\n  const sortedDates = Array.from(map.keys()).sort();\n\n  for (const date of sortedDates) {\n    const dailyCount = map.get(date) || 0;\n    cumulative += dailyCount;\n    history.push({\n        date: new Date(date).toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" }),\n        count: cumulative\n    });\n  }\n\n  // Return last 30 data points to avoid clutter, or sample them if huge\n  return history.slice(-30);\n}\n\n// Peer Comparison (Percentiles)\nexport async function getProblemStats(problemId: string, runtime: number, memory: number) {\n    const totalSubmissions = await prisma.submission.count({\n        where: { problemId, status: \"ACCEPTED\" }\n    });\n\n    if (totalSubmissions <= 1) return { runtimePercentile: 100, memoryPercentile: 100 };\n\n    // Runtime Percentile (Higher is better)\n    const slowerSubmissions = await prisma.submission.count({\n        where: {\n            problemId,\n            status: \"ACCEPTED\",\n            time: { gt: runtime }\n        }\n    });\n\n    // Memory Percentile (Higher is better)\n    const heavierSubmissions = await prisma.submission.count({\n        where: {\n            problemId,\n            status: \"ACCEPTED\",\n            memory: { gt: memory }\n        }\n    });\n\n    const runtimePercentile = Math.round((slowerSubmissions / totalSubmissions) * 100);\n    const memoryPercentile = Math.round((heavierSubmissions / totalSubmissions) * 100);\n\n    return { runtimePercentile, memoryPercentile };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4522, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 4660, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4920, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/category.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { ProblemDomain, Difficulty } from \"@prisma/client\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 300; // 5 minutes\n\n// CACHE KEY HELPERS\nconst getCategoriesCacheKey = (domain?: ProblemDomain) =>\n    domain ? `categories:${domain}:all` : \"categories:all\";\nconst getCategoryCacheKey = (slug: string) => `category:${slug}`;\nconst getCategoryProblemsCacheKey = (categoryId: string, page: number) =>\n    `category:${categoryId}:problems:page:${page}`;\n\nexport class CategoryService {\n    // GETTING ALL CATEGORIES\n    static async getCategories(domain: ProblemDomain = \"DSA\", userId?: string) {\n        try {\n            // ONLY CACHING THE BASE CATEGORIES STRUCTURE, NOT USER-SPECIFIC SOLVED COUNTS\n\n            const cacheKey = getCategoriesCacheKey(domain);\n            let categories: any[];\n\n            // GETTING CACHE FOR BASE CATEGORIES\n\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                categories = JSON.parse(cached).categories;\n            } else {\n                categories = await prisma.category.findMany({\n                    where: {\n                        domain\n                    },\n                    orderBy: { order: \"asc\" },\n                    select: {\n                        id: true,\n                        name: true,\n                        description: true,\n                        slug: true,\n                        order: true,\n                        domain: true,\n                        _count: {\n                            select: { categoryProblems: true }\n                        }\n                    }\n                });\n\n                // CACHING THE BASE CATEGORIES STRUCTURE IF NOT CACHED\n\n                await redis.setex(cacheKey, CACHE_TTL, JSON.stringify({ categories }));\n            }\n\n            // IF USER IS LOGGED IN, CALCULATING SOLVED COUNT PER CATEGORY\n\n            if (userId) {\n\n                // USING RAW QUERY FOR PERFORMANCE - 30X FASTER THAN FETCHING ALL ROWS\n\n                const solvedCountsRaw = await prisma.$queryRaw<any[]>`\n           SELECT\n             cp.\"categoryId\",\n             CAST(COUNT(DISTINCT cp.\"problemId\") AS INTEGER) as \"count\"\n           FROM \"CategoryProblem\" cp\n           JOIN \"Submission\" s ON cp.\"problemId\" = s.\"problemId\"\n           WHERE s.\"userId\" = ${userId}\n             AND s.\"status\" = 'ACCEPTED'::\"SubmissionResult\"\n             AND s.\"mode\" = 'SUBMIT'::\"SubmissionMode\"\n           GROUP BY cp.\"categoryId\"\n         `;\n\n                // CREATING A MAP OF SOLVED COUNT PER CATEGORY\n\n                const solvedMap = new Map<string, number>();\n                solvedCountsRaw.forEach((row: any) => {\n                    solvedMap.set(row.categoryId, row.count);\n                });\n\n                // MERGING INTO CATEGORIES\n                categories = categories.map((cat: any) => ({\n                    ...cat,\n                    solvedCount: solvedMap.get(cat.id) || 0\n                }));\n            } else {\n                // IF USER IS NOT LOGGED IN, SETTING SOLVED COUNT TO 0\n\n                categories = categories.map((cat: any) => ({\n                    ...cat,\n                    solvedCount: 0\n                }));\n            }\n\n            // RETURNING THE CATEGORIES\n\n            return { categories };\n        } catch (error) {\n            console.error(\"Failed to fetch categories:\", error);\n            return { categories: [] };\n        }\n    }\n\n    // GETTING A CATEGORY BY SLUG\n    static async getCategoryBySlug(slug: string) {\n        try {\n            const cacheKey = getCategoryCacheKey(slug);\n\n            // GETTING CACHE FOR CATEGORY\n\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                // RETURNING THE CACHE IF CACHED\n\n\n                return JSON.parse(cached);\n            }\n\n            // GETTING CATEGORY FROM DATABASE IF NOT CACHED\n\n            const category = await prisma.category.findUnique({\n                where: { slug },\n                include: {\n                    _count: {\n                        select: { categoryProblems: true }\n                    }\n                }\n            });\n\n            // IF CATEGORY IS NOT FOUND, RETURNING AN ERROR\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // CACHING THE CATEGORY\n\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(category));\n\n            return { success: true, category: category };\n        } catch (error) {\n            console.error(\"Failed to fetch category:\", error);\n            return { success: false, error: \"Failed to fetch category: \" + error };\n        }\n    }\n\n    // GETTING A CATEGORY BY ID --> NO CACHING\n    static async getCategoryById(id: string) {\n        try {\n            const category = await prisma.category.findUnique({\n                where: { id },\n                include: {\n                    _count: {\n                        select: { categoryProblems: true }\n                    }\n                }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            return { success: true, category };\n        } catch (error) {\n            console.error(\"Failed to fetch category:\", error);\n            return { success: false, error: \"Failed to fetch category\" };\n        }\n    }\n\n    // GETTING CATEGORY PROBLEMS\n    static async getCategoryProblems(\n        categoryId: string,\n        page: number = 1,\n        pageSize: number = 10,\n        userId?: string,\n        cursor?: string\n    ) {\n        try {\n            const cacheKey = cursor\n                ? `category:${categoryId}:problems:cursor:${cursor}`\n                : getCategoryProblemsCacheKey(categoryId, page);\n\n            // GETTING CACHE FOR CATEGORY PROBLEMS IF NOT CACHED\n            if (!userId || (page === 1 && !cursor)) {\n                const cached = await redis.get(cacheKey);\n                if (cached) {\n\n                    const parsed = JSON.parse(cached);\n                    // IF USER IS AUTHENTICATED, WE NEED TO CHECK SOLVED STATUS\n                    if (userId) {\n                        const problemIds = parsed.problems.map((p: any) => p.id);\n                        const solvedProblems = await prisma.submission.findMany({\n                            where: {\n                                userId,\n                                problemId: { in: problemIds },\n                                status: \"ACCEPTED\",\n                                mode: \"SUBMIT\"\n                            },\n                            select: { problemId: true },\n                            distinct: [\"problemId\"]\n                        });\n                        const solvedSet = new Set(solvedProblems.map(s => s.problemId));\n                        parsed.problems = parsed.problems.map((p: any) => ({\n                            ...p,\n                            isSolved: solvedSet.has(p.id)\n                        }));\n                    }\n                    return parsed;\n                }\n            }\n\n            const [categoryProblems, total] = await Promise.all([\n                prisma.categoryProblem.findMany({\n                    where: { categoryId },\n                    take: pageSize,\n                    orderBy: { order: \"asc\" },\n                    skip: cursor ? 1 : (page - 1) * pageSize,\n                    ...(cursor ? { cursor: { id: cursor } } : {}),\n                    include: {\n                        problem: {\n                            include: {\n                                _count: { select: { submissions: true } },\n                                ...(userId ? {\n                                    submissions: {\n                                        where: {\n                                            userId,\n                                            status: \"ACCEPTED\",\n                                            mode: \"SUBMIT\"\n                                        },\n                                        take: 1,\n                                        select: { id: true }\n                                    }\n                                } : {})\n                            }\n                        }\n                    }\n                }),\n                prisma.categoryProblem.count({ where: { categoryId } })\n            ]);\n\n            const problems = categoryProblems.map((cp) => {\n                const p = cp.problem;\n                const isSolved = (p as any).submissions?.length > 0;\n                return {\n                    ...p,\n                    isSolved,\n                    acceptance: p._count.submissions > 0\n                        ? ((p.solved || 0) / p._count.submissions) * 100\n                        : 0,\n                    submissions: undefined\n                };\n            });\n\n            const result = {\n                problems,\n                totalPages: Math.ceil(total / pageSize),\n                currentPage: page,\n                total\n            };\n\n            // Cache result (only for first page or cursor and non-authenticated)\n            if (!userId || (page === 1 && !cursor)) {\n                await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n            }\n\n            return result;\n        } catch (error) {\n            console.error(\"Failed to fetch category problems:\", error);\n            return { problems: [], totalPages: 0, currentPage: page, total: 0 };\n        }\n    }\n\n    // CREATING A CATEGORY\n    static async createCategory(data: {\n        name: string;\n        description?: string;\n        slug: string;\n        order?: number;\n        domain?: ProblemDomain;\n    }) {\n        try {\n            // CREATING THE CATEGORY\n\n            const category = await prisma.category.create({\n                data: {\n                    name: data.name,\n                    description: data.description,\n                    slug: data.slug,\n                    order: data.order ?? 0,\n                    domain: data.domain || \"DSA\"\n                }\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            // RETURNING THE SUCCESS AND THE CATEGORY\n            return { success: true, category: category };\n\n        } catch (error: any) {\n            console.error(\"Failed to create category:\", error);\n            return {\n                success: false,\n                error: error.code === \"P2002\" ? \"Slug already exists\" : \"Failed to create category\"\n            };\n        }\n    }\n\n    // UPDATING A CATEGORY\n    static async updateCategory(id: string, data: { name?: string; description?: string; slug?: string; order?: number; }) {\n        try {\n            const category = await prisma.category.update({\n                where: { id },\n                data\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            await redis.del(getCategoryCacheKey(category.slug));\n\n            return { success: true, category };\n        } catch (error) {\n            console.error(\"Failed to update category:\", error);\n            return { success: false, error: \"Failed to update category\" };\n        }\n    }\n\n    // DELETING A CATEGORY\n    static async deleteCategory(id: string) {\n        try {\n            const category = await prisma.category.findUnique({\n                where: { id },\n                select: { slug: true }\n            });\n\n            await prisma.category.delete({\n                where: { id }\n            });\n\n            // INVALIDATING THE CACHE\n\n            await redis.del(getCategoriesCacheKey());\n            // INVALIDATING THE CACHE FOR THE CATEGORY IF IT EXISTS\n            if (category) {\n                await redis.del(getCategoryCacheKey(category.slug));\n            }\n\n            return { success: true, slug: category?.slug };\n        } catch (error) {\n            console.error(\"Failed to delete category:\", error);\n            return { success: false, error: \"Failed to delete category\" };\n        }\n    }\n\n    // ADDING A PROBLEM TO A CATEGORY\n    static async addProblemToCategory(\n        categoryId: string,\n        problemId: string,\n        order?: number\n    ) {\n        try {\n            // GETTING THE CATEGORY TO GET ITS DOMAIN\n            const category = await prisma.category.findUnique({\n                where: { id: categoryId },\n                select: { domain: true, slug: true }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // UPDATING THE PROBLEM TO BE OF TYPE LEARN AND MATCH CATEGORY DOMAIN\n\n            await prisma.problem.update({\n                where: { id: problemId },\n                data: {\n                    type: \"LEARN\",\n                    domain: category.domain\n                }\n            });\n\n            // CREATING THE CATEGORY PROBLEM\n\n            const categoryProblem = await prisma.categoryProblem.create({\n                data: {\n                    categoryId,\n                    problemId,\n                    order: order ?? 0\n                },\n                include: {\n                    problem: true,\n                    category: true\n                }\n            });\n\n            // INVALIDATING THE CACHE FOR THE CATEGORY PROBLEMS\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n            await redis.del(getCategoryCacheKey(categoryProblem.category.slug));\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            return { success: true, categoryProblem };\n        } catch (error: any) {\n            console.error(\"Failed to add problem to category:\", error);\n            if (error.code === \"P2002\") {\n                return { success: false, error: \"Problem already in category\" };\n            }\n            return { success: false, error: \"Failed to add problem to category\" };\n        }\n    }\n\n    // REMOVING A PROBLEM FROM A CATEGORY\n    static async removeProblemFromCategory(\n        categoryId: string,\n        problemId: string\n    ) {\n        try {\n\n            // DELETING THE CATEGORY PROBLEM\n\n            await prisma.categoryProblem.delete({\n                where: {\n                    categoryId_problemId: {\n                        categoryId,\n                        problemId\n                    }\n                }\n            });\n\n            // INVALIDATING THE CACHE FOR THE CATEGORY PROBLEMS\n\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to remove problem from category:\", error);\n            return { success: false, error: \"Failed to remove problem from category\" };\n        }\n    }\n\n    // CREATING A PROBLEM AND ADDING IT TO A CATEGORY\n    static async createProblemAndAddToCategory(\n        categoryId: string,\n        data: {\n            title: string;\n            description: string;\n            difficulty: Difficulty;\n            slug: string;\n            hidden: boolean;\n            hiddenQuery?: string | null;\n            testCases?: { input: string; output: string; hidden?: boolean }[];\n        }\n    ) {\n        try {\n            // GETTING THE CATEGORY TO GET ITS DOMAIN\n            const category = await prisma.category.findUnique({\n                where: { id: categoryId },\n                select: { domain: true, slug: true }\n            });\n\n            if (!category) {\n                return { success: false, error: \"Category not found\" };\n            }\n\n            // CREATING THE PROBLEM AS TYPE LEARN WITH CATEGORY DOMAIN\n            const problem = await prisma.problem.create({\n                data: {\n                    title: data.title,\n                    description: data.description,\n                    difficulty: data.difficulty,\n                    slug: data.slug,\n                    score: data.difficulty === \"CONCEPT\" ? 0 : 10,\n                    hidden: data.hidden,\n                    hiddenQuery: data.hiddenQuery || null,\n                    type: \"LEARN\",\n                    domain: category.domain,\n                    testCases: {\n                        create: data.testCases?.map(tc => ({\n                            input: tc.input,\n                            output: tc.output,\n                            hidden: tc.hidden ?? false\n                        })) || []\n                    }\n                },\n            });\n\n            // ADDING THE PROBLEM TO THE CATEGORY\n            await prisma.categoryProblem.create({\n                data: {\n                    categoryId,\n                    problemId: problem.id,\n                    order: 0\n                }\n            });\n\n            // INVALIDATING THE CACHE\n            const cachePattern = `category:${categoryId}:problems:*`;\n            const keys = await redis.keys(cachePattern);\n            if (keys.length > 0) {\n                await redis.del(...keys);\n            }\n            await redis.del(getCategoryCacheKey(category.slug));\n            await redis.del(getCategoriesCacheKey(category.domain));\n\n            // INVALIDATING PROBLEM CACHES\n            const problemCachePattern = \"problems:*\";\n            const problemKeys = await redis.keys(problemCachePattern);\n            if (problemKeys.length > 0) {\n                await redis.del(...problemKeys);\n            }\n\n            return { success: true, problem };\n        } catch (error: any) {\n            console.error(\"Failed to create problem and add to category:\", error);\n            if (error.code === \"P2002\") {\n                return { success: false, error: \"Problem slug already exists\" };\n            }\n            return { success: false, error: error.message || \"Failed to create problem and add to category\" };\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5472, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/category.action.ts"],"sourcesContent":["\"use server\";\n\nimport { CategoryService } from \"@/core/services/category.service\";\nimport { ProblemDomain, Difficulty } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING ALL CATEGORIES\n\nexport async function getCategories(domain: ProblemDomain = \"DSA\") {\n  \"use cache: private\"; // Must be at top - allows headers() inside\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const userId = session?.user?.id;\n\n  cacheTag(`categories-${domain}${userId ? `-user-${userId}` : ''}`, 'categories-list');\n\n  return CategoryService.getCategories(domain, userId);\n}\n\n// GETTING A CATEGORY BY SLUG\n\nexport async function getCategory(slug: string) {\n  \"use cache\";\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  cacheTag(`category-${slug}`, 'categories-list');\n\n  return CategoryService.getCategoryBySlug(slug);\n}\n\n// GETTING A CATEGORY BY ID --> NO CACHING\n\nexport async function getCategoryById(id: string) {\n  return CategoryService.getCategoryById(id);\n}\n\n// GETTING CATEGORY PROBLEMS\n\nexport async function getCategoryProblems(\n  categoryId: string,\n  page: number = 1,\n  pageSize: number = 10,\n  cursor?: string\n) {\n  \"use cache: private\"; // Must be at top - allows headers() inside\n  cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const userId = session?.user?.id;\n\n  const tagKey = `category-problems-${categoryId}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n  cacheTag(tagKey, `category-${categoryId}`, 'categories-list');\n\n  return CategoryService.getCategoryProblems(categoryId, page, pageSize, userId, cursor);\n}\n\n\n// CREATING A CATEGORY --> ADMIN ONLY\n\nexport async function createCategory(data: {\n  name: string;\n  description?: string;\n  slug: string;\n  order?: number;\n  domain?: ProblemDomain;\n}) {\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.createCategory(data);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n  }\n\n  return result;\n}\n\n// UPDATING A CATEGORY --> ADMIN ONLY\n\nexport async function updateCategory(id: string, data: { name?: string; description?: string; slug?: string; order?: number; }) {\n\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.updateCategory(id, data);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS --> PROBLEMS AND ADMIN CATEGORIES\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n    if (data.slug) {\n      updateTag(`category-${data.slug}`);\n    }\n  }\n\n  return result;\n}\n\n// DELETING A CATEGORY --> ADMIN ONLY\n\nexport async function deleteCategory(id: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.deleteCategory(id);\n\n  if (result.success) {\n    // REVALIDATING THE PATHS --> PROBLEMS AND ADMIN CATEGORIES\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(\"/admin/categories\");\n    updateTag('categories-list');\n    if (result.slug) {\n      updateTag(`category-${result.slug}`);\n    }\n  }\n\n  return result;\n}\n\n\n// ADDING A PROBLEM TO A CATEGORY --> ADMIN ONLY\n\nexport async function addProblemToCategory(\n  categoryId: string,\n  problemId: string,\n  order?: number\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.addProblemToCategory(categoryId, problemId, order);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n    revalidatePath(`/admin/dsa/categories/${categoryId}`);\n    revalidatePath(`/admin/sql/categories/${categoryId}`);\n    updateTag(`category-${categoryId}`);\n    updateTag('categories-list');\n  }\n\n  return result;\n}\n\n\n// REMOVING A PROBLEM FROM A CATEGORY --> ADMIN ONLY\n\nexport async function removeProblemFromCategory(\n  categoryId: string,\n  problemId: string\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.removeProblemFromCategory(categoryId, problemId);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n  }\n\n  return result;\n}\n\n// CREATING A PROBLEM AND ADDING IT TO A CATEGORY --> ADMIN ONLY\n\nexport async function createProblemAndAddToCategory(\n  categoryId: string,\n  data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    testCases?: { input: string; output: string; hidden?: boolean }[];\n  }\n) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n\n  if (!session || session.user.role !== \"ADMIN\") {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const result = await CategoryService.createProblemAndAddToCategory(categoryId, data);\n\n  if (result.success) {\n    revalidatePath(\"/problems/dsa\");\n    revalidatePath(\"/problems/sql\");\n    revalidatePath(`/admin/categories/${categoryId}`);\n    revalidatePath(`/admin/dsa/categories/${categoryId}`);\n    revalidatePath(`/admin/sql/categories/${categoryId}`);\n    revalidatePath(\"/admin/problems\");\n    revalidatePath(\"/admin/dsa/problems\");\n    revalidatePath(\"/admin/sql/problems\");\n  }\n\n  return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5712, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28workspace%29/problems/%5Bslug%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {$$RSC_SERVER_CACHE_0 as 'c022638cd1b7725d97d4bfa30584aaa4676ba6a139'} from 'ACTIONS_MODULE1'\nexport {deleteProblem as '40d9f7e192f4cde9508f832f98d501a5d2bac3b26b'} from 'ACTIONS_MODULE2'\nexport {createProblem as '40dd2241aa639228d5754da39ff0b8d10a59d75bff'} from 'ACTIONS_MODULE2'\nexport {updateProblem as '6094ec6e5c7d68eabf2ee86ceb1e87755d9fd33b01'} from 'ACTIONS_MODULE2'\nexport {getRandomProblem as '60ee1ae949348cbb95c6ff1624db0e0167a061c945'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_3 as 'c01897e0e33720eec5643ef69ddae234356fd82300'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_4 as 'c05c8fadea7603e1a1f64c8b4dcbe007d8d4fb2c3a'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_2 as 'f0b5bb641795686f7cca1e438a6e0566d735ffcd4e'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_6 as 'f0e393a839ccab97fcb8522876156c6ba741ba3074'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_5 as 'f0eb7ece396ebe935b968e8abfe06e00d6920108af'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_1 as 'fc03c238e4639461fed11dd40d3ecd9287bcb20773'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_0 as 'ff85edbb114d3f01c639e45db77828c9d874750fd9'} from 'ACTIONS_MODULE2'\nexport {getVisibleContests as '00eefbb253a85123f8c3c600ca19869a5101d8c0d1'} from 'ACTIONS_MODULE3'\nexport {getInstitutionalClassrooms as '40224e3fe672716e149c2c2793410ece7e7ff96034'} from 'ACTIONS_MODULE3'\nexport {getParticipationStatus as '4041a53321b8a41efa0515551dc3e636f81f59f7d7'} from 'ACTIONS_MODULE3'\nexport {acceptContestRules as '407bfdebdef8125e9da675e434ddabed8c0d83ff51'} from 'ACTIONS_MODULE3'\nexport {createContestWithProblems as '407d6b79375f2016b6861524ddee55c2e99ceb5e5b'} from 'ACTIONS_MODULE3'\nexport {createContest as '407ff7fc9ba70fda023756de206f185bb7683b86bd'} from 'ACTIONS_MODULE3'\nexport {getContestDetail as '409d0a0373926b8940e890b689a1cac3144677e167'} from 'ACTIONS_MODULE3'\nexport {getSelectableProblems as '409f563bec9a985442cff8b7b83d7546b8276a02e1'} from 'ACTIONS_MODULE3'\nexport {finalizeContest as '40a47fbc0ae4e927cabd5fae0ee2325db6de07014c'} from 'ACTIONS_MODULE3'\nexport {finishContestAction as '40cb9402bcb3cefb68c56b22e13de3a9f637bd31ab'} from 'ACTIONS_MODULE3'\nexport {getContestRanking as '40edfea29c94aa36a1a52aa93c92827398e407c1c2'} from 'ACTIONS_MODULE3'\nexport {checkSubmissionEligibility as '40f7fe5a39b9ff511e9db90ca5a169ae86d7660b65'} from 'ACTIONS_MODULE3'\nexport {getContestParticipants as '40fcf50c7b1ee991289ef809f621af905c86ec6963'} from 'ACTIONS_MODULE3'\nexport {validateContestSession as '602cf4435ac48b07adb33a52140ca1f4538d93b7d6'} from 'ACTIONS_MODULE3'\nexport {verifyContestPassword as '604a0bcc1451e81e233f48280ac746b33b2aa18f12'} from 'ACTIONS_MODULE3'\nexport {getParticipantViolations as '607d884db8652712b1888554802e08210ff48e297a'} from 'ACTIONS_MODULE3'\nexport {unblockParticipant as '60995be1625901022cd2485061fb5f529d27001da0'} from 'ACTIONS_MODULE3'\nexport {startContestSession as '60ab32f1cc26748b4afce6a433ca3e6dc394836698'} from 'ACTIONS_MODULE3'\nexport {logContestViolation as '78bac990ae89cd8ae87b5bbd328ef9aee3e1937b8f'} from 'ACTIONS_MODULE3'\nexport {$$RSC_SERVER_CACHE_0 as '803cf50d552ccc152ed46f078e0fb03c1767a05eb9'} from 'ACTIONS_MODULE3'\nexport {$$RSC_SERVER_CACHE_1 as 'c00d8131bc66d78bc8131eec8f6d3c30fe0c4f51bb'} from 'ACTIONS_MODULE3'\nexport {$$RSC_SERVER_CACHE_2 as 'c08c3a89f87d0fda2e2465be36519f53224c7bbfb3'} from 'ACTIONS_MODULE3'\nexport {markConceptAsCompleted as '40a37009f3d89fa942e11725f8853c3d127638cb39'} from 'ACTIONS_MODULE4'\nexport {getParticipationStatus as '4041a53321b8a41efa0515551dc3e636f81f59f7d7'} from 'ACTIONS_MODULE3'\nexport {getRandomProblem as '60ee1ae949348cbb95c6ff1624db0e0167a061c945'} from 'ACTIONS_MODULE2'\nexport {logContestViolation as '78bac990ae89cd8ae87b5bbd328ef9aee3e1937b8f'} from 'ACTIONS_MODULE3'\nexport {finishContestAction as '40cb9402bcb3cefb68c56b22e13de3a9f637bd31ab'} from 'ACTIONS_MODULE3'\nexport {getProblemComments as '6044ed3755352d7fd254632d39462abd6795a1aba3'} from 'ACTIONS_MODULE5'\nexport {getProblemStats as '7047c436e22e056715bf68b1900859a27784c3ce69'} from 'ACTIONS_MODULE6'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE7'\nexport {voteComment as '707d926e4a11493fbc786e4dafc801cd9fea5119a5'} from 'ACTIONS_MODULE5'\nexport {pinComment as '60af00e80ae9125d962d6768a3c5e918095efad8c2'} from 'ACTIONS_MODULE5'\nexport {deleteComment as '60b9c01d983b07f0a2a8b264f93f4f77235a94ded3'} from 'ACTIONS_MODULE5'\nexport {postComment as '708aa5eaf1ed268262e98ff2f597d9df9f5c649439'} from 'ACTIONS_MODULE5'\nexport {getSubmission as '40f3732208c79da0b2b65a5118279fb4de68977ef7'} from 'ACTIONS_MODULE4'\nexport {getProblemSubmissionsAction as 'f043464bd06d6501259988d6e64f4460c054895b9b'} from 'ACTIONS_MODULE4'\nexport {getProblems as 'ffb6064b0a0a619152cef9d1130640ca662759362c'} from 'ACTIONS_MODULE2'\nexport {searchProblems as 'f01f5ef9ed6223b56ddc1153abce0acfbc57475009'} from 'ACTIONS_MODULE2'\nexport {getCategories as 'c0c61a0961c7e53f3af018ebf0d1ccd5c094778117'} from 'ACTIONS_MODULE8'\nexport {getCategoryProblems as 'f83292b4960e88e737718c29cfe55ecaedb6ed3165'} from 'ACTIONS_MODULE8'\n"],"names":[],"mappings":";AAAA;AAEA;AACA;AAWA;AAsBA;AAKA;AACA;AACA;AASA"}}]
}