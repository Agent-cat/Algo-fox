{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/platform.action.ts"],"sourcesContent":["\"use server\";\n\nimport { JSDOM } from \"jsdom\";\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { headers } from \"next/headers\";\n\nexport async function checkCodeChefUser(handle: string, ignoreCache = false) {\n    try {\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } }; // Cache for 1 hour\n\n        const resdata = await fetch(\n            `https://www.codechef.com/users/${handle}`,\n            fetchOptions\n        );\n\n        if (resdata.status == 200) {\n\n            let d = await resdata.text();\n            let data = { data: d };\n\n            // Heatmap data extraction\n            let heatMapDataCursour1 =\n                data.data.search(\"var userDailySubmissionsStats =\") +\n                \"var userDailySubmissionsStats =\".length;\n            let heatMapDataCursour2 = data.data.search(\"'#js-heatmap\") - 34;\n            let heatDataString = data.data.substring(\n                heatMapDataCursour1,\n                heatMapDataCursour2\n            );\n\n            let headMapData = null;\n            try {\n                 headMapData = JSON.parse(heatDataString);\n            } catch (e) {\n                console.log(\"Error parsing heatmap data\", e);\n            }\n\n            // Rating data extraction\n            let allRating =\n                data.data.search(\"var all_rating = \") + \"var all_rating = \".length;\n            let allRating2 = data.data.search(\"var current_user_rating =\") - 6;\n\n            let ratingData = null;\n            try {\n                 ratingData = JSON.parse(data.data.substring(allRating, allRating2));\n            } catch (e) {\n                console.log(\"Error parsing rating data\", e);\n            }\n\n            let dom = new JSDOM(data.data);\n            let document = dom.window.document;\n\n            const name = document.querySelector(\".user-details-container\")?.children[0]\n                ?.children[1]?.textContent || \"\";\n\n            // Safe extraction with optional chaining\n            const profile = document.querySelector(\".user-details-container\")?.children[0]\n                ?.children[0]?.getAttribute(\"src\") || \"\";\n\n            const currentRatingText = document.querySelector(\".rating-number\")?.textContent;\n            const currentRating = currentRatingText ? parseInt(currentRatingText) : 0;\n\n            const highestRatingText = document.querySelector(\".rating-number\")?.parentNode?.children[4]?.textContent?.split(\"Rating\")[1];\n            const highestRating = highestRatingText ? parseInt(highestRatingText) : 0;\n\n            const countryFlag = document.querySelector(\".user-country-flag\")?.getAttribute(\"src\") || \"\";\n            const countryName = document.querySelector(\".user-country-name\")?.textContent || \"\";\n\n            const globalRankText = document.querySelector(\".rating-ranks\")?.children[0]?.children[0]\n                ?.children[0]?.children[0]?.innerHTML;\n            const globalRank = globalRankText ? parseInt(globalRankText) : 0;\n\n            const countryRankText = document.querySelector(\".rating-ranks\")?.children[0]?.children[1]\n                ?.children[0]?.children[0]?.innerHTML;\n            const countryRank = countryRankText ? parseInt(countryRankText) : 0;\n\n            const stars = document.querySelector(\".rating\")?.textContent || \"unrated\";\n\n            // Extract Fully Solved Count\n            let fullySolvedCount = 0;\n            const h5Elements = document.querySelectorAll(\"h5\");\n            for (const h5 of h5Elements) {\n                if (h5.textContent?.includes(\"Fully Solved\")) {\n                    const match = h5.textContent.match(/\\d+/);\n                    if (match) {\n                        fullySolvedCount = parseInt(match[0]);\n                    }\n                    break;\n                }\n            }\n\n            return {\n                success: true,\n                status: resdata.status,\n                profile,\n                name,\n                currentRating,\n                highestRating,\n                countryFlag,\n                countryName,\n                globalRank,\n                countryRank,\n                stars,\n                heatMap: headMapData,\n                ratingData,\n                fullySolvedCount\n            };\n        }\n        else {\n            return { success: false, status: resdata.status }\n        }\n    } catch (e) {\n        console.log(e)\n        return { success: false, status: 404 }\n    }\n}\n\nexport async function verifyCodeChefOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    // Bypass cache for verification\n    const result = await checkCodeChefUser(handle, true);\n\n    if (result.success && result.name) {\n        // Check if the verification code is present in the name\n        // The user edits their \"Name\" field to include the code\n        if (result.name.includes(verificationCode)) {\n             try {\n                await prisma.user.update({\n                    where: { id: session.user.id },\n                    data: {\n                        codeChefVerified: true,\n                        // Ensure the verified handle is the one stored\n                        codeChefHandle: handle\n                    }\n                });\n                revalidatePath(\"/dashboard/settings\"); // Revalidate settings pages\n                revalidateTag(`user-${session.user.id}`,\"max\"); // Invalidate user cache tag\n                return { success: true };\n            } catch (error) {\n                console.error(\"Database update error:\", error);\n                return { success: false, error: \"Failed to update verification status\" };\n            }\n        } else {\n             return { success: false, error: \"Verification code not found in CodeChef name. Please ensure you have updated your profile name.\" };\n        }\n    }\n\n    return { success: false, error: \"Failed to fetch CodeChef profile\" };\n}\n// ... (existing imports and functions)\n\nexport async function checkCodeforcesUser(handle: string, ignoreCache = false) {\n    try {\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } };\n\n        const [userInfoRes, userStatusRes] = await Promise.all([\n            fetch(`https://codeforces.com/api/user.info?handles=${handle}`, fetchOptions),\n            fetch(`https://codeforces.com/api/user.status?handle=${handle}`, fetchOptions)\n        ]);\n\n        if (userInfoRes.ok && userStatusRes.ok) {\n            const userData = await userInfoRes.json();\n            const statusData = await userStatusRes.json();\n\n            if (userData.status === \"OK\" && userData.result.length > 0) {\n                const user = userData.result[0];\n\n                // Calculate solved count and difficulty breakdown\n                const uniqueSolved = new Set<string>();\n                const solvedByDifficulty = {\n                    EASY: 0,\n                    MEDIUM: 0,\n                    HARD: 0,\n                    TOTAL: 0\n                };\n\n                if (statusData.status === \"OK\") {\n                    for (const submission of statusData.result) {\n                        if (submission.verdict === \"OK\") {\n                            const problemId = `${submission.problem.contestId}-${submission.problem.index}`;\n                            if (!uniqueSolved.has(problemId)) {\n                                uniqueSolved.add(problemId);\n                                const rating = submission.problem.rating;\n                                if (rating) {\n                                    if (rating < 1200) solvedByDifficulty.EASY++;\n                                    else if (rating < 1600) solvedByDifficulty.MEDIUM++; // Adjusted thresholds\n                                    else solvedByDifficulty.HARD++;\n                                } else {\n                                    // Treat unrated as easy or ignore? Let's add to Easy for now or just Total\n                                    // solvedByDifficulty.EASY++;\n                                }\n                            }\n                        }\n                    }\n                    solvedByDifficulty.TOTAL = uniqueSolved.size;\n                }\n\n                return {\n                    success: true,\n                    status: 200,\n                    firstName: user.firstName,\n                    // Check other fields if needed for existence or display\n                    rating: user.rating,\n                    rank: user.rank,\n                    maxRating: user.maxRating,\n                    maxRank: user.maxRank,\n                    avatar: user.titlePhoto || user.avatar,\n                    solvedByDifficulty\n                };\n            }\n        }\n        return { success: false, status: userInfoRes.status };\n    } catch (e) {\n        console.error(e);\n        return { success: false, status: 500 };\n    }\n}\n\nexport async function verifyCodeforcesOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    // Bypass cache for verification\n    const result = await checkCodeforcesUser(handle, true);\n\n    if (result.success) {\n        // Check if the verification code is present in the first name\n        // Codeforces allows changing First Name in settings\n        if (result.firstName && result.firstName.includes(verificationCode)) {\n             try {\n                await prisma.user.update({\n                    where: { id: session.user.id },\n                    data: {\n                        codeforcesVerified: true,\n                        // Ensure the verified handle is the one stored\n                        codeforcesHandle: handle\n                    }\n                });\n                revalidatePath(\"/dashboard/settings\"); // Revalidate settings pages\n                revalidateTag(`user-${session.user.id}`,\"max\"); // Invalidate user cache tag\n                return { success: true };\n            } catch (error) {\n                console.error(\"Database update error:\", error);\n                return { success: false, error: \"Failed to update verification status\" };\n            }\n        } else {\n             return { success: false, error: \"Verification code not found in Codeforces First Name. Please ensure you have updated it in your profile settings.\" };\n        }\n    }\n\n    return { success: false, error: \"Failed to fetch Codeforces profile\" };\n}\n\n// Check LeetCode User\nexport async function checkLeetCodeUser(handle: string, ignoreCache = false) {\n    // LeetCode library doesn't expose easy fetch options for caching,\n    // but the contest fetch we added uses fetch().\n    // We can't easily cache the library call 'leetcode.user(handle)' unless we wrap it or if it caches internally.\n    // However, for the graphql fetch we CAN control cache.\n\n    try {\n        const { LeetCode } = await import(\"leetcode-query\");\n        const leetcode = new LeetCode();\n        // This part is using the library, hard to optimize without forking/replacing library usage.\n        // Assuming library does standard fetch, maybe we can't touch it easily.\n        // But for the contest part:\n        const user = await leetcode.user(handle);\n\n        // Fetch Contest Data manually via GraphQL\n        const contestQuery = `\n            query userContestRankingInfo($username: String!) {\n                userContestRanking(username: $username) {\n                    attendedContestsCount\n                    rating\n                    globalRanking\n                    topPercentage\n                    badge {\n                        name\n                    }\n                }\n                userContestRankingHistory(username: $username) {\n                    attended\n                    rating\n                    contest {\n                        title\n                        startTime\n                    }\n                }\n            }\n        `;\n\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } };\n\n        const contestRes = await fetch('https://leetcode.com/graphql', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Referer': 'https://leetcode.com'\n            },\n            body: JSON.stringify({\n                query: contestQuery,\n                variables: { username: handle }\n            }),\n            ...fetchOptions\n        });\n\n        const contestData = await contestRes.json();\n        const contestStats = contestData.data?.userContestRanking;\n        const contestHistory = contestData.data?.userContestRankingHistory?.filter((c: any) => c.attended);\n\n\n        if (user && user.matchedUser) {\n            return {\n                success: true,\n                status: 200,\n                name: user.matchedUser.profile.realName,\n                avatar: user.matchedUser.profile.userAvatar,\n                submitStats: user.matchedUser.submitStats,\n                contestStats: contestStats || null,\n                contestHistory: contestHistory || []\n            };\n        }\n        return { success: false, status: 404 };\n    } catch (e) {\n        console.error(\"LeetCode check error:\", e);\n        return { success: false, status: 500 };\n    }\n}\n\n// Verify LeetCode Ownership\nexport async function verifyLeetCodeOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Bypass cache\n        const result = await checkLeetCodeUser(handle, true);\n\n        if (result.success && result.name) {\n            // Check if verification code is in the name\n            if (result.name.includes(verificationCode)) {\n                try {\n                    await prisma.user.update({\n                        where: { id: session.user.id },\n                        data: {\n                            leetCodeVerified: true,\n                            leetCodeHandle: handle\n                        }\n                    });\n                    revalidatePath(\"/dashboard/settings\");\n                    revalidateTag(`user-${session.user.id}`,\"max\");\n                    return { success: true };\n                } catch (error) {\n                    console.error(\"Database update error:\", error);\n                    return { success: false, error: \"Failed to update verification status\" };\n                }\n            } else {\n                return { success: false, error: \"Verification code not found in LeetCode Name. Please ensure you have updated it in your profile.\" };\n            }\n        }\n    } catch (error) {\n         return { success: false, error: \"Failed to verify LeetCode profile\" };\n    }\n\n    return { success: false, error: \"Failed to fetch LeetCode profile or name is empty\" };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1091, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28main%29/dashboard/settings/platform/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE1'\nexport {updateUserInfo as '40dcf2b262cc87e0478a9f114239bdf2ac94b94b3c'} from 'ACTIONS_MODULE1'\nexport {checkCodeChefUser as '60497d1d82268f0126da46c6573d5de6f13ad2101a'} from 'ACTIONS_MODULE2'\nexport {checkCodeforcesUser as '608e4143fe9ddd7a52705074750d983c1ea8affb8f'} from 'ACTIONS_MODULE2'\nexport {checkLeetCodeUser as '60d44136a03ab3229f6d1299e2144e1828f063d7fd'} from 'ACTIONS_MODULE2'\nexport {verifyCodeChefOwnership as '601860f7af2208a291b9702f83b87c820127ee9592'} from 'ACTIONS_MODULE2'\nexport {verifyCodeforcesOwnership as '60c49734ef59284f868866483aaa4df8292525eeb8'} from 'ACTIONS_MODULE2'\nexport {verifyLeetCodeOwnership as '60b7ea2f21e7c7ff45aa305f594b146b6998521bf6'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AAEA;AAEA"}}]
}