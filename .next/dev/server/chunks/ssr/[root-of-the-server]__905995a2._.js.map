{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOO,MAAA,6BAAA,eAAe;IAElB,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI,IAAI,YAAY;IAExD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAA,yIAAQ,EAAC,CAAC,WAAW,EAAE,QAAQ,EAAE,CAAC,KAAK,EAAE,QAAQ;IAEjD,OAAO,kJAAW,CAAC,YAAY,CAAC;AACpC;IAjBO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAuBf,eAAe;IAClB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,OAAO,kJAAW,CAAC,oBAAoB,CAAC;AAC5C;AAMO,eAAe,mBAAmB,IASxC;IACG,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,MAAM,MAAM,MAAM,kJAAW,CAAC,kBAAkB,CAAC,QAAQ;IAEzD,IAAI,IAAI,OAAO,EAAE;QACb,+DAA+D;QAC/D,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;QAC/C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+CAA+C;QACjE;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,UAAU,EAAE,QAAQ;QAC/B,IAAA,0IAAS,EAAC;IACd;IAEA,OAAO;AACX;AAKO,eAAe,eAAe,IAQpC;IACG,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAI;QACA,0CAA0C;QAC1C,MAAM,cAAc,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBACJ,gBAAgB;gBAChB,kBAAkB;gBAClB,gBAAgB;YACpB;QACJ;QAEA,MAAM,aAAkB;YACpB,MAAM,KAAK,IAAI;YACf,KAAK,KAAK,GAAG;YACb,gBAAgB,KAAK,cAAc;YACnC,gBAAgB,KAAK,cAAc;YACnC,kBAAkB,KAAK,gBAAgB;YACvC,cAAc,KAAK,YAAY;QACnC;QAEA,uCAAuC;QACvC,IAAI,aAAa;YACb,IAAI,KAAK,cAAc,KAAK,aAAa,KAAK,cAAc,KAAK,YAAY,cAAc,EAAE;gBACzF,WAAW,gBAAgB,GAAG;YAClC;YACA,IAAI,KAAK,gBAAgB,KAAK,aAAa,KAAK,gBAAgB,KAAK,YAAY,gBAAgB,EAAE;gBAC/F,WAAW,kBAAkB,GAAG;YACpC;YACA,IAAI,KAAK,cAAc,KAAK,aAAa,KAAK,cAAc,KAAK,YAAY,cAAc,EAAE;gBACzF,WAAW,gBAAgB,GAAG;YAClC;QACJ;QAEA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;QACV;QAEA,yBAAyB;QACzB,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;QAC/C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+CAA+C;QACjE;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC,wBAAwB,iCAAiC;QACxE,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,WAAW,EAAE,QAAQ;QAChC,IAAA,0IAAS,EAAC,CAAC,UAAU,EAAE,QAAQ;QAC/B,IAAA,0IAAS,EAAC;QACV,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAMO,eAAe;IAClB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAI;QACA,yBAAyB;QACzB,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC3C,MAAM,MAAM,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;QAC1C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,iDAAiD;QACnE;QAEA,2BAA2B;QAC3B,IAAA,+IAAc,EAAC;QACf,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,WAAW,EAAE,QAAQ;QAChC,IAAA,0IAAS,EAAC;QAEV,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyB;IAC7D;AACJ;AAKO,MAAA,6BAAA,eAAe;IAElB,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI;IAExC,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAC9B,IAAA,yIAAQ,EAAC,CAAC,KAAK,EAAE,QAAQ;IAEzB,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;QACpB,SAAS;YACL,aAAa;QACjB;IACJ;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,OAAO;QACH,IAAI,KAAK,EAAE;QACX,MAAM,KAAK,IAAI;QACf,OAAO,KAAK,KAAK;QACjB,OAAO,KAAK,KAAK;QACjB,KAAK,KAAK,GAAG;QACb,iBAAiB,KAAK,WAAW,EAAE;IACvC;AACJ;IAhCO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;;;IApLA;IAkBA;IA2CA;IAkFA;;AA/IA,+OAAA;AAkBA,+OAAA;AA2CA,+OAAA;AAkFA,+OAAA"}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/dashboard.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport redis from \"@/lib/redis\";\n\nexport class DashboardService {\n    // GETTING DASHBOARD STATS\n    static async getDashboardStats(userId: string) {\n\n        const cacheKey = `dashboard:stats:${userId}`;\n        const CACHE_TTL = 5 * 60; // 5 minutes\n\n        try {\n            // GETTING CACHE FROM REDIS\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n                // RETURNING THE CACHE IF CACHED\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            // REDIS ERROR --> CONTINUE WITHOUT CACHE\n            console.error('Redis get error:', error);\n        }\n\n        // FETCHING USER DATA (LITE)\n        // We still fetch the user and their *recent* submissions (e.g. last 5) for the UI Activity Feed\n        // But we do NOT fetch ALL submissions for stats calculation anymore.\n\n        const userPromise = prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                id: true,\n                name: true,\n                email: true,\n                image: true,\n                role: true,\n                institution: {\n                    select: {\n                        name: true\n                    }\n                },\n                problemsSolved: true,\n                totalScore: true,\n                bio: true,\n                goldBadges: true,\n                silverBadges: true,\n                bronzeBadges: true,\n                leetCodeHandle: true,\n                leetCodeVerified: true,\n                codeChefHandle: true,\n                codeChefVerified: true,\n                codeforcesHandle: true,\n                codeforcesVerified: true,\n                githubHandle: true,\n                submissions: {\n                    where: { mode: \"SUBMIT\" },\n                    select: {\n                        id: true,\n                        createdAt: true,\n                        status: true,\n                        code: true,\n                        language: { select: { name: true } },\n                        problem: {\n                            select: {\n                                id: true,\n                                difficulty: true,\n                                slug: true,\n                                title: true\n                            }\n                        },\n                    },\n                    orderBy: { createdAt: 'desc' },\n                    take: 20 // Recent activity only\n                }\n            }\n        });\n\n        // --- OPTIMIZED RAW QUERIES ---\n\n        // 1. SOLVED BY DIFFICULTY\n        const difficultyStatsPromise = prisma.$queryRaw<any[]>`\n            SELECT\n                p.\"difficulty\",\n                CAST(COUNT(DISTINCT s.\"problemId\") AS INTEGER) as \"count\"\n            FROM \"Submission\" s\n            JOIN \"Problem\" p ON s.\"problemId\" = p.\"id\"\n            WHERE s.\"userId\" = ${userId}\n              AND s.\"status\" = 'ACCEPTED'::\"SubmissionResult\"\n              AND s.\"mode\" = 'SUBMIT'::\"SubmissionMode\"\n              AND p.\"difficulty\" != 'CONCEPT'::\"Difficulty\"\n            GROUP BY p.\"difficulty\"\n        `;\n\n        // 2. LANGUAGE COUNTS\n        const languageStatsPromise = prisma.$queryRaw<any[]>`\n            SELECT\n                l.\"name\",\n                CAST(COUNT(DISTINCT s.\"problemId\") AS INTEGER) as \"count\"\n            FROM \"Submission\" s\n            JOIN \"Language\" l ON s.\"languageId\" = l.\"id\"\n            JOIN \"Problem\" p ON s.\"problemId\" = p.\"id\"\n            WHERE s.\"userId\" = ${userId}\n              AND s.\"status\" = 'ACCEPTED'::\"SubmissionResult\"\n              AND s.\"mode\" = 'SUBMIT'::\"SubmissionMode\"\n              AND p.\"difficulty\" != 'CONCEPT'::\"Difficulty\"\n            GROUP BY l.\"name\"\n        `;\n\n        // 3. ACTIVITY DATES (For Streaks)\n        // We only need the dates, sorted.\n        const activityDatesPromise = prisma.$queryRaw<{ date: Date }[]>`\n            SELECT DISTINCT\n                DATE(s.\"createdAt\") as \"date\"\n            FROM \"Submission\" s\n            JOIN \"Problem\" p ON s.\"problemId\" = p.\"id\"\n            WHERE s.\"userId\" = ${userId}\n              AND s.\"status\" = 'ACCEPTED'::\"SubmissionResult\"\n              AND s.\"mode\" = 'SUBMIT'::\"SubmissionMode\"\n              AND p.\"difficulty\" != 'CONCEPT'::\"Difficulty\"\n            ORDER BY \"date\" ASC\n        `;\n\n        // 4. TOTAL PROBLEMS COUNT (METADATA)\n        const totalByDifficultyPromise = prisma.problem.groupBy({\n            by: ['difficulty'],\n            where: {\n                hidden: false,\n                difficulty: { not: 'CONCEPT' }\n            },\n            _count: { id: true }\n        });\n\n        const [user, difficultyStats, languageStats, activityDates, totalByDifficulty] = await Promise.all([\n            userPromise,\n            difficultyStatsPromise,\n            languageStatsPromise,\n            activityDatesPromise,\n            totalByDifficultyPromise\n        ]);\n\n        if (!user) {\n            return null;\n        }\n\n        // --- PROCESS DATA ---\n\n        // SOLVED BY DIFFICULTY\n        const solvedByDifficulty = { EASY: 0, MEDIUM: 0, HARD: 0 };\n        difficultyStats.forEach((row: any) => {\n            if (row.difficulty in solvedByDifficulty) {\n                solvedByDifficulty[row.difficulty as keyof typeof solvedByDifficulty] = row.count;\n            }\n        });\n\n        // TOTAL PROBLEMS\n        const totalProblems = { EASY: 0, MEDIUM: 0, HARD: 0, TOTAL: 0 };\n        totalByDifficulty.forEach(group => {\n            const count = group._count.id;\n            if (group.difficulty in totalProblems) {\n                totalProblems[group.difficulty as keyof typeof totalProblems] = count;\n            }\n            totalProblems.TOTAL += count;\n        });\n\n        // LANGUAGE COUNTS\n        const languageCounts: Record<string, number> = {};\n        languageStats.forEach((row: any) => {\n            const langName = row.name;\n            let normalizedName = langName;\n            if (langName.toLowerCase().includes('cpp') || langName.toLowerCase().includes('c++')) normalizedName = 'Cpp';\n            else if (langName.toLowerCase().includes('java')) normalizedName = 'Java';\n            else if (langName.toLowerCase().includes('javascript')) normalizedName = 'JavaScript';\n\n            if (!languageCounts[normalizedName]) languageCounts[normalizedName] = 0;\n            languageCounts[normalizedName] += row.count;\n        });\n\n        // STREAKS CALCULATION\n        let currentStreak = 0;\n        let bestStreak = 0;\n\n        // activityDates is array of { date: Date }\n        if (activityDates.length > 0) {\n            const sortedDates = activityDates.map(d => new Date(d.date));\n\n            // BEST STREAK\n            let streak = 1;\n            bestStreak = 1;\n            for (let i = 1; i < sortedDates.length; i++) {\n                // Check diff in days\n                const diffTime = Math.abs(sortedDates[i].getTime() - sortedDates[i - 1].getTime());\n                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\n                // Note: With DATE() cast, time is 00:00:00. consecutive days have diffDays = 1.\n                // However, timezone issues might make 'date' string parsing tricky.\n                // Prisma returns Date object.\n\n                if (diffDays === 1) {\n                    streak++;\n                    bestStreak = Math.max(bestStreak, streak);\n                } else if (diffDays > 1) {\n                    streak = 1;\n                }\n                // if diffDays == 0 (same day), ignore\n            }\n\n            // CURRENT STREAK\n            // Check if last activity was today or yesterday\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const lastActivity = sortedDates[sortedDates.length - 1];\n            const lastActivityTime = new Date(lastActivity);\n            lastActivityTime.setHours(0, 0, 0, 0);\n\n            const diffToLast = (today.getTime() - lastActivityTime.getTime()) / (1000 * 60 * 60 * 24);\n\n            if (diffToLast <= 1) {\n                // Users is active today or yesterday -> streak is alive.\n                // Re-calculate strictly from end\n                currentStreak = 1;\n                for (let i = sortedDates.length - 1; i > 0; i--) {\n                    const curr = sortedDates[i];\n                    const prev = sortedDates[i - 1];\n                    const diff = (curr.getTime() - prev.getTime()) / (1000 * 60 * 60 * 24);\n                    if (diff <= 1) { // 1 day or 0 (same day, though distinct query handles that)\n                        if (diff === 1) currentStreak++;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                currentStreak = 0;\n            }\n        }\n\n        const result = {\n            ...user,\n            solvedByDifficulty,\n            totalProblems,\n            languageCounts,\n            currentStreak,\n            bestStreak: Math.max(bestStreak, currentStreak) // simple fallback\n        };\n\n        // CACHING THE RESULT IN REDIS\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error('Redis set error:', error);\n        }\n\n        // RETURNING THE RESULT\n        return result;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 894, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/dashboard.action.ts"],"sourcesContent":["\"use server\";\n\nimport { DashboardService } from \"@/core/services/dashboard.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING DASHBOARD STATS\nexport async function getDashboardStats() {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes for dashboard stats\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    // CHECKING IF USER IS AUTHENTICATED --> RETURNING NULL IF NOT AUTHENTICATED\n    if (!session?.user) {\n        return null;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`dashboard-${userId}`, 'dashboard-stats');\n\n    return DashboardService.getDashboardStats(userId);\n}\n\n// GET USER PROFILE (PUBLIC READ-ONLY)\nexport async function getUserProfile(userId: string) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // Still require authentication to view profiles\n    if (!session?.user) {\n        return null;\n    }\n\n    cacheTag(`dashboard-${userId}`, 'dashboard-stats');\n\n    return DashboardService.getDashboardStats(userId);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AACA;;;;;;;;AAGO,MAAA,6BAAA,eAAe;IAElB,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI,IAAI,gCAAgC;IAE5E,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IACA,4EAA4E;IAC5E,IAAI,CAAC,SAAS,MAAM;QAChB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAA,yIAAQ,EAAC,CAAC,UAAU,EAAE,QAAQ,EAAE;IAEhC,OAAO,4JAAgB,CAAC,iBAAiB,CAAC;AAC9C;IAjBO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAoBf,MAAA,6BAAA,eAAe,eAAe,MAAc;IAE/C,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI;IAExC,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,gDAAgD;IAChD,IAAI,CAAC,SAAS,MAAM;QAChB,OAAO;IACX;IAEA,IAAA,yIAAQ,EAAC,CAAC,UAAU,EAAE,QAAQ,EAAE;IAEhC,OAAO,4JAAgB,CAAC,iBAAiB,CAAC;AAC9C;IAhBO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe"}},
    {"offset": {"line": 969, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28main%29/dashboard/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE1'\nexport {$$RSC_SERVER_CACHE_0 as '80c021ad7166c82138a01abbe5518c7829e01e6c67'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_1 as 'c059702a0f335f168476ac392628be76b67819c5d0'} from 'ACTIONS_MODULE2'\nexport {syncUserProfile as '002aa3dda4f25040a3c6010d4b8c2ac1d87451eb09'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAEA;AACA"}}]
}