{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { admin } from \"better-auth/plugins\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"./prisma\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n    disableSignUp: true,\n  },\n  socialProviders: {\n    google: {\n      enabled: true,\n      clientId: process.env.GOOGLE_CLIENT_ID as string,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n    microsoft: {\n      enabled: true,\n      clientId: process.env.MICROSOFT_CLIENT_ID as string,\n      clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"STUDENT\",\n      },\n      institutionId: {\n        type: \"string\",\n        required: false,\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n\n  plugins: [\n    admin({\n      adminRoles: [\"ADMIN\"],\n      defaultRole: \"STUDENT\",\n      adminUserIds: [\"jvp0LDpaCm0Y2VpUVP75vCNQnDioEdpm\"], // vishnu\n    }),\n  ],\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEO,MAAM,OAAO,IAAA,qKAAU,EAAC;IAC7B,UAAU,IAAA,8MAAa,EAAC,uHAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;QACT,eAAe;IACjB;IACA,iBAAiB;QACf,QAAQ;YACN,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;QACA,WAAW;YACT,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;YAChB;YACA,eAAe;gBACb,MAAM;gBACN,UAAU;YACZ;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IAEA,SAAS;QACP,IAAA,6KAAK,EAAC;YACJ,YAAY;gBAAC;aAAQ;YACrB,aAAa;YACb,cAAc;gBAAC;aAAmC;QACpD;KACD;AACH"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOO,MAAA,6BAAA,eAAe;IAElB,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI,IAAI,YAAY;IAExD,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAA,yIAAQ,EAAC,CAAC,WAAW,EAAE,QAAQ,EAAE,CAAC,KAAK,EAAE,QAAQ;IAEjD,OAAO,kJAAW,CAAC,YAAY,CAAC;AACpC;IAjBO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAuBf,eAAe;IAClB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,OAAO,kJAAW,CAAC,oBAAoB,CAAC;AAC5C;AAMO,eAAe,mBAAmB,IASxC;IACG,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,MAAM,MAAM,MAAM,kJAAW,CAAC,kBAAkB,CAAC,QAAQ;IAEzD,IAAI,IAAI,OAAO,EAAE;QACb,+DAA+D;QAC/D,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;QAC/C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+CAA+C;QACjE;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,UAAU,EAAE,QAAQ;QAC/B,IAAA,0IAAS,EAAC;IACd;IAEA,OAAO;AACX;AAKO,eAAe,eAAe,IAQpC;IACG,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAI;QACA,0CAA0C;QAC1C,MAAM,cAAc,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBACJ,gBAAgB;gBAChB,kBAAkB;gBAClB,gBAAgB;YACpB;QACJ;QAEA,MAAM,aAAkB;YACpB,MAAM,KAAK,IAAI;YACf,KAAK,KAAK,GAAG;YACb,gBAAgB,KAAK,cAAc;YACnC,gBAAgB,KAAK,cAAc;YACnC,kBAAkB,KAAK,gBAAgB;YACvC,cAAc,KAAK,YAAY;QACnC;QAEA,uCAAuC;QACvC,IAAI,aAAa;YACb,IAAI,KAAK,cAAc,KAAK,aAAa,KAAK,cAAc,KAAK,YAAY,cAAc,EAAE;gBACzF,WAAW,gBAAgB,GAAG;YAClC;YACA,IAAI,KAAK,gBAAgB,KAAK,aAAa,KAAK,gBAAgB,KAAK,YAAY,gBAAgB,EAAE;gBAC/F,WAAW,kBAAkB,GAAG;YACpC;YACA,IAAI,KAAK,cAAc,KAAK,aAAa,KAAK,cAAc,KAAK,YAAY,cAAc,EAAE;gBACzF,WAAW,gBAAgB,GAAG;YAClC;QACJ;QAEA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;QACV;QAEA,yBAAyB;QACzB,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;QAC/C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+CAA+C;QACjE;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC,wBAAwB,iCAAiC;QACxE,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,WAAW,EAAE,QAAQ;QAChC,IAAA,0IAAS,EAAC,CAAC,UAAU,EAAE,QAAQ;QAC/B,IAAA,0IAAS,EAAC;QACV,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC/D;AACJ;AAMO,eAAe;IAClB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,IAAI;QACA,yBAAyB;QACzB,IAAI;YACA,MAAM,QAAQ,CAAC,4VAA2B,EAAE,OAAO;YACnD,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC3C,MAAM,MAAM,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;QAC1C,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,iDAAiD;QACnE;QAEA,2BAA2B;QAC3B,IAAA,+IAAc,EAAC;QACf,IAAA,0IAAS,EAAC,CAAC,KAAK,EAAE,QAAQ;QAC1B,IAAA,0IAAS,EAAC,CAAC,WAAW,EAAE,QAAQ;QAChC,IAAA,0IAAS,EAAC;QAEV,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyB;IAC7D;AACJ;AAKO,MAAA,6BAAA,eAAe;IAElB,IAAA,0IAAS,EAAC;QAAE,OAAO;QAAK,YAAY;IAAI;IAExC,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM,IAAI;QACpB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAC9B,IAAA,yIAAQ,EAAC,CAAC,KAAK,EAAE,QAAQ;IAEzB,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;QACpB,SAAS;YACL,aAAa;QACjB;IACJ;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,OAAO;QACH,IAAI,KAAK,EAAE;QACX,MAAM,KAAK,IAAI;QACf,OAAO,KAAK,KAAK;QACjB,OAAO,KAAK,KAAK;QACjB,KAAK,KAAK,GAAG;QACb,iBAAiB,KAAK,WAAW,EAAE;IACvC;AACJ;IAhCO,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;;;IApLA;IAkBA;IA2CA;IAkFA;;AA/IA,+OAAA;AAkBA,+OAAA;AA2CA,+OAAA;AAkFA,+OAAA"}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest-checker.action.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { User } from \"@prisma/client\";\n\nexport type ParticipationStatus = {\n  userId: string;\n  name: string;\n  handle: string | null;\n  participated: boolean;\n  rank?: number;\n  score?: number;\n  details?: any;\n  error?: string;\n};\n\n// --- Codeforces ---\n\nasync function checkCodeforcesParticipation(contestId: string, users: User[]): Promise<ParticipationStatus[]> {\n  const usersWithHandle = users.filter(u => u.codeforcesHandle);\n  const handleMap = new Map<string, User>();\n  usersWithHandle.forEach(u => handleMap.set(u.codeforcesHandle!.toLowerCase(), u));\n\n  if (usersWithHandle.length === 0) {\n    return users.map(u => ({\n      userId: u.id,\n      name: u.name,\n      handle: u.codeforcesHandle || null,\n      participated: false,\n      error: \"No Codeforces handle linked\"\n    }));\n  }\n\n  // Codeforces allows multiple handles in one request (up to some limit, usually 10000 characters url length)\n  // chunk handles if necessary\n  const chunks = [];\n  const chunkSize = 100; // conservative batch size\n  for (let i = 0; i < usersWithHandle.length; i += chunkSize) {\n    chunks.push(usersWithHandle.slice(i, i + chunkSize));\n  }\n\n  const results: ParticipationStatus[] = [];\n  // Initialize all as not participated\n  users.forEach(u => {\n      if (!u.codeforcesHandle) {\n          results.push({\n              userId: u.id,\n              name: u.name,\n              handle: null,\n              participated: false,\n              error: \"No handle\"\n          });\n      }\n  });\n\n  for (const chunk of chunks) {\n    const handles = chunk.map(u => u.codeforcesHandle).join(\";\");\n    try {\n      const res = await fetch(`https://codeforces.com/api/contest.standings?contestId=${contestId}&handles=${handles}&showUnofficial=true`);\n      const data = await res.json();\n\n      if (data.status !== \"OK\") {\n        chunk.forEach(u => results.push({\n          userId: u.id,\n          name: u.name,\n          handle: u.codeforcesHandle,\n          participated: false,\n          error: data.comment || \"Codeforces API Error\"\n        }));\n        continue;\n      }\n\n      // Process rows\n      const rows = data.result.rows;\n      // Mark those present as participated\n      const foundHandles = new Set<string>();\n\n      rows.forEach((row: any) => {\n        // row.party.members contains the handles\n        row.party.members.forEach((member: any) => {\n           const handle = member.handle.toLowerCase();\n           const user = handleMap.get(handle);\n           if (user) {\n             foundHandles.add(handle);\n             results.push({\n               userId: user.id,\n               name: user.name,\n               handle: user.codeforcesHandle,\n               participated: true,\n               rank: row.rank,\n               score: row.points,\n               details: {\n                 penalty: row.penalty,\n                 successfulHackCount: row.successfulHackCount\n               }\n             });\n           }\n        });\n      });\n\n      // Those in the chunk but not found in rows => did not participate\n      chunk.forEach(u => {\n        if (u.codeforcesHandle && !foundHandles.has(u.codeforcesHandle.toLowerCase())) {\n          results.push({\n            userId: u.id,\n            name: u.name,\n            handle: u.codeforcesHandle,\n            participated: false\n          });\n        }\n      });\n\n    } catch (e: any) {\n      chunk.forEach(u => results.push({\n        userId: u.id,\n        name: u.name,\n        handle: u.codeforcesHandle,\n        participated: false,\n        error: e.message\n      }));\n    }\n  }\n\n  return results;\n}\n\n// --- LeetCode ---\n\nasync function checkLeetCodeParticipation(contestSlug: string, users: User[]): Promise<ParticipationStatus[]> {\n  // LeetCode doesn't have a batch check. We must check each user.\n  // We'll run in parallel with concurrency limit.\n\n  const results: ParticipationStatus[] = [];\n\n  const checkUser = async (user: User) => {\n    if (!user.leetCodeHandle) {\n      return {\n        userId: user.id,\n        name: user.name,\n        handle: null,\n        participated: false,\n        error: \"No handle\"\n      };\n    }\n\n    try {\n      // Query user's contest history\n      const query = `\n        query userContestRankingInfo($username: String!) {\n          userContestRankingHistory(username: $username) {\n            attended\n            contest {\n              titleSlug\n              startTime\n            }\n            ranking\n            finishTimeInSeconds\n          }\n        }\n      `;\n\n      const res = await fetch(\"https://leetcode.com/graphql\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Referer\": `https://leetcode.com/u/${user.leetCodeHandle}/`\n        },\n        body: JSON.stringify({\n          query,\n          variables: { username: user.leetCodeHandle }\n        }),\n        cache: \"no-store\"\n      });\n\n      const data = await res.json();\n      if (data.errors) {\n         return {\n            userId: user.id,\n            name: user.name,\n            handle: user.leetCodeHandle,\n            participated: false,\n            error: data.errors[0]?.message\n         };\n      }\n\n      const history = data.data.userContestRankingHistory || [];\n      // Find the contest\n      const participation = history.find((p: any) => p.contest?.titleSlug === contestSlug);\n\n      if (participation && participation.attended) {\n        return {\n          userId: user.id,\n          name: user.name,\n          handle: user.leetCodeHandle,\n          participated: true,\n          rank: participation.ranking,\n          details: {\n            finishTime: participation.finishTimeInSeconds\n          }\n        };\n      } else {\n        return {\n          userId: user.id,\n          name: user.name,\n          handle: user.leetCodeHandle,\n          participated: false\n        };\n      }\n\n    } catch (e: any) {\n      return {\n        userId: user.id,\n        name: user.name,\n        handle: user.leetCodeHandle,\n        participated: false,\n        error: e.message\n      };\n    }\n  };\n\n  // Process in chunks to avoid rate limits\n  const chunkSize = 5;\n  for (let i = 0; i < users.length; i += chunkSize) {\n    const chunk = users.slice(i, i + chunkSize);\n    const chunkResults = await Promise.all(chunk.map(checkUser));\n    results.push(...chunkResults);\n  }\n\n  return results;\n}\n\n// --- CodeChef ---\n\nasync function checkCodeChefParticipation(contestCode: string, users: User[]): Promise<ParticipationStatus[]> {\n  const results: ParticipationStatus[] = [];\n\n  const checkUser = async (user: User) => {\n    if (!user.codeChefHandle) {\n      return {\n        userId: user.id,\n        name: user.name,\n        handle: null,\n        participated: false,\n        error: \"No handle\"\n      };\n    }\n\n    try {\n      // Use the ranking search API\n      const res = await fetch(`https://www.codechef.com/api/rankings/${contestCode}?itemsPerPage=1&search=${user.codeChefHandle}`, {\n          cache: \"no-store\"\n      });\n\n      if (!res.ok) { // Contest might be invalid or other error\n         return {\n            userId: user.id,\n            name: user.name,\n            handle: user.codeChefHandle,\n            participated: false,\n            error: `API Status: ${res.status}`\n         };\n      }\n\n      const data = await res.json();\n\n      // data.list contains the rows\n      // We searched for the specific handle. If it's there and exact match...\n      const entry = data.list?.find((item: any) => item.user_handle?.toLowerCase() === user.codeChefHandle?.toLowerCase());\n\n      if (entry) {\n        return {\n          userId: user.id,\n          name: user.name,\n          handle: user.codeChefHandle,\n          participated: true,\n          rank: entry.rank,\n          score: parseFloat(entry.score),\n          details: {\n             penalty: entry.penalty\n          }\n        };\n      } else {\n        return {\n          userId: user.id,\n          name: user.name,\n          handle: user.codeChefHandle,\n          participated: false\n        };\n      }\n\n    } catch (e: any) {\n      return {\n        userId: user.id,\n        name: user.name,\n        handle: user.codeChefHandle,\n        participated: false,\n        error: e.message\n      };\n    }\n  };\n\n   // Process in chunks\n  const chunkSize = 5;\n  for (let i = 0; i < users.length; i += chunkSize) {\n    const chunk = users.slice(i, i + chunkSize);\n    const chunkResults = await Promise.all(chunk.map(checkUser));\n    results.push(...chunkResults);\n  }\n\n  return results;\n}\n\n\n// --- Main Action ---\n\nexport async function checkExternalParticipation(\n  platform: \"CodeForces\" | \"LeetCode\" | \"CodeChef\",\n  contestIdentifier: string, // ID for CF, Slug for LC, Code for CC\n  userFilters?: {\n      institutionId?: string;\n      classroomId?: string;\n  }\n) {\n\n  // 1. Fetch Users\n  const where: any = {\n      role: \"STUDENT\" // Mostly we care about students\n  };\n\n  if (userFilters?.institutionId) {\n      where.institutionId = userFilters.institutionId;\n  }\n\n  // Note: Classroom logic might need recursive fetch if not directly on user,\n  // but User model has `enrolledClassrooms`.\n  if (userFilters?.classroomId) {\n      where.enrolledClassrooms = {\n          some: {\n              id: userFilters.classroomId\n          }\n      };\n  }\n\n  const users = await prisma.user.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      codeforcesHandle: true,\n      leetCodeHandle: true,\n      codeChefHandle: true\n    }\n  });\n\n  if (users.length === 0) {\n      return { success: true, results: [] };\n  }\n\n  let results: ParticipationStatus[] = [];\n\n  try {\n      if (platform === \"CodeForces\") {\n          results = await checkCodeforcesParticipation(contestIdentifier, users as User[]);\n      } else if (platform === \"LeetCode\") {\n          results = await checkLeetCodeParticipation(contestIdentifier, users as User[]);\n      } else if (platform === \"CodeChef\") {\n          results = await checkCodeChefParticipation(contestIdentifier, users as User[]);\n      }\n\n      return { success: true, results };\n  } catch (error: any) {\n      console.error(\"Check participation error:\", error);\n      return { success: false, error: error.message };\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1088, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28main%29/admin/external-contest-verification/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE1'\nexport {checkExternalParticipation as '70a74088e6ae2baef179da5722207b030fb65b8469'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AAEA;AACA"}}]
}