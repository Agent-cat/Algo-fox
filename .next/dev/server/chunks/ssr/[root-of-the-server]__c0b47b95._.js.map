{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/redis.ts"],"sourcesContent":["import IORedis from \"ioredis\";\n\nconst connection = new IORedis({\n  host: process.env.REDIS_HOST || \"127.0.0.1\",\n  port: parseInt(process.env.REDIS_PORT || \"6379\"),\n  maxRetriesPerRequest: null,\n  enableReadyCheck: false,\n});\n\nconnection.on(\"error\", (error) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.warn(\"[Redis] Connection error:\", error);\n  }\n});\n\nexport default connection;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oJAAO,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;IAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;IACzC,sBAAsB;IACtB,kBAAkB;AACpB;AAEA,WAAW,EAAE,CAAC,SAAS,CAAC;IACtB,wCAA2C;QACzC,QAAQ,IAAI,CAAC,6BAA6B;IAC5C;AACF;uCAEe"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/user.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEA,MAAM,YAAY,IAAI,aAAa;AAE5B,MAAM;IAET;;;IAGA,GACA,aAAa,aAAa,MAAc,EAAmB;QACvD,MAAM,WAAW,CAAC,WAAW,EAAE,QAAQ;QAEvC,IAAI;YACA,MAAM,SAAS,MAAM,uHAAK,CAAC,GAAG,CAAC;YAC/B,IAAI,QAAQ;gBAER,OAAO,SAAS,QAAQ;YAC5B;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ;gBAAE,YAAY;YAAK;QAC/B;QAEA,MAAM,QAAQ,MAAM,cAAc;QAElC,IAAI;YACA,MAAM,uHAAK,CAAC,KAAK,CAAC,UAAU,WAAW,MAAM,QAAQ;QACzD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,oBAAoB;QACtC;QAEA,OAAO;IACX;IAGA;;;KAGC,GACD,aAAa,qBAAqB,MAAc,EAAmD;QAC/F,IAAI;YACA,0EAA0E;YAC1E,MAAM,oBAAoB,MAAM,uHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACvD,OAAO;oBACH;oBACA,QAAQ;oBACR,MAAM;gBACV;gBACA,QAAQ;oBACJ,WAAW;oBACX,SAAS;wBACL,QAAQ;4BACJ,YAAY;wBAChB;oBACJ;gBACJ;gBACA,UAAU;oBAAC;iBAAY;YAC3B;YAEA,4CAA4C;YAC5C,IAAI,aAAa;YACjB,KAAK,MAAM,cAAc,kBAAmB;gBACxC,MAAM,SAAS,IAAA,uIAAsB,EAAC,WAAW,OAAO,CAAC,UAAU;gBACnE,cAAc;YAClB;YAEA,2CAA2C;YAC3C,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF;gBACJ;YACJ;YAEA,mBAAmB;YACnB,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ;YAC1C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;YAEA,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QACjD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM,IAAI,MAAM;QACpB;IACJ;IAEA;;;IAGA,GACA,aAAa,mBAAmB,MAAc,EAAE,IAU/C,EAAiD;QAC9C,IAAI;YACA,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACrB,OAAO;oBAAE,IAAI;gBAAO;gBACpB,MAAM;oBACF,MAAM,KAAK,IAAI;oBACf,WAAW,KAAK,SAAS,IAAI;oBAC7B,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI,IAAI;oBACxC,KAAK,KAAK,GAAG,IAAI;oBACjB,gBAAgB,KAAK,cAAc,IAAI;oBACvC,gBAAgB,KAAK,cAAc,IAAI;oBACvC,kBAAkB,KAAK,gBAAgB,IAAI,KAAK,gBAAgB,IAAI;oBACpE,cAAc,KAAK,YAAY,IAAI;oBACnC,qBAAqB;gBACzB;YACJ;YAEA,6BAA6B;YAC7B,IAAI;gBACA,MAAM,uHAAK,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ;YAC/C,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,yCAAyC;YAC3D;YAEA,OAAO;gBAAE,SAAS;YAAK;QAC3B,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;YAChD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAgC;QACpE;IACJ;AACJ"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/cache-utils.ts"],"sourcesContent":["import redis from \"./redis\";\n\n/**\n * Cache configuration for different data types\n */\nexport const CACHE_CONFIG = {\n  // Short-lived cache for frequently changing data\n  SHORT: { ttl: 30, stale: 15 },\n  // Medium cache for moderately changing data\n  MEDIUM: { ttl: 120, stale: 60 },\n  // Long cache for rarely changing data\n  LONG: { ttl: 600, stale: 300 },\n  // Very long cache for static-ish data\n  STATIC: { ttl: 3600, stale: 1800 },\n} as const;\n\n/**\n * Generate a consistent cache key\n */\nexport function cacheKey(prefix: string, ...parts: (string | number)[]): string {\n  return `algofox:${prefix}:${parts.join(\":\")}`;\n}\n\n/**\n * Get data from Redis cache with automatic JSON parsing\n */\nexport async function getFromCache<T>(key: string): Promise<T | null> {\n  try {\n    const data = await redis.get(key);\n    if (!data) return null;\n    return JSON.parse(data) as T;\n  } catch (error) {\n    console.error(\"[Cache] Get error:\", error);\n    return null;\n  }\n}\n\n/**\n * Set data in Redis cache with automatic JSON serialization\n */\nexport async function setInCache<T>(\n  key: string,\n  data: T,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<void> {\n  try {\n    await redis.setex(key, ttlSeconds, JSON.stringify(data));\n  } catch (error) {\n    console.error(\"[Cache] Set error:\", error);\n  }\n}\n\n/**\n * Delete a cache key\n */\nexport async function deleteFromCache(key: string): Promise<void> {\n  try {\n    await redis.del(key);\n  } catch (error) {\n    console.error(\"[Cache] Delete error:\", error);\n  }\n}\n\n/**\n * Delete multiple cache keys by pattern\n */\nexport async function deleteByPattern(pattern: string): Promise<void> {\n  try {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  } catch (error) {\n    console.error(\"[Cache] Delete pattern error:\", error);\n  }\n}\n\n/**\n * Get or set pattern - tries cache first, falls back to fetcher\n */\nexport async function cachedFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<T> {\n  // Try cache first\n  const cached = await getFromCache<T>(key);\n  if (cached !== null) {\n    return cached;\n  }\n\n  // Fetch fresh data\n  const data = await fetcher();\n\n  // Cache the result (don't await to not block response)\n  setInCache(key, data, ttlSeconds).catch(() => {});\n\n  return data;\n}\n\n/**\n * Invalidate cache keys for an entity\n */\nexport async function invalidateCache(\n  prefix: string,\n  ...ids: (string | number)[]\n): Promise<void> {\n  const pattern = `algofox:${prefix}:${ids.length > 0 ? ids.join(\":\") : \"*\"}`;\n  await deleteByPattern(pattern);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AAKO,MAAM,eAAe;IAC1B,iDAAiD;IACjD,OAAO;QAAE,KAAK;QAAI,OAAO;IAAG;IAC5B,4CAA4C;IAC5C,QAAQ;QAAE,KAAK;QAAK,OAAO;IAAG;IAC9B,sCAAsC;IACtC,MAAM;QAAE,KAAK;QAAK,OAAO;IAAI;IAC7B,sCAAsC;IACtC,QAAQ;QAAE,KAAK;QAAM,OAAO;IAAK;AACnC;AAKO,SAAS,SAAS,MAAc,EAAE,GAAG,KAA0B;IACpE,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,MAAM,IAAI,CAAC,MAAM;AAC/C;AAKO,eAAe,aAAgB,GAAW;IAC/C,IAAI;QACF,MAAM,OAAO,MAAM,uHAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,MAAM,OAAO;QAClB,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO;IACT;AACF;AAKO,eAAe,WACpB,GAAW,EACX,IAAO,EACP,aAAqB,aAAa,MAAM,CAAC,GAAG;IAE5C,IAAI;QACF,MAAM,uHAAK,CAAC,KAAK,CAAC,KAAK,YAAY,KAAK,SAAS,CAAC;IACpD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;IACtC;AACF;AAKO,eAAe,gBAAgB,GAAW;IAC/C,IAAI;QACF,MAAM,uHAAK,CAAC,GAAG,CAAC;IAClB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;IACzC;AACF;AAKO,eAAe,gBAAgB,OAAe;IACnD,IAAI;QACF,MAAM,OAAO,MAAM,uHAAK,CAAC,IAAI,CAAC;QAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;YACnB,MAAM,uHAAK,CAAC,GAAG,IAAI;QACrB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;IACjD;AACF;AAKO,eAAe,YACpB,GAAW,EACX,OAAyB,EACzB,aAAqB,aAAa,MAAM,CAAC,GAAG;IAE5C,kBAAkB;IAClB,MAAM,SAAS,MAAM,aAAgB;IACrC,IAAI,WAAW,MAAM;QACnB,OAAO;IACT;IAEA,mBAAmB;IACnB,MAAM,OAAO,MAAM;IAEnB,uDAAuD;IACvD,WAAW,KAAK,MAAM,YAAY,KAAK,CAAC,KAAO;IAE/C,OAAO;AACT;AAKO,eAAe,gBACpB,MAAc,EACd,GAAG,GAAwB;IAE3B,MAAM,UAAU,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,IAAI,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,OAAO,KAAK;IAC3E,MAAM,gBAAgB;AACxB"}},
    {"offset": {"line": 733, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/classroom.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport redis from \"@/lib/redis\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheKey, cachedFetch, CACHE_CONFIG, deleteFromCache } from \"@/lib/cache-utils\";\n\nconst classroomSchema = z.object({\n    name: z.string().min(2, \"Name must be at least 2 characters\"),\n    section: z.string().optional().or(z.literal(\"\")),\n    subject: z.string().optional().or(z.literal(\"\")),\n    institutionId: z.string(),\n});\n\nfunction generateJoinCode() {\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    let code = \"\";\n    for (let i = 0; i < 6; i++) {\n        code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n}\n\n/**\n * Creates a new classroom.\n * Only ADMIN, INSTITUTION_MANAGER, or TEACHER roles can create classrooms.\n */\nexport async function createClassroom(data: z.infer<typeof classroomSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    // Security check\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized. Only teachers or managers can create classrooms.\" };\n    }\n\n    try {\n        const validatedData = classroomSchema.parse(data);\n\n        // Generate unique 6-character join code\n        let joinCode = \"\";\n        let isUnique = false;\n        let attempts = 0;\n        while (!isUnique && attempts < 10) {\n            joinCode = generateJoinCode();\n            const existing = await prisma.classroom.findUnique({\n                where: { joinCode },\n            });\n            if (!existing) isUnique = true;\n            attempts++;\n        }\n\n        if (!isUnique) {\n            return { success: false, error: \"Failed to generate a unique join code. Please try again.\" };\n        }\n\n        const classroom = await prisma.classroom.create({\n            data: {\n                name: validatedData.name,\n                section: validatedData.section || null,\n                subject: validatedData.subject || null,\n                joinCode,\n                institutionId: validatedData.institutionId,\n                teacherId: currentUser.id,\n            },\n        });\n\n        // Invalidate relevant caches\n        revalidateTag(`teacher-classrooms-${currentUser.id}`, \"max\");\n        revalidateTag(`institution-classrooms-${validatedData.institutionId}`, \"max\");\n        revalidatePath(\"/dashboard/institution/classrooms\");\n\n        return { success: true, data: classroom };\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return { success: false, error: error.issues[0].message };\n        }\n        console.error(\"Failed to create classroom:\", error);\n        return { success: false, error: \"Failed to create classroom\" };\n    }\n}\n\n/**\n * Allows a student to join a classroom using a 6-character code.\n * Also onboards the student to the institution if they are not already associated.\n */\nexport async function joinClassroom(code: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    try {\n\n        const classroom = await prisma.classroom.findUnique({\n            where: { joinCode: code.toUpperCase() },\n            include: {\n                students: {\n                    where: { id: currentUser.id },\n                },\n            },\n        });\n\n        if (!classroom) {\n            return { success: false, error: \"Invalid join code.\" };\n        }\n\n        if (classroom.students.length > 0) {\n            return { success: false, error: \"You are already enrolled in this classroom.\" };\n        }\n\n\n        // Institution Check:\n        // 1. If user belongs to an institution, they can only join classrooms from THAT institution.\n        // 2. If user has NO institution, they are assigned to this classroom's institution.\n\n        if (currentUser.institutionId && currentUser.institutionId !== classroom.institutionId) {\n             return {\n                success: false,\n                error: \"You cannot join this classroom because it belongs to a different institution.\"\n             };\n        }\n\n        // Add student to classroom\n        await prisma.classroom.update({\n            where: { id: classroom.id },\n            data: {\n                students: {\n                    connect: { id: currentUser.id },\n                },\n            },\n        });\n\n        // Onboard student to institution if null\n        const updateData: any = {\n            onboardingCompleted: true,\n        };\n\n        if (!currentUser.institutionId) {\n            updateData.institutionId = classroom.institutionId;\n        }\n\n        await prisma.user.update({\n            where: { id: currentUser.id },\n            data: updateData,\n        });\n\n        // Redis Integration: Cache student IDs per classroom\n        const redisKey = `classroom:students:${classroom.id}`;\n        await redis.sadd(redisKey, currentUser.id);\n\n        // Invalidate caches\n        revalidateTag(`student-classrooms-${currentUser.id}`, \"max\");\n        revalidateTag(`classroom-${classroom.id}`, \"max\");\n        revalidatePath(\"/dashboard/classrooms\");\n\n        return { success: true, message: `Successfully joined ${classroom.name}` };\n    } catch (error) {\n        console.error(\"Failed to join classroom:\", error);\n        return { success: false, error: \"Failed to join classroom\" };\n    }\n}\n\n/**\n * Fetches basic details of a classroom by its join code.\n * Used for the join classroom page.\n */\nexport async function getClassroomByCode(code: string) {\n    try {\n        const classroom = await prisma.classroom.findUnique({\n            where: { joinCode: code.toUpperCase() },\n            select: {\n                id: true,\n                name: true,\n                subject: true,\n                section: true,\n                teacher: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                    }\n                },\n                _count: {\n                    select: { students: true }\n                }\n            }\n        });\n\n        if (!classroom) {\n            return { success: false, error: \"Classroom not found\" };\n        }\n\n        const session = await auth.api.getSession({\n            headers: await headers(),\n        });\n\n        const isEnrolled = session?.user ? await prisma.classroom.findFirst({\n            where: {\n                id: classroom.id,\n                students: { some: { id: session.user.id } }\n            }\n        }) : false;\n\n        return {\n            success: true,\n            classroom,\n            isEnrolled: !!isEnrolled\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch classroom by code:\", error);\n        return { success: false, error: \"Failed to fetch classroom\" };\n    }\n}\n\n/**\n * Fetches classrooms created by the currently logged-in teacher (CACHED).\n */\nexport async function getTeacherClassrooms() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const fetchClassrooms = unstable_cache(\n        async () => {\n            return await prisma.classroom.findMany({\n                where: { teacherId: userId },\n                include: {\n                    _count: {\n                        select: { students: true },\n                    },\n                },\n                orderBy: { createdAt: \"desc\" },\n            });\n        },\n        [`teacher-classrooms-${userId}`],\n        { tags: [`teacher-classrooms-${userId}`], revalidate: 120 }\n    );\n\n    try {\n        const classrooms = await fetchClassrooms();\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch teacher classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\n/**\n * Fetches classrooms where the currently logged-in student is enrolled (CACHED).\n */\nexport async function getStudentClassrooms() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const fetchClassrooms = unstable_cache(\n        async () => {\n            const user = await prisma.user.findUnique({\n                where: { id: userId },\n                include: {\n                    enrolledClassrooms: {\n                        include: {\n                            teacher: {\n                                select: { name: true },\n                            },\n                        },\n                        orderBy: { createdAt: \"desc\" },\n                    },\n                },\n            });\n            return user?.enrolledClassrooms || [];\n        },\n        [`student-classrooms-${userId}`],\n        { tags: [`student-classrooms-${userId}`], revalidate: 120 }\n    );\n\n    try {\n        const classrooms = await fetchClassrooms();\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch student classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\n/**\n * Fetches details of a specific classroom, including the student list for the leaderboard (CACHED).\n * Supports pagination for large student lists.\n */\nexport async function getClassroomWithStudents(\n    id: string,\n    page: number = 1,\n    limit: number = 50\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const skip = (page - 1) * limit;\n\n    const fetchClassroom = unstable_cache(\n        async () => {\n            const [classroom, totalStudents] = await Promise.all([\n                prisma.classroom.findUnique({\n                    where: { id },\n                    select: {\n                        id: true,\n                        name: true,\n                        subject: true,\n                        section: true,\n                        joinCode: true,\n                        isTrackingActive: true,\n                        trackingStartedAt: true,\n                        teacher: {\n                            select: { name: true, id: true },\n                        },\n                        students: {\n                            select: {\n                                id: true,\n                                name: true,\n                                totalScore: true,\n                                image: true,\n                            },\n                            orderBy: { totalScore: \"desc\" },\n                            skip,\n                            take: limit,\n                        },\n                    },\n                }),\n                prisma.user.count({\n                    where: {\n                        enrolledClassrooms: {\n                            some: { id }\n                        }\n                    }\n                })\n            ]);\n\n            return { classroom, totalStudents };\n        },\n        [`classroom-${id}-page-${page}`],\n        { tags: [`classroom-${id}`], revalidate: 60 }\n    );\n\n    try {\n        const { classroom, totalStudents } = await fetchClassroom();\n\n        if (!classroom) {\n            return { success: false, error: \"Classroom not found\" };\n        }\n\n        return {\n            success: true,\n            classroom,\n            pagination: {\n                total: totalStudents,\n                pages: Math.ceil(totalStudents / limit),\n                current: page,\n                limit\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch classroom detail:\", error);\n        return { success: false, error: \"Failed to fetch classroom\" };\n    }\n}\n\nexport async function toggleClassroomTracking(classroomId: string, active: boolean) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const classroom = await prisma.classroom.findUnique({\n        where: { id: classroomId },\n        select: { teacherId: true }\n    });\n\n    if (!classroom || (classroom.teacherId !== session.user.id && (session.user as any).role !== \"ADMIN\")) {\n        return { success: false, error: \"Access denied\" };\n    }\n\n    await prisma.classroom.update({\n        where: { id: classroomId },\n        data: {\n            isTrackingActive: active,\n            trackingStartedAt: active ? new Date() : null\n        }\n    });\n\n    await deleteFromCache(cacheKey(\"live-tracking\", classroomId));\n    revalidateTag(`classroom-${classroomId}`, \"max\");\n    revalidatePath(`/dashboard/classrooms/${classroomId}`);\n    return { success: true };\n}\n\nexport async function getClassroomLiveTracking(classroomId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Use Redis cache for live tracking data (short TTL)\n    const cacheKeyName = cacheKey(\"live-tracking\", classroomId);\n\n    const fetchTracking = async () => {\n        const classroom = await prisma.classroom.findUnique({\n            where: { id: classroomId },\n            select: {\n                isTrackingActive: true,\n                trackingStartedAt: true,\n                students: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        submissions: {\n                            where: {\n                                mode: \"SUBMIT\",\n                            },\n                            orderBy: { createdAt: 'desc' },\n                            take: 20,\n                            include: {\n                                problem: { select: { title: true } }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        if (!classroom) return null;\n\n        // Filter submissions if tracking is active\n        const studentsData = classroom.students.map(student => {\n            const filteredSubmissions = student.submissions.filter(sub =>\n                classroom.isTrackingActive &&\n                classroom.trackingStartedAt &&\n                new Date(sub.createdAt) >= new Date(classroom.trackingStartedAt)\n            ).map(sub => ({\n                id: sub.id,\n                code: sub.code,\n                status: sub.status,\n                problemTitle: sub.problem.title,\n                createdAt: sub.createdAt\n            }));\n\n            return {\n                id: student.id,\n                name: student.name,\n                image: student.image,\n                submissions: filteredSubmissions\n            };\n        });\n\n        return {\n            isTrackingActive: classroom.isTrackingActive,\n            trackingStartedAt: classroom.trackingStartedAt,\n            students: studentsData\n        };\n    };\n\n    try {\n        const data = await cachedFetch(cacheKeyName, fetchTracking, CACHE_CONFIG.SHORT.ttl);\n\n        if (!data) {\n            return { success: false, error: \"Classroom not found\" };\n        }\n\n        return {\n            success: true,\n            ...data\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch live tracking:\", error);\n        return { success: false, error: \"Failed to fetch tracking data\" };\n    }\n}\n\n/**\n * Fetches all classrooms for an institution (CACHED with pagination).\n */\nexport async function getInstitutionClassrooms(page: number = 1, limit: number = 20) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (currentUser.role !== \"ADMIN\" && currentUser.role !== \"INSTITUTION_MANAGER\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const institutionId = currentUser.institutionId;\n    const skip = (page - 1) * limit;\n\n    const fetchClassrooms = unstable_cache(\n        async () => {\n            const [classrooms, total] = await Promise.all([\n                prisma.classroom.findMany({\n                    where: { institutionId },\n                    include: {\n                        teacher: {\n                            select: { name: true, email: true }\n                        },\n                        _count: {\n                            select: { students: true }\n                        }\n                    },\n                    orderBy: { createdAt: \"desc\" },\n                    skip,\n                    take: limit,\n                }),\n                prisma.classroom.count({\n                    where: { institutionId }\n                })\n            ]);\n\n            return { classrooms, total };\n        },\n        [`institution-classrooms-${institutionId}-page-${page}`],\n        { tags: [`institution-classrooms-${institutionId}`], revalidate: 120 }\n    );\n\n    try {\n        const { classrooms, total } = await fetchClassrooms();\n        return {\n            success: true,\n            classrooms,\n            pagination: {\n                total,\n                pages: Math.ceil(total / limit),\n                current: page,\n                limit\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch institution classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function removeStudentFromClassroom(classroomId: string, studentId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n    const isPowerful = [\"ADMIN\", \"INSTITUTION_MANAGER\"].includes(currentUser.role);\n\n    try {\n        const classroom = await prisma.classroom.findUnique({\n            where: { id: classroomId },\n            select: { teacherId: true, institutionId: true },\n        });\n\n        if (!classroom) {\n            return { success: false, error: \"Classroom not found\" };\n        }\n\n        // Only allow if powerful role OR if current user is the teacher\n        if (!isPowerful && classroom.teacherId !== currentUser.id) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.classroom.update({\n            where: { id: classroomId },\n            data: {\n                students: {\n                    disconnect: { id: studentId },\n                },\n            },\n        });\n\n        // Remove from Redis set\n        const redisKey = `classroom:students:${classroomId}`;\n        await redis.srem(redisKey, studentId);\n\n        // Invalidate caches\n        revalidateTag(`classroom-${classroomId}`, \"max\");\n        revalidateTag(`student-classrooms-${studentId}`, \"max\");\n        revalidatePath(`/dashboard/classrooms/${classroomId}`);\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to remove student:\", error);\n        return { success: false, error: \"Failed to remove student\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1507, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/classroom/ClassroomDashboard.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ClassroomDashboard = registerClientReference(\n    function() { throw new Error(\"Attempted to call ClassroomDashboard() from the server but ClassroomDashboard is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/classroom/ClassroomDashboard.tsx <module evaluation>\",\n    \"ClassroomDashboard\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,qBAAqB,IAAA,wQAAuB,EACrD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,6EACA","ignoreList":[0]}},
    {"offset": {"line": 1521, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/classroom/ClassroomDashboard.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ClassroomDashboard = registerClientReference(\n    function() { throw new Error(\"Attempted to call ClassroomDashboard() from the server but ClassroomDashboard is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/classroom/ClassroomDashboard.tsx\",\n    \"ClassroomDashboard\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,qBAAqB,IAAA,wQAAuB,EACrD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,yDACA","ignoreList":[0]}},
    {"offset": {"line": 1535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/app/%28main%29/dashboard/classrooms/%5Bid%5D/page.tsx"],"sourcesContent":["import { getClassroomWithStudents } from \"@/actions/classroom\";\nimport { ClassroomDashboard } from \"@/components/classroom/ClassroomDashboard\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\nimport Link from \"next/link\";\nimport { ArrowLeft, School, GraduationCap, ChevronRight } from \"lucide-react\";\nimport { Suspense } from \"react\";\n\ninterface PageProps {\n    params: Promise<{ id: string }>;\n}\n\nasync function ClassroomDetailContent({ params }: { params: Promise<{ id: string }> }) {\n    \"use cache: private\";\n    const { id } = await params;\n\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        redirect(\"/signin\");\n    }\n\n    const res = await getClassroomWithStudents(id);\n    if (!res.success || !res.classroom) {\n        return (\n            <div className=\"min-h-screen flex items-center justify-center bg-white dark:bg-[#0a0a0a] p-6\">\n                <div className=\"text-center max-w-sm\">\n                    <div className=\"p-4 bg-gray-50 dark:bg-[#1a1a1a] rounded-3xl mb-6 inline-block\">\n                        <School className=\"w-12 h-12 text-gray-300 dark:text-gray-600\" />\n                    </div>\n                    <h1 className=\"text-3xl font-black text-gray-900 dark:text-white mb-2 tracking-tighter\">Classroom Not Found</h1>\n                    <Link href=\"/dashboard/classrooms\" className=\"inline-flex items-center gap-2 text-orange-600 dark:text-orange-500 font-bold\">\n                        <ArrowLeft className=\"w-5 h-5\" />\n                        Back to Hub\n                    </Link>\n                </div>\n            </div>\n        );\n    }\n\n    const classroom = res.classroom;\n\n    return (\n        <ClassroomDashboard\n            classroom={classroom as any}\n            currentUserId={session.user.id}\n        />\n    );\n}\n\nexport default function ClassroomDetailPage({ params }: PageProps) {\n    return (\n        <Suspense fallback={\n            <div className=\"min-h-screen bg-white dark:bg-[#0a0a0a] flex items-center justify-center\">\n                <div className=\"text-center\">\n                    <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-orange-500 mx-auto\"></div>\n                    <p className=\"mt-4 text-gray-600 dark:text-gray-400\">Loading classroom...</p>\n                </div>\n            </div>\n        }>\n            <ClassroomDetailContent params={params} />\n        </Suspense>\n    );\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;;;;;;;;;;;;;AAOA,MAAA,6BAAA,eAAe,uBAAuB,EAAE,MAAM,EAAuC;IAEjF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IAErB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM;QAChB,IAAA,iMAAQ,EAAC;IACb;IAEA,MAAM,MAAM,MAAM,IAAA,gJAAwB,EAAC;IAC3C,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,SAAS,EAAE;QAChC,qBACI,8OAAC;YAAI,WAAU;sBACX,cAAA,8OAAC;gBAAI,WAAU;;kCACX,8OAAC;wBAAI,WAAU;kCACX,cAAA,8OAAC,gNAAM;4BAAC,WAAU;;;;;;;;;;;kCAEtB,8OAAC;wBAAG,WAAU;kCAA0E;;;;;;kCACxF,8OAAC,0LAAI;wBAAC,MAAK;wBAAwB,WAAU;;0CACzC,8OAAC,6NAAS;gCAAC,WAAU;;;;;;4BAAY;;;;;;;;;;;;;;;;;;IAMrD;IAEA,MAAM,YAAY,IAAI,SAAS;IAE/B,qBACI,8OAAC,oKAAkB;QACf,WAAW;QACX,eAAe,QAAQ,IAAI,CAAC,EAAE;;;;;;AAG1C;IAtCA,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAwCA,SAAS,oBAAoB,EAAE,MAAM,EAAa;IAC7D,qBACI,8OAAC,iNAAQ;QAAC,wBACN,8OAAC;YAAI,WAAU;sBACX,cAAA,8OAAC;gBAAI,WAAU;;kCACX,8OAAC;wBAAI,WAAU;;;;;;kCACf,8OAAC;wBAAE,WAAU;kCAAwC;;;;;;;;;;;;;;;;;kBAI7D,cAAA,8OAAC;YAAuB,QAAQ;;;;;;;;;;;AAG5C"}},
    {"offset": {"line": 1709, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/assignment.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheKey, cachedFetch, CACHE_CONFIG } from \"@/lib/cache-utils\";\n\n/**\n * Get all assignments for a specific classroom (CACHED with pagination)\n */\nexport async function getClassroomAssignments(\n    classroomId: string,\n    page: number = 1,\n    limit: number = 20\n) {\n    // Filter out assignments older than 3 weeks\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n    const skip = (page - 1) * limit;\n\n    const fetchAssignments = unstable_cache(\n        async () => {\n            const [assignments, total] = await Promise.all([\n                prisma.assignment.findMany({\n                    where: {\n                        classroomId,\n                        createdAt: { gte: threeWeeksAgo }\n                    },\n                    include: {\n                        _count: {\n                            select: { problems: true }\n                        }\n                    },\n                    orderBy: { createdAt: \"desc\" },\n                    skip,\n                    take: limit,\n                }),\n                prisma.assignment.count({\n                    where: {\n                        classroomId,\n                        createdAt: { gte: threeWeeksAgo }\n                    }\n                })\n            ]);\n\n            return { assignments, total };\n        },\n        [`classroom-assignments-${classroomId}-page-${page}`],\n        { tags: [`assignments-classroom-${classroomId}`, 'assignments-all'], revalidate: 60 }\n    );\n\n    const { assignments, total } = await fetchAssignments();\n\n    return {\n        assignments,\n        pagination: {\n            total,\n            pages: Math.ceil(total / limit),\n            current: page,\n            limit\n        }\n    };\n}\n\n/**\n * Get all assignments for a specific classroom (UNCACHED)\n * Use this for refetching after mutations to get fresh data\n */\nexport async function refreshClassroomAssignments(classroomId: string) {\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n\n    return await prisma.assignment.findMany({\n        where: {\n            classroomId,\n            createdAt: { gte: threeWeeksAgo }\n        },\n        include: {\n            _count: {\n                select: { problems: true }\n            }\n        },\n        orderBy: { createdAt: \"desc\" }\n    });\n}\n\n/**\n * Create a new assignment for a classroom\n */\nexport async function createAssignment(\n    classroomId: string,\n    data: {\n        title: string;\n        description?: string;\n        dueDate?: Date;\n        problemIds: string[];\n    }\n) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Verify teacher owns the classroom\n        const classroom = await prisma.classroom.findUnique({\n            where: { id: classroomId },\n            select: { teacherId: true }\n        });\n\n        if (!classroom || classroom.teacherId !== session.user.id) {\n            return { success: false, error: \"Unauthorized access to classroom\" };\n        }\n\n        const assignment = await prisma.assignment.create({\n            data: {\n                title: data.title,\n                description: data.description,\n                dueDate: data.dueDate,\n                classroomId,\n                problems: {\n                    create: data.problemIds.map((id, index) => ({\n                        problemId: id,\n                        order: index\n                    }))\n                }\n            }\n        });\n\n        // Revalidate classroom-specific and global assignment caches\n        revalidateTag(`assignments-classroom-${classroomId}`, \"max\");\n        revalidateTag('assignments-all', \"max\"); // Invalidate student assignments cache\n\n        return { success: true, assignmentId: assignment.id };\n    } catch (error) {\n        console.error(\"Create assignment error:\", error);\n        return { success: false, error: \"Failed to create assignment\" };\n    }\n}\n\n/**\n * Get details of a specific assignment, including problems (CACHED)\n */\nexport async function getAssignmentDetails(assignmentId: string) {\n    const fetchDetails = unstable_cache(\n        async () => {\n            return await prisma.assignment.findUnique({\n                where: { id: assignmentId },\n                include: {\n                    problems: {\n                        include: {\n                            problem: {\n                                select: {\n                                    id: true,\n                                    title: true,\n                                    slug: true,\n                                    difficulty: true,\n                                    type: true,\n                                    domain: true,\n                                }\n                            }\n                        },\n                        orderBy: { order: \"asc\" }\n                    },\n                    classroom: {\n                        select: {\n                            name: true,\n                            id: true\n                        }\n                    }\n                }\n            });\n        },\n        [`assignment-details-${assignmentId}`],\n        { tags: [`assignment-${assignmentId}`], revalidate: 3600 } // Cache for 1 hour\n    );\n\n    return await fetchDetails();\n}\n\n/**\n * Get all assignments for the current student across all enrolled classrooms (CACHED with pagination)\n */\nexport async function getStudentAssignments(page: number = 1, limit: number = 20) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) return { assignments: [], pagination: null };\n\n    // Filter out assignments older than 3 weeks\n    const threeWeeksAgo = new Date();\n    threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);\n    const skip = (page - 1) * limit;\n    const userId = session.user.id;\n\n    const fetchStudentAssignments = unstable_cache(\n        async () => {\n            // First get enrolled classrooms\n            const user = await prisma.user.findUnique({\n                where: { id: userId },\n                select: {\n                    enrolledClassrooms: {\n                        select: { id: true }\n                    }\n                }\n            });\n\n            if (!user || user.enrolledClassrooms.length === 0) {\n                return { assignments: [], total: 0 };\n            }\n\n            const classroomIds = user.enrolledClassrooms.map(c => c.id);\n\n            // Fetch assignments for these classrooms with count\n            const [assignments, total] = await Promise.all([\n                prisma.assignment.findMany({\n                    where: {\n                        classroomId: { in: classroomIds },\n                        createdAt: { gte: threeWeeksAgo }\n                    },\n                    include: {\n                        classroom: {\n                            select: { name: true }\n                        },\n                        _count: {\n                            select: { problems: true }\n                        }\n                    },\n                    orderBy: { dueDate: \"asc\" }, // Due soonest first\n                    skip,\n                    take: limit,\n                }),\n                prisma.assignment.count({\n                    where: {\n                        classroomId: { in: classroomIds },\n                        createdAt: { gte: threeWeeksAgo }\n                    }\n                })\n            ]);\n\n            return { assignments, total };\n        },\n        [`student-assignments-${userId}-page-${page}`],\n        { tags: [`student-assignments-${userId}`, 'assignments-all'], revalidate: 60 }\n    );\n\n    const { assignments, total } = await fetchStudentAssignments();\n\n    return {\n        assignments,\n        pagination: total > 0 ? {\n            total,\n            pages: Math.ceil(total / limit),\n            current: page,\n            limit\n        } : null\n    };\n}\n\n/**\n * Check completion status of problems in an assignment for a specific user (CACHED short-term)\n */\nexport async function getAssignmentProgress(assignmentId: string, userId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    const targetUserId = userId || session?.user?.id;\n    if (!targetUserId) return null;\n\n    // Get assignment problems (cached)\n    const assignment = await getAssignmentDetails(assignmentId);\n    if (!assignment) return null;\n\n    const problemIds = assignment.problems.map(p => p.problemId);\n\n    // Use Redis cache for progress (short TTL since submissions update frequently)\n    const progressCacheKey = cacheKey(\"assignment-progress\", assignmentId, targetUserId);\n\n    const progress = await cachedFetch(\n        progressCacheKey,\n        async () => {\n            // Fetch successful submissions for these problems by the user\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: targetUserId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\"\n                },\n                select: {\n                    problemId: true\n                },\n                distinct: [\"problemId\"]\n            });\n\n            const solvedProblemIds = new Set(submissions.map(s => s.problemId));\n\n            const progressMap: Record<string, boolean> = {};\n            let completedCount = 0;\n\n            assignment.problems.forEach(p => {\n                const isSolved = solvedProblemIds.has(p.problemId);\n                progressMap[p.problemId] = isSolved;\n                if (isSolved) completedCount++;\n            });\n\n            return {\n                total: assignment.problems.length,\n                completed: completedCount,\n                progressMap\n            };\n        },\n        CACHE_CONFIG.SHORT.ttl // 30 seconds cache\n    );\n\n    return progress;\n}\n\n/**\n * Teacher Analytics: Get progress of all students in a classroom for a specific assignment (CACHED)\n */\nexport async function getTeacherAssignmentAnalytics(\n    assignmentId: string,\n    classroomId: string,\n    page: number = 1,\n    limit: number = 50\n) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const skip = (page - 1) * limit;\n    const analyticsCacheKey = cacheKey(\"assignment-analytics\", assignmentId, classroomId, String(page));\n\n    const analytics = await cachedFetch(\n        analyticsCacheKey,\n        async () => {\n            // Parallel fetch for better performance\n            const [classroom, assignment, totalStudents] = await Promise.all([\n                prisma.classroom.findUnique({\n                    where: { id: classroomId },\n                    select: {\n                        students: {\n                            select: {\n                                id: true,\n                                name: true,\n                                image: true,\n                                email: true\n                            },\n                            skip,\n                            take: limit,\n                        }\n                    }\n                }),\n                prisma.assignment.findUnique({\n                    where: { id: assignmentId },\n                    include: {\n                        problems: {\n                            select: { problemId: true }\n                        }\n                    }\n                }),\n                prisma.user.count({\n                    where: {\n                        enrolledClassrooms: {\n                            some: { id: classroomId }\n                        }\n                    }\n                })\n            ]);\n\n            if (!classroom || !assignment) return null;\n\n            const studentIds = classroom.students.map(s => s.id);\n            const problemIds = assignment.problems.map(p => p.problemId);\n\n            // Get all accepted submissions in one query\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: { in: studentIds },\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\"\n                },\n                select: {\n                    userId: true,\n                    problemId: true\n                }\n            });\n\n            // Build submission index for O(1) lookup\n            const submissionIndex = new Map<string, Set<string>>();\n            submissions.forEach(s => {\n                if (!submissionIndex.has(s.userId)) {\n                    submissionIndex.set(s.userId, new Set());\n                }\n                submissionIndex.get(s.userId)!.add(s.problemId);\n            });\n\n            // Build analytics\n            const studentAnalytics = classroom.students.map(student => {\n                const solvedSet = submissionIndex.get(student.id) || new Set();\n\n                return {\n                    student,\n                    completedCount: solvedSet.size,\n                    totalCount: problemIds.length,\n                    completionPercentage: problemIds.length > 0\n                        ? (solvedSet.size / problemIds.length) * 100\n                        : 0,\n                    hasCompletedAll: solvedSet.size === problemIds.length\n                };\n            });\n\n            return {\n                analytics: studentAnalytics,\n                pagination: {\n                    total: totalStudents,\n                    pages: Math.ceil(totalStudents / limit),\n                    current: page,\n                    limit\n                }\n            };\n        },\n        CACHE_CONFIG.MEDIUM.ttl // 2 minutes cache\n    );\n\n    return analytics;\n}\n\n/**\n * Delete an assignment\n */\nexport async function deleteAssignment(assignmentId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"TEACHER\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const assignment = await prisma.assignment.findUnique({\n            where: { id: assignmentId },\n            include: {\n                classroom: {\n                    select: { teacherId: true, id: true }\n                }\n            }\n        });\n\n        if (!assignment || assignment.classroom.teacherId !== session.user.id) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        // Delete assignment problems first, then assignment\n        await prisma.$transaction([\n            prisma.assignmentProblem.deleteMany({\n                where: { assignmentId }\n            }),\n            prisma.assignment.delete({\n                where: { id: assignmentId }\n            })\n        ]);\n\n        // Invalidate caches\n        revalidateTag(`assignment-${assignmentId}`, \"max\");\n        revalidateTag(`assignments-classroom-${assignment.classroom.id}`, \"max\");\n        revalidateTag('assignments-all', \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Delete assignment error:\", error);\n        return { success: false, error: \"Failed to delete assignment\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2247, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/core/services/problem.service.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 300; // 5 minutes\nconst PROBLEM_CACHE_TTL = 3600; // 1 hour\n\n// CACHE KEY HELPERS\nconst getProblemsCacheKey = (type: ProblemType, domain: ProblemDomain, page: number, diff?: Difficulty, tags: string[] = []) =>\n    `problems:list:${domain}:${type}:page:${page}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`;\nconst getAdminProblemsCacheKey = (domain: string | undefined, page: number) =>\n    `admin:problems:${domain || 'all'}:page:${page}`;\nconst getProblemCacheKey = (slug: string) => `problem:${slug}`;\n\nexport class ProblemService {\n\n    // CACHED FETCHER FOR PUBLIC PROBLEM LIST\n    private static async getCachedProblems(page: number, pageSize: number, type: ProblemType, domain: ProblemDomain = \"DSA\", diff?: Difficulty, tags: string[] = [], cursor?: string) {\n        // We use page for cache key primarily, but if cursor is used, it's for infinite scroll which often is bypass-cache or unique key\n        const cacheKey = cursor\n            ? `problems:list:${domain}:${type}:cursor:${cursor}:pageSize:${pageSize}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`\n            : getProblemsCacheKey(type, domain, page, diff, tags);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const query: any = {\n            where: {\n                type,\n                domain,\n                difficulty: diff,\n                hidden: false,\n                tags: tags.length > 0 ? {\n                    some: {\n                        slug: { in: tags }\n                    }\n                } : undefined\n            },\n            take: pageSize,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        };\n\n        if (cursor) {\n            query.cursor = { id: cursor };\n            query.skip = 1; // Skip the item already fetched\n        } else {\n            query.skip = (page - 1) * pageSize;\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany(query),\n            prisma.problem.count({\n                where: {\n                    type,\n                    domain,\n                    difficulty: diff,\n                    hidden: false,\n                    tags: tags.length > 0 ? {\n                        some: {\n                            slug: { in: tags }\n                        }\n                    } : undefined\n                }\n            })\n        ]);\n\n        const result = { problems, total };\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // GETTING PUBLIC PROBLEMS\n    static async getProblems(\n        page: number = 1,\n        pageSize: number = 10,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string,\n        diff?: Difficulty,\n        tags: string[] = [],\n        cursor?: string\n    ) {\n        // FETCHING PUBLIC DATA (CACHED)\n        const { problems, total } = await this.getCachedProblems(page, pageSize, type, domain, diff, tags, cursor);\n\n        // IF USER IS LOGGED IN, FETCHING THEIR SOLVED STATUS FOR THESE SPECIFIC PROBLEMS\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map((p: any) => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        // MERGING DATA\n        const problemsWithStats = problems.map((p: any) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return {\n            problems: problemsWithStats,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n    }\n\n    // GETTING ADMIN PROBLEMS\n    static async getAdminProblems(\n        page: number = 1,\n        pageSize: number = 50,\n        domain?: ProblemDomain,\n        excludeDifficulty?: Difficulty,\n        type?: ProblemType\n    ) {\n        const cacheKey = getAdminProblemsCacheKey(domain, page);\n        // Note: cache key doesn't include excludeDifficulty which could be an issue if we vary it often,\n        // but for now only one usage pattern exists per page.\n        // Ideally we should append it to cache key but let's keep it simple as per plan.\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n                // If we have cached data, we might need to filter it manually if the cache key doesn't support variations\n                // But for now let's assume cache key strategy needs update if we want perfect caching.\n                // However, user just wants filtering. Let's bypass cache if we have specific filter or update cache key.\n                // Actually, let's just proceed with fetching fresh if we use filters or rely on the query.\n                // Given the current cache implementation is simple, let's just do the query.\n\n                // return JSON.parse(cached); // Disabling cache return for filtered requests for safety or we update key\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const skip = (page - 1) * pageSize;\n        const where: any = domain ? { domain } : {};\n\n        if (type) {\n            where.type = type;\n        } else {\n            where.type = { not: \"CONTEST\" };\n        }\n\n        if (excludeDifficulty) {\n            where.difficulty = { not: excludeDifficulty };\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany({\n                where,\n                skip,\n                take: pageSize,\n                orderBy: { createdAt: 'desc' },\n                select: {\n                    id: true,\n                    title: true,\n                    slug: true,\n                    difficulty: true,\n                    hidden: true,\n                    score: true,\n                    type: true,\n                    domain: true,\n                    createdAt: true,\n                    updatedAt: true,\n                }\n            }),\n            prisma.problem.count({ where })\n        ]);\n\n        const result = {\n            problems,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // SEARCHING FOR PROBLEMS\n    static async searchProblems(\n        term: string,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string\n    ) {\n        const problems = await prisma.problem.findMany({\n            where: {\n                type,\n                domain,\n                hidden: false,\n                title: {\n                    contains: term,\n                    mode: 'insensitive'\n                }\n            },\n            take: 10,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        });\n\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map(p => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        const problemsWithStats = problems.map((p) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return { problems: problemsWithStats };\n    }\n\n    // CACHED FETCHER FOR SINGLE PROBLEM\n    private static async getCachedProblem(slug: string) {\n        const cacheKey = getProblemCacheKey(slug);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const problem = await prisma.problem.findUnique({\n            where: { slug },\n            include: {\n                testCases: true,\n                user: { select: { name: true, image: true } },\n                tags: { select: { name: true, slug: true } },\n                functionTemplates: true // Include for DSA function template boilerplates\n            }\n        });\n\n        if (problem) {\n            try {\n                await redis.setex(cacheKey, PROBLEM_CACHE_TTL, JSON.stringify(problem));\n            } catch (error) {\n                console.error(\"Redis set error:\", error);\n            }\n        }\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY SLUG CACHED\n    static async getProblem(slug: string) {\n        const problem = await this.getCachedProblem(slug);\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY ID\n    static async getProblemById(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({\n                where: { id },\n                include: {\n                    testCases: true,\n                    tags: { select: { name: true, slug: true } },\n                    functionTemplates: true\n                }\n            });\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to get problem by id:\", error);\n            return { success: false, error: \"Failed to get problem by id\" };\n        }\n    }\n\n    // GETTING NEXT PROBLEM\n    static async getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const nextProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        lt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'desc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return nextProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get next problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING PREVIOUS PROBLEM\n    static async getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const prevProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        gt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'asc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return prevProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get previous problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING RANDOM PROBLEM\n    static async getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n        try {\n           // efficient random selection using raw query or count-based skip\n           const count = await prisma.problem.count({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               }\n           });\n\n           if (count === 0) return null;\n\n           const skip = Math.floor(Math.random() * count);\n           const randomProblem = await prisma.problem.findFirst({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               },\n               skip,\n               select: {\n                   slug: true\n               }\n           });\n\n           return randomProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get random problem:\", error);\n            return null;\n        }\n    }\n\n    // CREATING A PROBLEM\n    static async createProblem(data: {\n        title: string;\n        description: string;\n        difficulty: Difficulty;\n        slug: string;\n        hidden: boolean;\n        hiddenQuery?: string | null;\n        domain?: ProblemDomain;\n        testCases: { input: string; output: string; hidden?: boolean }[];\n        tags?: string[];\n        useFunctionTemplate?: boolean;\n        functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n        solution?: string | null;\n    }) {\n        try {\n            const problem = await prisma.problem.create({\n                data: {\n                    title: data.title,\n                    description: data.description,\n                    difficulty: data.difficulty,\n                    slug: data.slug,\n                    score: 10,\n                    hidden: data.hidden,\n                    hiddenQuery: data.hiddenQuery || null,\n                    domain: data.domain || \"DSA\",\n                    useFunctionTemplate: data.useFunctionTemplate || false,\n                    solution: data.solution || null,\n                    testCases: {\n                        create: data.testCases.map(tc => ({\n                            input: tc.input,\n                            output: tc.output,\n                            hidden: tc.hidden ?? false\n                        }))\n                    },\n                    tags: data.tags ? {\n                        connect: data.tags.map(slug => ({ slug }))\n                    } : undefined,\n                    // Create function templates if provided and enabled\n                    functionTemplates: data.useFunctionTemplate && data.functionTemplates?.length ? {\n                        create: data.functionTemplates.map(ft => ({\n                            languageId: ft.languageId,\n                            functionTemplate: ft.functionTemplate,\n                            driverCode: ft.driverCode,\n                        }))\n                    } : undefined\n                },\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n\n            return { success: true, problem };\n        } catch (error) {\n            console.error(\"Failed to create problem:\", error);\n            return { success: false, error: \"Failed to create problem\" };\n        }\n    }\n\n    // UPDATING A PROBLEM\n    static async updateProblem(id: string, data: any) {\n        try {\n            const { testCases, tags, functionTemplates, ...problemData } = data;\n\n            const updateData: any = { ...problemData };\n            if (testCases) {\n                updateData.testCases = {\n                    deleteMany: {},\n                    create: testCases.map((tc: any) => ({\n                        input: tc.input,\n                        output: tc.output,\n                        hidden: tc.hidden ?? false\n                    }))\n                };\n            }\n\n            if (tags) {\n                updateData.tags = {\n                    set: [], // Disconnect all existing\n                    connect: tags.map((slug: string) => ({ slug }))\n                };\n            }\n\n            // Handle function templates\n            if (functionTemplates !== undefined) {\n                updateData.functionTemplates = {\n                    deleteMany: {}, // Delete all existing templates\n                    create: functionTemplates.map((ft: any) => ({\n                        languageId: ft.languageId,\n                        functionTemplate: ft.functionTemplate,\n                        driverCode: ft.driverCode,\n                    }))\n                };\n            }\n\n            // UPDATING THE PROBLEM\n            const problem = await prisma.problem.update({\n                where: { id },\n                data: updateData\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            await redis.del(getProblemCacheKey(problem.slug));\n            // Also invalidate function template cache\n            await redis.del(`problem-templates:${id}`);\n\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to update problem:\", error);\n            return { success: false, error: \"Failed to update problem\" };\n        }\n    }\n\n    // DELETING A PROBLEM\n    static async deleteProblem(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({ where: { id }, select: { slug: true } });\n\n            await prisma.problem.delete({\n                where: { id }\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            if (problem) {\n                await redis.del(getProblemCacheKey(problem.slug));\n            }\n\n            // RETURNING THE SUCCESS\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to delete problem:\", error);\n            return { success: false, error: \"Failed to delete problem\" };\n        }\n    }\n\n    private static async invalidateProblemCaches() {\n        const cachePattern = \"problems:list:*\";\n        const keys = await redis.keys(cachePattern);\n        if (keys.length > 0) {\n            await redis.del(...keys);\n        }\n        const adminCachePattern = \"admin:problems:*\";\n        const adminKeys = await redis.keys(adminCachePattern);\n        if (adminKeys.length > 0) {\n            await redis.del(...adminKeys);\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/problems.ts"],"sourcesContent":["\"use server\";\n\nimport { ProblemService } from \"@/core/services/problem.service\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING PUBLIC PROBLEMS\n\nexport async function getProblems(\n    page: number = 1,\n    pageSize: number = 10,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\",\n    difficulty?: Difficulty,\n    tags?: string[],\n    cursor?: string\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `problems-${domain}-${type}${difficulty ? `-${difficulty}` : ''}${tags && tags.length > 0 ? `-${tags.join('-')}` : ''}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-list', `problems-${domain}-${type}`);\n\n    return ProblemService.getProblems(page, pageSize, type, domain, userId, difficulty, tags || [], cursor);\n}\n\n// GETTING ADMIN PROBLEMS\n\nexport async function getAdminProblems(\n    page: number = 1,\n    pageSize: number = 50,\n    domain?: ProblemDomain,\n    excludeDifficulty?: Difficulty,\n    type?: ProblemType\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const tagKey = `admin-problems-${domain || 'all'}${excludeDifficulty ? `-exclude-${excludeDifficulty}` : ''}${type ? `-type-${type}` : ''}-page-${page}`;\n    cacheTag(tagKey, 'admin-problems-list');\n\n    return ProblemService.getAdminProblems(page, pageSize, domain, excludeDifficulty, type);\n}\n\n// SEARCHING FOR PROBLEMS\n\nexport async function searchProblems(\n    term: string,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\"\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes for search results\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `search-${domain}-${type}-${term.toLowerCase().slice(0, 20)}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-search');\n\n    return ProblemService.searchProblems(term, type, domain, userId);\n}\n\n// GETTING A PROBLEM BY SLUG CACHED\n\nexport async function getProblem(slug: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-${slug}`, 'problems-list');\n\n    return ProblemService.getProblem(slug);\n}\n\n\n// CREATING A PROBLEM --> ADMIN ONLY\n\nexport async function createProblem(data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    domain?: ProblemDomain;\n    testCases: { input: string; output: string; hidden?: boolean }[];\n    tags?: string[];\n    useFunctionTemplate?: boolean;\n    functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n    solution?: string | null;\n}) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.createProblem(data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(\"/admin/problems\");\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag('problems-SQL-PRACTICE');\n        updateTag('problems-DSA-PRACTICE');\n    }\n\n    return result;\n}\n\n\n// GETTING A PROBLEM BY ID\nexport async function getProblemById(id: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-id-${id}`, 'problems-list');\n\n    return ProblemService.getProblemById(id);\n}\n\n// NAVIGATION ACTIONS\n\nexport async function getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getNextProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getPreviousProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n    // No cache for random\n    return ProblemService.getRandomProblem(domain, type);\n}\n\n\n// UPDATING A PROBLEM --> ADMIN ONLY\nexport async function updateProblem(id: string, data: any) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.updateProblem(id, data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag(`problems-${result.data?.domain || 'DSA'}-${result.data?.type || 'PRACTICE'}`);\n        updateTag(`problem-${result.data?.slug}`);\n    }\n\n    return result;\n}\n\n\n// DELETING A PROBLEM --> ADMIN ONLY\nexport async function deleteProblem(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.deleteProblem(id);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n    }\n\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3119, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28main%29/dashboard/classrooms/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80b7c88da10d3a194c1170a71124e07c2947bd3a4a'} from 'ACTIONS_MODULE1'\nexport {$$RSC_SERVER_CACHE_0 as 'c0aedadb2987fc5c1995746b3ab4b358510ee91b21'} from 'ACTIONS_MODULE2'\nexport {getStudentClassrooms as '000ec191d293cb8cc90e57828e017864626cb92ee5'} from 'ACTIONS_MODULE3'\nexport {getTeacherClassrooms as '00d1b81d9172745f1e621bc00389a4047839aa9a65'} from 'ACTIONS_MODULE3'\nexport {joinClassroom as '402b2dfd9102ab55714da1b45943219de73e571e8e'} from 'ACTIONS_MODULE3'\nexport {createClassroom as '403750cd613b34ea87612c7694cf246e6b79128ea4'} from 'ACTIONS_MODULE3'\nexport {getClassroomByCode as '4062742210455aba21be245a7b93cd6f55cbfccfbb'} from 'ACTIONS_MODULE3'\nexport {getClassroomLiveTracking as '40cf2b7d8360449612784b56c4ebe4adc7f8e41e41'} from 'ACTIONS_MODULE3'\nexport {getInstitutionClassrooms as '60ba5514d1cabf3d740ffa8f4168ee127042974be0'} from 'ACTIONS_MODULE3'\nexport {toggleClassroomTracking as '60edb317f160a76e4bb511111cff02ad646382fb68'} from 'ACTIONS_MODULE3'\nexport {removeStudentFromClassroom as '60f68b6b6de74b348b326d1abc2051c2a16b2617c9'} from 'ACTIONS_MODULE3'\nexport {getClassroomWithStudents as '7088643fe9948b5d44e935d70bd04124cc9fb572ff'} from 'ACTIONS_MODULE3'\nexport {removeStudentFromClassroom as '60f68b6b6de74b348b326d1abc2051c2a16b2617c9'} from 'ACTIONS_MODULE3'\nexport {getClassroomLiveTracking as '40cf2b7d8360449612784b56c4ebe4adc7f8e41e41'} from 'ACTIONS_MODULE3'\nexport {toggleClassroomTracking as '60edb317f160a76e4bb511111cff02ad646382fb68'} from 'ACTIONS_MODULE3'\nexport {getClassroomAssignments as '70b22c8ab63d11fc3b25b267ea271300db7487dcaa'} from 'ACTIONS_MODULE4'\nexport {refreshClassroomAssignments as '402d498415f6e7ce5e7b14101bd742a174c034fe89'} from 'ACTIONS_MODULE4'\nexport {createAssignment as '604eabe0422d89d8eae28e459c0dae2ed6d7bab8fe'} from 'ACTIONS_MODULE4'\nexport {searchProblems as 'f01f5ef9ed6223b56ddc1153abce0acfbc57475009'} from 'ACTIONS_MODULE5'\nexport {getTeacherAssignmentAnalytics as '78073ece8699c8e6f210ef2e8915c5f3d914d87a4a'} from 'ACTIONS_MODULE4'\n"],"names":[],"mappings":";AAAA;AAEA;AACA;AACA;AAaA;AAGA"}}]
}