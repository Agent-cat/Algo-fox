{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAgcsB,6BAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA2WsB,4BAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/tag.action.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\n\nexport async function searchTags(query: string) {\n    try {\n        const tags = await prisma.tag.findMany({\n            where: {\n                name: {\n                    contains: query,\n                    mode: \"insensitive\",\n                },\n            },\n            take: 10,\n            orderBy: {\n                name: 'asc'\n            }\n        });\n\n        return { success: true, tags };\n    } catch (error) {\n        console.error(\"Failed to search tags:\", error);\n        return { success: false, error: \"Failed to search tags\" };\n    }\n}\n\nexport async function createTag(name: string) {\n    try {\n        const slug = name\n            .toLowerCase()\n            .trim()\n            .replace(/[^\\w\\s-]/g, \"\")\n            .replace(/[\\s_-]+/g, \"-\")\n            .replace(/^-+|-+$/g, \"\");\n\n        const tag = await prisma.tag.upsert({\n            where: { slug },\n            update: {},\n            create: {\n                name,\n                slug,\n            },\n        });\n\n        return { success: true, tag };\n    } catch (error) {\n        console.error(\"Failed to create tag:\", error);\n        return { success: false, error: \"Failed to create tag\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAIsB,aAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/tag.action.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\n\nexport async function searchTags(query: string) {\n    try {\n        const tags = await prisma.tag.findMany({\n            where: {\n                name: {\n                    contains: query,\n                    mode: \"insensitive\",\n                },\n            },\n            take: 10,\n            orderBy: {\n                name: 'asc'\n            }\n        });\n\n        return { success: true, tags };\n    } catch (error) {\n        console.error(\"Failed to search tags:\", error);\n        return { success: false, error: \"Failed to search tags\" };\n    }\n}\n\nexport async function createTag(name: string) {\n    try {\n        const slug = name\n            .toLowerCase()\n            .trim()\n            .replace(/[^\\w\\s-]/g, \"\")\n            .replace(/[\\s_-]+/g, \"-\")\n            .replace(/^-+|-+$/g, \"\");\n\n        const tag = await prisma.tag.upsert({\n            where: { slug },\n            update: {},\n            create: {\n                name,\n                slug,\n            },\n        });\n\n        return { success: true, tag };\n    } catch (error) {\n        console.error(\"Failed to create tag:\", error);\n        return { success: false, error: \"Failed to create tag\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA0BsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/admin/TagInput.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { X, Search, Loader2, Plus } from \"lucide-react\";\nimport { searchTags, createTag } from \"@/actions/tag.action\";\nimport { toast } from \"sonner\";\n\n\n\ninterface Tag {\n    slug: string;\n    name: string;\n}\n\ninterface TagInputProps {\n    value: Tag[];\n    onChange: (tags: Tag[]) => void;\n    placeholder?: string;\n}\n\nexport function TagInput({ value, onChange, placeholder = \"Search or create tags...\" }: TagInputProps) {\n    const [inputValue, setInputValue] = useState(\"\");\n    const [suggestions, setSuggestions] = useState<Tag[]>([]);\n    const [isSearching, setIsSearching] = useState(false);\n    const [isCreating, setIsCreating] = useState(false);\n    const [showSuggestions, setShowSuggestions] = useState(false);\n    const wrapperRef = useRef<HTMLDivElement>(null);\n\n    // Debounce logic\n    useEffect(() => {\n        const timer = setTimeout(() => {\n            if (inputValue.trim()) {\n                handleSearch(inputValue);\n            } else {\n                setSuggestions([]);\n            }\n        }, 300);\n\n        return () => clearTimeout(timer);\n    }, [inputValue]);\n\n    // Click outside to close\n    useEffect(() => {\n        function handleClickOutside(event: MouseEvent) {\n            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) {\n                setShowSuggestions(false);\n            }\n        }\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, []);\n\n    const handleSearch = async (query: string) => {\n        setIsSearching(true);\n        const res = await searchTags(query);\n        if (res.success && res.tags) {\n            // Filter out already selected tags\n            const selectedSlugs = new Set(value.map(t => t.slug));\n            setSuggestions(res.tags.filter(t => !selectedSlugs.has(t.slug)));\n        }\n        setIsSearching(false);\n        setShowSuggestions(true);\n    };\n\n    const handleSelectTag = (tag: Tag) => {\n        onChange([...value, tag]);\n        setInputValue(\"\");\n        setSuggestions([]);\n        setShowSuggestions(false);\n    };\n\n    const handleRemoveTag = (slug: string) => {\n        onChange(value.filter(t => t.slug !== slug));\n    };\n\n    const handleCreateTag = async () => {\n        if (!inputValue.trim()) return;\n        setIsCreating(true);\n        const res = await createTag(inputValue);\n        setIsCreating(false);\n\n        if (res.success && res.tag) {\n            handleSelectTag(res.tag);\n            toast.success(`Tag \"${res.tag.name}\" created`);\n        } else {\n            toast.error(\"Failed to create tag\");\n        }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n        if (e.key === 'Enter') {\n            e.preventDefault();\n            if (suggestions.length > 0) {\n                handleSelectTag(suggestions[0]);\n            } else if (inputValue.trim()) {\n                handleCreateTag();\n            }\n        }\n    };\n\n    return (\n        <div className=\"space-y-3\" ref={wrapperRef}>\n            <div className=\"flex flex-wrap gap-2\">\n                {value.map((tag) => (\n                    <span\n                        key={tag.slug}\n                        className=\"inline-flex items-center gap-1 px-3 py-1 bg-orange-50 text-orange-700 rounded-full text-sm font-medium border border-orange-100\"\n                    >\n                        {tag.name}\n                        <button\n                            type=\"button\"\n                            onClick={() => handleRemoveTag(tag.slug)}\n                            className=\"ml-2\"\n                        >\n                            <X className=\"w-3 h-3\" />\n                        </button>\n                    </span>\n                ))}\n            </div>\n\n            <div className=\"relative\">\n                <div className=\"absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none\">\n                    <Search className=\"h-4 w-4 text-gray-400\" />\n                </div>\n                <input\n                    type=\"text\"\n                    value={inputValue}\n                    onChange={(e) => {\n                        setInputValue(e.target.value);\n                        setShowSuggestions(true);\n                    }}\n                    onFocus={() => {\n                        if (inputValue.trim()) setShowSuggestions(true);\n                    }}\n                    onKeyDown={handleKeyDown}\n                    className=\"w-full pl-10 pr-4 py-3 border border-gray-300 dark:border-[#333] rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all placeholder:text-gray-400 dark:placeholder:text-gray-600 bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white\"\n                    placeholder={placeholder}\n                />\n\n                {/* Suggestions Dropdown */}\n                {showSuggestions && inputValue.trim() && (\n                    <div className=\"absolute z-50 mt-1 w-full bg-white dark:bg-[#1a1a1a] rounded-lg shadow-xl border border-gray-100 dark:border-[#333] max-h-60 overflow-y-auto\">\n                        {isSearching ? (\n                            <div className=\"p-4 text-center text-gray-400 text-sm flex items-center justify-center gap-2\">\n                                <Loader2 className=\"w-4 h-4 animate-spin\" /> Searching...\n                            </div>\n                        ) : (\n                            <div className=\"py-1\">\n                                {suggestions.map((tag) => (\n                                    <button\n                                        key={tag.slug}\n                                        type=\"button\"\n                                        onClick={() => handleSelectTag(tag)}\n                                        className=\"w-full text-left px-4 py-2 hover:bg-orange-50 dark:hover:bg-[#262626] text-gray-700 dark:text-gray-300 text-sm transition-colors flex items-center justify-between group\"\n                                    >\n                                        <span>{tag.name}</span>\n                                        <Plus className=\"w-3 h-3 opacity-0 group-hover:opacity-100 text-orange-500\" />\n                                    </button>\n                                ))}\n\n                                {suggestions.length === 0 && (\n                                    <button\n                                        type=\"button\"\n                                        onClick={handleCreateTag}\n                                        className=\"w-full text-left px-4 py-3 hover:bg-orange-50 dark:hover:bg-[#262626] text-orange-600 dark:text-orange-400 text-sm transition-colors flex items-center gap-2 border-t border-gray-50 dark:border-[#262626] font-medium\"\n                                    >\n                                        <Plus className=\"w-4 h-4\" />\n                                        Create \"{inputValue}\"\n                                        {isCreating && <Loader2 className=\"w-3 h-3 animate-spin ml-auto\" />}\n                                    </button>\n                                )}\n                            </div>\n                        )}\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/languages.ts"],"sourcesContent":["\nexport interface Language {\n    id: number; // Judge0 ID\n    name: string;\n    monacoLanguage: string; // Monaco Editor language identifier\n    boilerplate: string;\n}\n\nexport const LANGUAGES: Language[] = [\n    {\n        id: 63,\n        name: \"JavaScript\",\n        monacoLanguage: \"javascript\",\n        boilerplate: `const fs = require(\"fs\");\n\nconst input = fs.readFileSync(0, \"utf8\").trim().split(/\\\\s+/);\n\n// write your code here\n\nconsole.log();`\n    },\n\n    {\n        id: 62,\n        name: \"Java\",\n        monacoLanguage: \"java\",\n        boilerplate: `import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        // write your code here\n\n        \n    }\n}`\n    },\n\n    {\n        id: 71,\n        name: \"Python\",\n        monacoLanguage: \"python\",\n        boilerplate: `import sys\n\ndata = sys.stdin.read().split()\n\n# write your code here\n\nprint()`\n    },\n\n    {\n        id: 50,\n        name: \"C\",\n        monacoLanguage: \"c\",\n        boilerplate: `#include <stdio.h>\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 54,\n        name: \"C++\",\n        monacoLanguage: \"cpp\",\n        boilerplate: `#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 73,\n        name: \"Rust\",\n        monacoLanguage: \"rust\",\n        boilerplate: `use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    // write your code here\n}`\n    },\n\n    {\n        id: 60,\n        name: \"Go\",\n        monacoLanguage: \"go\",\n        boilerplate: `package main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    in := bufio.NewReader(os.Stdin)\n\n    // write your code here\n\n}`\n    },\n    {\n        id: 82,\n        name: \"SQL\",\n        monacoLanguage: \"sql\",\n        boilerplate: `` // Empty boilerplate for SQL\n    }\n];\n\nexport function getLanguageById(id: number): Language | undefined {\n    return LANGUAGES.find(lang => lang.id === id);\n}\n\nexport function getLanguageByName(name: string): Language | undefined {\n    return LANGUAGES.find(lang => lang.name === name);\n}\n\nexport const DEFAULT_LANGUAGE_ID = 63;\n\n"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,YAAwB;IACjC;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;cAMR,CAAC;IACX;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;CASrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;OAMf,CAAC;IACJ;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;CAQrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;;;;CAYrB,CAAC;IACE;IACA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,EAAE,CAAC,4BAA4B;IAChD;CACH;AAEM,SAAS,gBAAgB,EAAU;IACtC,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;AAC9C;AAEO,SAAS,kBAAkB,IAAY;IAC1C,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;AAChD;AAEO,MAAM,sBAAsB"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/admin/FunctionTemplateEditor.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport Editor from \"@monaco-editor/react\";\nimport { ChevronDown, ChevronRight, Loader2, Copy, Check } from \"lucide-react\";\nimport { LANGUAGES } from \"@/lib/languages\";\nimport { useTheme } from \"next-themes\";\n\n// DSA languages only (exclude SQL which has id 82)\nconst DSA_LANGUAGES = LANGUAGES.filter(lang => lang.id !== 82);\n\nexport interface FunctionTemplate {\n    languageId: number;\n    functionTemplate: string;\n    driverCode: string;\n}\n\ninterface FunctionTemplateEditorProps {\n    value: FunctionTemplate[];\n    onChange: (templates: FunctionTemplate[]) => void;\n    useFunctionTemplate: boolean;\n    onUseFunctionTemplateChange: (use: boolean) => void;\n}\n\nexport default function FunctionTemplateEditor({\n    value,\n    onChange,\n    useFunctionTemplate,\n    onUseFunctionTemplateChange,\n}: FunctionTemplateEditorProps) {\n    const [expandedLanguages, setExpandedLanguages] = useState<Set<number>>(new Set());\n    const [copiedFrom, setCopiedFrom] = useState<number | null>(null);\n    const { theme, systemTheme } = useTheme();\n    const currentTheme = theme === 'system' ? systemTheme : theme;\n    const isDark = currentTheme === 'dark';\n\n    // Create a map for quick lookup\n    const templateMap = useMemo(() => {\n        const map = new Map<number, FunctionTemplate>();\n        value.forEach(t => map.set(t.languageId, t));\n        return map;\n    }, [value]);\n\n    const toggleLanguage = (langId: number) => {\n        setExpandedLanguages(prev => {\n            const next = new Set(prev);\n            if (next.has(langId)) {\n                next.delete(langId);\n            } else {\n                next.add(langId);\n            }\n            return next;\n        });\n    };\n\n    const updateTemplate = (languageId: number, field: \"functionTemplate\" | \"driverCode\", newValue: string) => {\n        const existing = templateMap.get(languageId);\n        const updated: FunctionTemplate = existing\n            ? { ...existing, [field]: newValue }\n            : { languageId, functionTemplate: \"\", driverCode: \"\", [field]: newValue };\n\n        const newTemplates = value.filter(t => t.languageId !== languageId);\n        newTemplates.push(updated);\n        onChange(newTemplates);\n    };\n\n    const getTemplate = (languageId: number): FunctionTemplate => {\n        return templateMap.get(languageId) || { languageId, functionTemplate: \"\", driverCode: \"\" };\n    };\n\n    const copyToAllLanguages = (sourceLanguageId: number) => {\n        const source = getTemplate(sourceLanguageId);\n        if (!source.functionTemplate && !source.driverCode) return;\n\n        const newTemplates: FunctionTemplate[] = DSA_LANGUAGES.map(lang => ({\n            languageId: lang.id,\n            functionTemplate: source.functionTemplate,\n            driverCode: source.driverCode,\n        }));\n\n        onChange(newTemplates);\n        setCopiedFrom(sourceLanguageId);\n        setTimeout(() => setCopiedFrom(null), 2000);\n    };\n\n    const hasContent = (languageId: number): boolean => {\n        const t = getTemplate(languageId);\n        return !!(t.functionTemplate || t.driverCode);\n    };\n\n    return (\n        <div className=\"space-y-6\">\n            {/* Mode Toggle */}\n            <div className=\"bg-gray-50 dark:bg-[#141414] rounded-xl p-4 border border-gray-200 dark:border-[#262626]\">\n                <div className=\"flex items-center gap-4\">\n                    <button\n                        type=\"button\"\n                        onClick={() => onUseFunctionTemplateChange(false)}\n                        className={`flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-all border-2 ${!useFunctionTemplate\n                            ? \"bg-white dark:bg-[#1a1a1a] border-orange-500 text-orange-700 dark:text-orange-400 shadow-sm\"\n                            : \"bg-transparent border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-[#1a1a1a]\"\n                            }`}\n                    >\n                        <div className=\"flex flex-col items-center gap-1\">\n                            <span className=\"font-semibold\">Use Default</span>\n                            <span className=\"text-xs opacity-75\">Standard boilerplate code</span>\n                        </div>\n                    </button>\n                    <button\n                        type=\"button\"\n                        onClick={() => onUseFunctionTemplateChange(true)}\n                        className={`flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-all border-2 ${useFunctionTemplate\n                            ? \"bg-white dark:bg-[#1a1a1a] border-orange-500 text-orange-700 dark:text-orange-400 shadow-sm\"\n                            : \"bg-transparent border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-[#1a1a1a]\"\n                            }`}\n                    >\n                        <div className=\"flex flex-col items-center gap-1\">\n                            <span className=\"font-semibold\">Use Function</span>\n                            <span className=\"text-xs opacity-75\">Custom function template + driver</span>\n                        </div>\n                    </button>\n                </div>\n            </div>\n\n            {/* Function Template Editor (shown when useFunctionTemplate is true) */}\n            {useFunctionTemplate && (\n                <div className=\"space-y-3\">\n                    <div className=\"flex items-center justify-between\">\n                        <h3 className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">\n                            Language Templates\n                        </h3>\n                        <span className=\"text-xs text-gray-500 dark:text-gray-400\">\n                            Define function signature and driver code for each language\n                        </span>\n                    </div>\n\n                    {/* Language Accordion */}\n                    <div className=\"border border-gray-200 dark:border-[#262626] rounded-xl overflow-hidden\">\n                        {DSA_LANGUAGES.map((lang, idx) => {\n                            const isExpanded = expandedLanguages.has(lang.id);\n                            const template = getTemplate(lang.id);\n                            const hasTemplateContent = hasContent(lang.id);\n\n                            return (\n                                <div key={lang.id} className={idx > 0 ? \"border-t border-gray-200 dark:border-[#262626]\" : \"\"}>\n                                    {/* Language Header */}\n                                    <div className=\"w-full flex items-center justify-between px-4 py-3 bg-gray-50 dark:bg-[#1a1a1a] hover:bg-gray-100 dark:hover:bg-[#202020] transition-colors\">\n                                        <button\n                                            type=\"button\"\n                                            onClick={() => toggleLanguage(lang.id)}\n                                            className=\"flex items-center gap-3 flex-1\"\n                                        >\n                                            {isExpanded ? (\n                                                <ChevronDown className=\"w-4 h-4 text-gray-500 dark:text-gray-400\" />\n                                            ) : (\n                                                <ChevronRight className=\"w-4 h-4 text-gray-500 dark:text-gray-400\" />\n                                            )}\n                                            <span className=\"font-medium text-gray-700 dark:text-gray-200\">{lang.name}</span>\n                                            {hasTemplateContent && (\n                                                <span className=\"px-2 py-0.5 bg-green-100 dark:bg-green-500/10 text-green-700 dark:text-green-400 text-xs rounded-full font-medium\">\n                                                    Configured\n                                                </span>\n                                            )}\n                                        </button>\n                                        {isExpanded && hasTemplateContent && (\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => copyToAllLanguages(lang.id)}\n                                                className=\"flex items-center gap-1.5 px-2 py-1 text-xs font-medium text-gray-600 dark:text-gray-400 hover:text-orange-600 dark:hover:text-orange-400 hover:bg-orange-50 dark:hover:bg-orange-500/10 rounded transition-colors\"\n                                            >\n                                                {copiedFrom === lang.id ? (\n                                                    <>\n                                                        <Check className=\"w-3 h-3\" />\n                                                        Copied!\n                                                    </>\n                                                ) : (\n                                                    <>\n                                                        <Copy className=\"w-3 h-3\" />\n                                                        Copy to all\n                                                    </>\n                                                )}\n                                            </button>\n                                        )}\n                                    </div>\n\n                                    {/* Language Content */}\n                                    {isExpanded && (\n                                        <div className=\"p-4 bg-white dark:bg-[#141414] space-y-4\">\n                                            {/* Function Template */}\n                                            <div className=\"space-y-2\">\n                                                <label className=\"block text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wide\">\n                                                    Function Template\n                                                    <span className=\"font-normal text-gray-400 dark:text-gray-500 ml-2\">\n                                                        (What user sees as boilerplate)\n                                                    </span>\n                                                </label>\n                                                <div className=\"border border-gray-200 dark:border-[#333] rounded-lg overflow-hidden h-40\">\n                                                    <Editor\n                                                        height=\"100%\"\n                                                        language={lang.monacoLanguage}\n                                                        value={template.functionTemplate}\n                                                        theme={isDark ? \"vs-dark\" : \"vs-light\"}\n                                                        onChange={(val) => updateTemplate(lang.id, \"functionTemplate\", val || \"\")}\n                                                        options={{\n                                                            minimap: { enabled: false },\n                                                            fontSize: 13,\n                                                            lineNumbers: \"on\",\n                                                            scrollBeyondLastLine: false,\n                                                            automaticLayout: true,\n                                                            padding: { top: 8 },\n                                                        }}\n                                                        loading={\n                                                            <div className=\"flex items-center justify-center h-full\">\n                                                                <Loader2 className=\"w-5 h-5 text-orange-500 animate-spin\" />\n                                                            </div>\n                                                        }\n                                                    />\n                                                </div>\n                                            </div>\n\n                                            {/* Driver Code */}\n                                            <div className=\"space-y-2\">\n                                                <label className=\"block text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wide\">\n                                                    Driver Code\n                                                    <span className=\"font-normal text-gray-400 dark:text-gray-500 ml-2\">\n                                                        (Hidden - calls user&apos;s function)\n                                                    </span>\n                                                </label>\n                                                <div className=\"border border-gray-200 dark:border-[#333] rounded-lg overflow-hidden h-48\">\n                                                    <Editor\n                                                        height=\"100%\"\n                                                        language={lang.monacoLanguage}\n                                                        value={template.driverCode}\n                                                        theme={isDark ? \"vs-dark\" : \"vs-light\"}\n                                                        onChange={(val) => updateTemplate(lang.id, \"driverCode\", val || \"\")}\n                                                        options={{\n                                                            minimap: { enabled: false },\n                                                            fontSize: 13,\n                                                            lineNumbers: \"on\",\n                                                            scrollBeyondLastLine: false,\n                                                            automaticLayout: true,\n                                                            padding: { top: 8 },\n                                                        }}\n                                                        loading={\n                                                            <div className=\"flex items-center justify-center h-full\">\n                                                                <Loader2 className=\"w-5 h-5 text-orange-500 animate-spin\" />\n                                                            </div>\n                                                        }\n                                                    />\n                                                </div>\n                                                <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                                                    This code wraps the user&apos;s implementation. Include input parsing and function call.\n                                                </p>\n                                            </div>\n                                        </div>\n                                    )}\n                                </div>\n                            );\n                        })}\n                    </div>\n\n                    {/* Helper tip */}\n                    <div className=\"bg-blue-50 dark:bg-blue-500/10 border border-blue-200 dark:border-blue-500/20 rounded-lg p-3\">\n                        <p className=\"text-xs text-blue-700 dark:text-blue-300\">\n                            <strong>Tip:</strong> Define the function signature in &quot;Function Template&quot; and the I/O handling in &quot;Driver Code&quot;.\n                            When running, the system combines: <code className=\"bg-blue-100 dark:bg-blue-500/20 px-1 rounded\">driver code + user&apos;s function</code>\n                        </p>\n                    </div>\n                </div>\n            )}\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 963, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/admin/ProblemForm.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Difficulty, ProblemDomain } from \"@prisma/client\";\nimport { toast } from \"sonner\";\nimport { useRouter } from \"next/navigation\";\nimport { Plus, Trash2, Eye, EyeOff } from \"lucide-react\";\nimport { useForm, useFieldArray } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport * as z from \"zod\";\nimport { TagInput } from \"./TagInput\";\nimport FunctionTemplateEditor, { FunctionTemplate } from \"./FunctionTemplateEditor\";\n\n\n// FUNCTION TAMPLATE SCHEMA\nconst functionTemplateSchema = z.object({\n    languageId: z.number(),\n    functionTemplate: z.string(),\n    driverCode: z.string(),\n});\n\n\n// FORM SCHEMA\nconst formSchema = z.object({\n    title: z.string().min(1, \"Title is required\"),\n    slug: z.string().min(1, \"Slug is required\"),\n    description: z.string().min(1, \"Description is required\"),\n    difficulty: z.nativeEnum(Difficulty),\n    hidden: z.boolean(),\n    hiddenQuery: z.string().optional().nullable(),\n    tags: z.array(z.string()).optional(),\n    testCases: z.array(z.object({\n        input: z.string(), // Optional for SQL\n        output: z.string().min(1, \"Output is required\"),\n        hidden: z.boolean().optional()\n    })).min(1, \"At least one test case is required\"),\n    useFunctionTemplate: z.boolean().optional(),\n    functionTemplates: z.array(functionTemplateSchema).optional(),\n    solution: z.string().optional().nullable(),\n});\n\ntype FormValues = z.infer<typeof formSchema>;\n\n// PROPS INTERFACE\ninterface ProblemFormProps {\n    initialData?: Omit<Partial<FormValues>, \"tags\"> & {\n        tags?: { name: string; slug: string }[];\n        useFunctionTemplate?: boolean;\n        functionTemplates?: FunctionTemplate[];\n    };\n    onSubmit: (data: any) => Promise<{ success: boolean; error?: string }>;\n    submitLabel: string;\n    domain?: ProblemDomain;\n    redirectPath?: string;\n}\n\nexport default function ProblemForm({ initialData, onSubmit, submitLabel, domain = \"DSA\", redirectPath }: ProblemFormProps) {\n    const [isLoading, setIsLoading] = useState(false);\n    const [currentStep, setCurrentStep] = useState(1);\n    const [selectedTags, setSelectedTags] = useState<{ name: string, slug: string }[]>(initialData?.tags || []);\n\n    //FUNCTION TAMPLATE (DSA ONLY)\n    const [useFunctionTemplate, setUseFunctionTemplate] = useState(initialData?.useFunctionTemplate || false);\n    const [functionTemplates, setFunctionTemplates] = useState<FunctionTemplate[]>(initialData?.functionTemplates || []);\n\n    // Sync state with initialData updates (crucial for edit mode)\n    useEffect(() => {\n        if (initialData?.useFunctionTemplate !== undefined) {\n            setUseFunctionTemplate(initialData.useFunctionTemplate);\n        }\n        if (initialData?.functionTemplates) {\n            setFunctionTemplates(initialData.functionTemplates);\n        }\n    }, [initialData]);\n\n    const router = useRouter();\n\n    // NUMBER OF STEPS BASED ON DOMAIN\n    const isDSA = domain === \"DSA\";\n    const totalSteps = isDSA ? 5 : 4;\n\n    const { register, control, handleSubmit, watch, setValue, trigger, formState: { errors } } = useForm<FormValues>({\n        resolver: zodResolver(formSchema),\n        defaultValues: {\n            title: initialData?.title || \"\",\n            slug: initialData?.slug || \"\",\n            description: initialData?.description || \"\",\n            difficulty: initialData?.difficulty || \"EASY\",\n            hidden: initialData?.hidden || false,\n            hiddenQuery: initialData?.hiddenQuery || \"\",\n            testCases: initialData?.testCases?.length ? initialData.testCases : [{ input: \"\", output: \"\", hidden: false }],\n            tags: initialData?.tags?.map(t => t.slug) || [],\n            useFunctionTemplate: initialData?.useFunctionTemplate || false,\n            functionTemplates: initialData?.functionTemplates || [],\n            solution: initialData?.solution || \"\",\n        }\n    });\n\n    const { fields, append, remove } = useFieldArray({\n        control,\n        name: \"testCases\"\n    });\n\n    const hiddenValue = watch(\"hidden\");\n\n    // BUILD STEPS ARRAY BASED ON DOMAIN\n    const steps = isDSA\n        ? [\n            { id: 1, name: \"Basic Details\" },\n            { id: 2, name: \"Description\" },\n            { id: 3, name: \"Solution\" },\n            { id: 4, name: \"Test Cases\" },\n            { id: 5, name: \"Code Templates\" }\n        ]\n        : [\n            { id: 1, name: \"Basic Details\" },\n            { id: 2, name: \"Description\" },\n            { id: 3, name: \"Solution\" },\n            { id: 4, name: \"Test Cases\" }\n        ];\n\n    // NEXT STEP HANDLER\n    const handleNext = async (e?: React.MouseEvent<HTMLButtonElement>) => {\n        e?.preventDefault();\n        e?.stopPropagation();\n\n        let isValid = false;\n        if (currentStep === 1) {\n            isValid = await trigger([\"title\", \"slug\", \"difficulty\"]);\n        } else if (currentStep === 2) {\n            isValid = await trigger([\"description\"]);\n        } else if (currentStep === 3) {\n            isValid = await trigger([\"solution\"]);\n        } else if (currentStep === 4) {\n            isValid = await trigger([\"testCases\"]);\n        } else {\n            isValid = true; // Step 5 (templates) has no required validation\n        }\n\n        if (isValid && currentStep < totalSteps) {\n            setCurrentStep(prev => prev + 1);\n        }\n    };\n\n    const handleBack = () => {\n        setCurrentStep(prev => prev - 1);\n    };\n\n    // ON SUBMIT\n    async function onSubmitForm(data: FormValues) {\n\n        if (isLoading) return;\n        setIsLoading(true);\n\n        const submissionData = {\n            ...data,\n            hidden: data.hidden,\n            hiddenQuery: domain === \"SQL\" ? (data.hiddenQuery?.trim() || null) : null,\n            domain,\n            tags: selectedTags.map(t => t.slug),\n            useFunctionTemplate: isDSA ? useFunctionTemplate : false,\n            functionTemplates: isDSA && useFunctionTemplate ? functionTemplates : [],\n        };\n\n        const res = await onSubmit(submissionData);\n\n        if (res.success) {\n            toast.success(\"Saved successfully\");\n            if (redirectPath !== undefined) {\n                router.push(redirectPath || \"/admin/problems\");\n                router.refresh();\n            }\n        } else {\n            toast.error(res.error || \"Something went wrong\");\n        }\n        setIsLoading(false);\n    }\n\n    return (\n        <div className=\"bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-2xl shadow-sm overflow-hidden\">\n            {/* Steps Header */}\n            <div className=\"border-b border-gray-100 dark:border-[#262626] bg-gray-50/50 dark:bg-[#1a1a1a] p-6\">\n                <div className=\"flex items-center justify-between max-w-2xl mx-auto\">\n                    {steps.map((step) => (\n                        <div key={step.id} className=\"flex items-center gap-3\">\n                            <div className={`\n                                w-8 h-8 rounded-full flex items-center justify-center text-sm font-semibold transition-colors\n                                ${currentStep >= step.id ? \"bg-orange-600 text-white\" : \"bg-gray-200 dark:bg-[#333] text-gray-500 dark:text-gray-400\"}\n                            `}>\n                                {step.id}                            </div>\n                            <span className={`text-sm font-medium ${currentStep >= step.id ? \"text-gray-900 dark:text-white\" : \"text-gray-400 dark:text-gray-600\"}`}>\n                                {step.name}\n                            </span>\n                            {step.id < totalSteps && <div className=\"w-12 h-0.5 bg-gray-200 mx-2\" />}\n                        </div>\n                    ))}\n                </div>\n            </div>\n\n            <form onSubmit={handleSubmit(onSubmitForm)} className=\"p-8\">\n                {/* Step 1: Basics */}\n                {currentStep === 1 && (\n                    <div className=\"space-y-6 max-w-2xl mx-auto animation-fade-in\">\n                        <div className=\"space-y-2\">\n                            <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Problem Title</label>\n                            <input\n                                {...register(\"title\")}\n                                placeholder=\"e.g. Two Sum\"\n                                className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all placeholder:text-gray-400 dark:placeholder:text-gray-600 font-medium text-gray-900 dark:text-white bg-white dark:bg-[#0a0a0a]\"\n                            />\n                            {errors.title && <p className=\"text-xs text-red-500\">{errors.title.message}</p>}\n                        </div>\n\n                        <div className=\"space-y-2\">\n                            <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Slug</label>\n                            <input\n                                {...register(\"slug\")}\n                                placeholder=\"e.g. two-sum\"\n                                className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all placeholder:text-gray-400 dark:placeholder:text-gray-600 font-medium text-gray-900 dark:text-white bg-white dark:bg-[#0a0a0a]\"\n                            />\n                            {errors.slug && <p className=\"text-xs text-red-500\">{errors.slug.message}</p>}\n                        </div>\n\n                        <div className={`grid gap-6 ${domain === \"SQL\" ? \"grid-cols-2\" : \"grid-cols-1\"}`}>\n                            <div className=\"space-y-2\">\n                                <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Difficulty</label>\n                                <select\n                                    {...register(\"difficulty\")}\n                                    className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all bg-white dark:bg-[#0a0a0a] font-medium text-gray-700 dark:text-gray-300\"\n                                >\n                                    <option value=\"EASY\">Easy</option>\n                                    <option value=\"MEDIUM\">Medium</option>\n                                    <option value=\"HARD\">Hard</option>\n                                </select>\n                            </div>\n\n                            <div className=\"space-y-2\">\n                                <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Tags</label>\n                                <TagInput\n                                    value={selectedTags}\n                                    onChange={(newTags) => {\n                                        setSelectedTags(newTags);\n                                        setValue(\"tags\", newTags.map(t => t.slug));\n                                    }}\n                                />\n                            </div>\n\n                            <div className=\"space-y-2\">\n                                <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Hidden</label>\n                                <div className=\"space-y-2 flex flex-col justify-end\">\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => setValue(\"hidden\", !hiddenValue)}\n                                        className={`w-full flex items-center justify-center gap-2 px-4 py-3 rounded-lg text-sm font-semibold transition-colors border ${hiddenValue\n                                            ? \"bg-gray-50 dark:bg-[#1a1a1a] text-gray-600 dark:text-gray-400 border-gray-200 dark:border-[#333]\"\n                                            : \"bg-green-50 dark:bg-green-500/10 text-green-700 dark:text-green-400 border-green-200 dark:border-green-500/20\"\n                                            }`}\n                                    >\n                                        {hiddenValue ? <EyeOff className=\"w-4 h-4\" /> : <Eye className=\"w-4 h-4\" />}\n                                        {hiddenValue ? \"Hidden Problem\" : \"Visible Problem\"}\n                                    </button>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                )}\n\n                {/* Step 2: Description */}\n                {currentStep === 2 && (\n                    <div className=\"space-y-4 max-w-4xl mx-auto animation-fade-in\">\n                        <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Description (Markdown)</label>\n                        <textarea\n                            {...register(\"description\")}\n                            rows={15}\n                            placeholder=\"# Problem Description...\"\n                            className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all font-mono text-sm leading-relaxed text-gray-900 dark:text-gray-100 bg-white dark:bg-[#0a0a0a] placeholder:text-gray-400 dark:placeholder:text-gray-600\"\n                        />\n                        {errors.description && <p className=\"text-xs text-red-500\">{errors.description.message}</p>}\n\n                        {/* Hidden Query field - only for SQL domain */}\n                        {domain === \"SQL\" && (\n                            <div className=\"space-y-2 mt-6\">\n                                <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">\n                                    Hidden Query (Optional)\n                                    <span className=\"text-xs text-gray-500 dark:text-gray-400 font-normal ml-2\">\n                                        This SQL query will be prepended to the user's code before execution\n                                    </span>\n                                </label>\n                                <textarea\n                                    {...register(\"hiddenQuery\")}\n                                    rows={5}\n                                    placeholder=\"-- e.g. CREATE TABLE temp_table AS SELECT * FROM ...\"\n                                    className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all font-mono text-sm leading-relaxed text-gray-900 dark:text-gray-100 bg-white dark:bg-[#0a0a0a]\"\n                                />\n                            </div>\n                        )}\n                    </div>\n                )}\n\n                {/* Step 3: Solution */}\n                {currentStep === 3 && (\n                    <div className=\"space-y-4 max-w-4xl mx-auto animation-fade-in\">\n                        <label className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Solution (Markdown)</label>\n                        <p className=\"text-xs text-gray-500 dark:text-gray-400 mb-2\">This solution will be visible only to users who have successfully solved the problem.</p>\n                        <textarea\n                            {...register(\"solution\")}\n                            rows={15}\n                            placeholder=\"# Detailed Solution...\"\n                            className=\"w-full px-4 py-3 rounded-lg border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 focus:ring-2 focus:ring-orange-100 dark:focus:ring-orange-500/10 outline-none transition-all font-mono text-sm leading-relaxed text-gray-900 dark:text-gray-100 bg-white dark:bg-[#0a0a0a]\"\n                        />\n                        {errors.solution && <p className=\"text-xs text-red-500\">{errors.solution.message}</p>}\n                    </div>\n                )}\n\n                {/* Step 4: Test Cases */}\n                {currentStep === 4 && (\n                    <div className=\"space-y-6 max-w-3xl mx-auto animation-fade-in\">\n                        <div className=\"flex items-center justify-between\">\n                            <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">Test Cases</h3>\n                            <button\n                                type=\"button\"\n                                onClick={() => append({ input: \"\", output: \"\", hidden: false })}\n                                className=\"flex items-center gap-2 px-3 py-1.5 text-orange-600 hover:bg-orange-50 rounded-lg text-sm font-medium transition-colors\"\n                            >\n                                <Plus className=\"w-4 h-4\" />\n                                Add Case\n                            </button>\n                        </div>\n\n                        <div className=\"space-y-4\">\n                            {fields.map((field, index) => (\n                                <div key={field.id} className=\"flex gap-4 p-4 border border-gray-100 dark:border-[#262626] rounded-xl bg-gray-50/50 dark:bg-[#1a1a1a] hover:border-orange-200 dark:hover:border-orange-500/30 transition-colors\">\n                                    <div className=\"flex-1 space-y-2\">\n                                        <label className=\"text-xs font-medium text-gray-500 dark:text-gray-400\">\n                                            INPUT {domain === \"SQL\" && <span className=\"text-[10px] font-normal opacity-70 ml-1\">(OPTIONAL)</span>}\n                                        </label>\n                                        <textarea\n                                            {...register(`testCases.${index}.input` as const)}\n                                            className=\"w-full px-3 py-2 rounded-md border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 outline-none text-sm font-mono bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100\"\n                                            rows={2}\n                                        />\n                                    </div>\n                                    <div className=\"flex-1 space-y-2\">\n                                        <label className=\"text-xs font-medium text-gray-500\">OUTPUT</label>\n                                        <textarea\n                                            {...register(`testCases.${index}.output` as const)}\n                                            className=\"w-full px-3 py-2 rounded-md border border-gray-200 dark:border-[#333] focus:border-orange-500 dark:focus:border-orange-500 outline-none text-sm font-mono bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100\"\n                                            rows={2}\n                                        />\n                                    </div>\n                                    <div className=\"flex flex-col gap-2 pt-6 items-center\">\n                                        <label className=\"flex items-center gap-2 cursor-pointer group\" title=\"Hidden Test Case\">\n                                            <input\n                                                type=\"checkbox\"\n                                                {...register(`testCases.${index}.hidden` as const)}\n                                                className=\"w-4 h-4 rounded border-gray-300 dark:border-[#444] text-orange-600 focus:ring-orange-500 dark:bg-[#0a0a0a] cursor-pointer\"\n                                            />\n                                            <span className=\"text-xs text-gray-500 dark:text-gray-400 font-medium group-hover:text-gray-700 dark:group-hover:text-gray-200 transition-colors\">Hidden</span>\n                                        </label>\n                                        <button type=\"button\" onClick={() => remove(index)} className=\"p-2 text-gray-400 hover:text-red-500 transition-colors\">\n                                            <Trash2 className=\"w-4 h-4\" />\n                                        </button>\n                                    </div>\n                                </div>\n                            ))}\n                            {errors.testCases && <p className=\"text-xs text-red-500\">{errors.testCases.root?.message || \"Invalid test cases\"}</p>}\n                        </div>\n                    </div>\n                )}\n\n                {/* Step 5: Code Templates (DSA only) */}\n                {isDSA && currentStep === 5 && (\n                    <div className=\"space-y-6 max-w-4xl mx-auto animation-fade-in\">\n                        <div className=\"mb-4\">\n                            <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">Code Templates</h3>\n                            <p className=\"text-sm text-gray-500 dark:text-gray-400\">Choose how users will start solving this problem.</p>\n                        </div>\n                        <FunctionTemplateEditor\n                            value={functionTemplates}\n                            onChange={setFunctionTemplates}\n                            useFunctionTemplate={useFunctionTemplate}\n                            onUseFunctionTemplateChange={setUseFunctionTemplate}\n                        />\n                    </div>\n                )}\n\n                {/* Footer Actions */}\n                <div className=\"mt-8 pt-6 border-t border-gray-100 dark:border-[#262626] flex justify-between\">\n                    <button\n                        type=\"button\"\n                        onClick={handleBack}\n                        disabled={currentStep === 1}\n                        className=\"px-6 py-2.5 rounded-lg text-sm font-medium text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] hover:text-gray-900 dark:hover:text-white disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n                    >\n                        Back\n                    </button>\n\n                    {currentStep < totalSteps ? (\n                        <button\n                            type=\"button\"\n                            onClick={handleNext}\n                            className=\"px-6 py-2.5 rounded-lg bg-gray-900 dark:bg-white text-white dark:text-gray-900 text-sm font-medium hover:bg-gray-800 dark:hover:bg-gray-200 transition-colors\"\n                        >\n                            Next Step\n                        </button>\n                    ) : (\n                        <button\n                            type=\"submit\"\n                            disabled={isLoading}\n                            className=\"px-8 py-2.5 rounded-lg bg-orange-600 text-white text-sm font-bold hover:bg-orange-700 transition-colors disabled:opacity-70 flex items-center gap-2\"\n                        >\n                            {isLoading ? \"Saving...\" : submitLabel}\n                        </button>\n                    )}\n                </div>\n            </form>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1841, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/CreateContestWizard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useForm } from \"react-hook-form\";\nimport { useState, useEffect } from \"react\";\nimport {\n    Loader2, X, Trophy, Calendar, Users,\n    Globe, School, BookOpen, Plus, CheckCircle2, Layers,\n    ChevronRight, ChevronLeft, Image, FileText, Award, Settings,\n    Code, Database, Eye, EyeOff\n} from \"lucide-react\";\nimport { toast } from \"sonner\";\nimport { createContest, getInstitutionalClassrooms, createContestWithProblems } from \"@/actions/contest\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport * as z from \"zod\";\nimport { useRouter } from \"next/navigation\";\nimport ProblemForm from \"@/components/admin/ProblemForm\";\nimport { ProblemDomain } from \"@prisma/client\";\n\n// Extended contest schema with new fields\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\").regex(/^[a-z0-9-]+$/, \"Slug can only contain lowercase letters, numbers, and hyphens\"),\n    description: z.string().optional(),\n    startTime: z.string().min(1, \"Start time is required\"),\n    endTime: z.string().min(1, \"End time is required\"),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean(),\n    classroomId: z.string().optional(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.object({\n        id: z.string(),\n        title: z.string(),\n        domain: z.enum([\"DSA\", \"SQL\"]),\n    })).optional(), // Optional in schema, validated manually on step 3\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\ntype FormData = z.infer<typeof contestSchema>;\n\ninterface ContestProblem {\n    id: string;\n    title: string;\n    domain: \"DSA\" | \"SQL\";\n    data: any; // Full problem data\n}\n\ninterface CreateContestWizardProps {\n    institutionId: string | null;\n    userId: string;\n    userRole: string;\n}\n\nexport function CreateContestWizard({ institutionId, userId, userRole }: CreateContestWizardProps) {\n    const router = useRouter();\n    const [currentStep, setCurrentStep] = useState(1);\n    const [isLoading, setIsLoading] = useState(false);\n    const [classrooms, setClassrooms] = useState<any[]>([]);\n    const [contestProblems, setContestProblems] = useState<ContestProblem[]>([]);\n    const [showProblemForm, setShowProblemForm] = useState<\"DSA\" | \"SQL\" | null>(null);\n    const [isCreatingProblem, setIsCreatingProblem] = useState(false);\n\n    const { register, handleSubmit, watch, setValue, trigger, formState: { errors } } = useForm<FormData>({\n        resolver: zodResolver(contestSchema) as any,\n        defaultValues: {\n            title: \"\",\n            slug: \"\",\n            description: \"\",\n            startTime: \"\",\n            endTime: \"\",\n            visibility: userRole === \"CONTEST_MANAGER\" ? (institutionId ? \"INSTITUTION\" : \"CLASSROOM\") : \"PUBLIC\",\n            hidden: false,\n            classroomId: \"\",\n            backgroundImage: \"\",\n            prizes: \"\",\n            rules: \"\",\n            problems: [],\n        } as Partial<FormData>,\n        mode: \"onBlur\",\n        reValidateMode: \"onChange\",\n    });\n\n    const visibility = watch(\"visibility\");\n    const isHidden = watch(\"hidden\");\n    const isContestManager = userRole === \"CONTEST_MANAGER\";\n\n    // Fetch classrooms if institution visibility or classroom visibility is selected\n    useEffect(() => {\n        if (institutionId && (visibility === \"CLASSROOM\" || visibility === \"INSTITUTION\")) {\n            getInstitutionalClassrooms(institutionId).then(res => {\n                if (res.success) setClassrooms(res.classrooms || []);\n            });\n        }\n    }, [visibility, institutionId]);\n\n    // Auto-generate slug from title\n    const title = watch(\"title\");\n    useEffect(() => {\n        if (title && currentStep === 1) {\n            const autoSlug = title\n                .toLowerCase()\n                .replace(/[^a-z0-9]+/g, \"-\")\n                .replace(/^-+|-+$/g, \"\");\n            setValue(\"slug\", autoSlug);\n        }\n    }, [title, currentStep, setValue]);\n\n    const handleProblemSubmit = async (data: any, domain: \"DSA\" | \"SQL\") => {\n        setIsCreatingProblem(true);\n        try {\n            // Create a temporary problem object (will be saved when contest is created)\n            const problemId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            const newProblem: ContestProblem = {\n                id: problemId,\n                title: data.title,\n                domain,\n                data: { ...data, domain },\n            };\n            setContestProblems(prev => [...prev, newProblem]);\n            setValue(\"problems\", [...contestProblems, newProblem].map(p => ({ id: p.id, title: p.title, domain: p.domain })));\n            setShowProblemForm(null);\n            toast.success(`${domain} problem added successfully!`);\n        } catch (error) {\n            toast.error(\"Failed to add problem\");\n        } finally {\n            setIsCreatingProblem(false);\n        }\n    };\n\n    const removeProblem = (problemId: string) => {\n        const updated = contestProblems.filter(p => p.id !== problemId);\n        setContestProblems(updated);\n        setValue(\"problems\", updated.map(p => ({ id: p.id, title: p.title, domain: p.domain })));\n    };\n\n    const handleNext = async (e: React.FormEvent) => {\n        e.preventDefault();\n\n        if (currentStep === 1) {\n            const isValid = await trigger([\"title\", \"slug\", \"startTime\", \"endTime\"]);\n            if (!isValid) {\n                toast.error(\"Please fill in all required fields\");\n                return;\n            }\n            setCurrentStep(2);\n        } else if (currentStep === 2) {\n            const fields: (keyof FormData)[] = [\"visibility\"];\n            if (visibility === \"CLASSROOM\") {\n                fields.push(\"classroomId\");\n            }\n            const isValid = await trigger(fields);\n            if (!isValid) {\n                toast.error(\"Please complete all required fields\");\n                return;\n            }\n            setCurrentStep(3);\n        }\n    };\n\n    const onSubmit = async (data: FormData) => {\n        // Only submit on final step\n        if (currentStep < 3) {\n            return;\n        }\n\n        // Validate problems on final step\n        if (contestProblems.length === 0) {\n            toast.error(\"Please add at least one problem\");\n            return;\n        }\n\n        setIsLoading(true);\n        try {\n            const res = await createContestWithProblems({\n                ...data,\n                startTime: new Date(data.startTime),\n                endTime: new Date(data.endTime),\n                institutionId: visibility !== \"PUBLIC\" ? institutionId : null,\n                problems: contestProblems.map(p => p.data),\n            });\n\n            if (res.success) {\n                toast.success(\"Contest created successfully!\");\n                router.push(`/contest/${res.contestId}`);\n            } else {\n                toast.error(res.error || \"Failed to create contest\");\n            }\n        } catch (error) {\n            toast.error(\"Something went wrong\");\n        } finally {\n            setIsLoading(false);\n        }\n    };\n\n    const steps = [\n        { id: 1, name: \"General Details\", icon: BookOpen },\n        { id: 2, name: \"Customization & Rules\", icon: Settings },\n        { id: 3, name: \"Problem Management\", icon: Layers },\n    ];\n\n    return (\n        <div className=\"max-w-5xl mx-auto\">\n            {/* Problem Form Modal - Outside main form to avoid nested forms */}\n            {showProblemForm && (\n                <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto\">\n                    <div className=\"bg-white dark:bg-[#141414] rounded-2xl shadow-2xl max-w-4xl w-full my-8 relative max-h-[90vh] overflow-y-auto border border-gray-200 dark:border-[#262626]\">\n                        <div className=\"sticky top-0 bg-white dark:bg-[#141414] border-b border-gray-200 dark:border-[#262626] p-6 flex items-center justify-between z-10 rounded-t-2xl\">\n                            <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">Create {showProblemForm} Problem</h2>\n                            <button\n                                type=\"button\"\n                                onClick={() => setShowProblemForm(null)}\n                                className=\"text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors p-2 hover:bg-gray-100 dark:hover:bg-[#1a1a1a] rounded-lg\"\n                            >\n                                <X className=\"w-5 h-5\" />\n                            </button>\n                        </div>\n                        <div className=\"p-6\">\n                            <ProblemForm\n                                onSubmit={async (data) => {\n                                    if (showProblemForm) {\n                                        await handleProblemSubmit(data, showProblemForm);\n                                    }\n                                    return { success: true };\n                                }}\n                                submitLabel={`Add ${showProblemForm} Problem`}\n                                domain={showProblemForm}\n                                redirectPath={undefined}\n                            />\n                        </div>\n                    </div>\n                </div>\n            )}\n\n            {/* Progress Steps */}\n            <div className=\"mb-8\">\n                <div className=\"flex items-center justify-between\">\n                    {steps.map((step, index) => {\n                        const Icon = step.icon;\n                        const isActive = currentStep === step.id;\n                        const isCompleted = currentStep > step.id;\n                        return (\n                            <div key={step.id} className=\"flex items-center flex-1\">\n                                <div className=\"flex flex-col items-center flex-1\">\n                                    <div className={`w-12 h-12 rounded-full flex items-center justify-center border-2 transition-all ${isActive ? \"border-orange-500 bg-orange-50 dark:bg-orange-500/10 text-orange-600\" :\n                                            isCompleted ? \"border-green-500 bg-green-50 dark:bg-green-500/10 text-green-600\" :\n                                                \"border-gray-300 dark:border-[#333] bg-white dark:bg-[#1a1a1a] text-gray-400\"\n                                        }`}>\n                                        <Icon className=\"w-6 h-6\" />\n                                    </div>\n                                    <span className={`mt-2 text-sm font-medium ${isActive ? \"text-orange-600\" :\n                                            isCompleted ? \"text-green-600\" :\n                                                \"text-gray-400\"\n                                        }`}>\n                                        {step.name}\n                                    </span>\n                                </div>\n                                {index < steps.length - 1 && (\n                                    <div className={`flex-1 h-0.5 mx-4 ${isCompleted ? \"bg-green-500\" : \"bg-gray-300 dark:bg-[#333]\"\n                                        }`} />\n                                )}\n                            </div>\n                        );\n                    })}\n                </div>\n            </div>\n\n            <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-6\">\n                {/* Step 1: General Details */}\n                {currentStep === 1 && (\n                    <div className=\"bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-lg p-6 space-y-6\">\n                        <h2 className=\"text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                            <BookOpen className=\"w-5 h-5 text-orange-600\" />\n                            General Details\n                        </h2>\n\n                        <div className=\"grid grid-cols-1 gap-6\">\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Contest Name</label>\n                                <input\n                                    {...register(\"title\")}\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all text-gray-900 dark:text-white\"\n                                    placeholder=\"e.g. Weekly DSA Challenge #1\"\n                                />\n                                {errors.title && <p className=\"text-xs text-red-500 mt-1\">{errors.title.message}</p>}\n                            </div>\n\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Custom Contest URL (Slug)</label>\n                                <input\n                                    {...register(\"slug\")}\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all font-mono text-sm text-gray-900 dark:text-white\"\n                                    placeholder=\"weekly-dsa-challenge-1\"\n                                />\n                                {errors.slug && <p className=\"text-xs text-red-500 mt-1\">{errors.slug.message}</p>}\n                                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">URL will be: /contest/your-slug</p>\n                            </div>\n\n                            <div className=\"grid grid-cols-2 gap-4\">\n                                <div>\n                                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Start Time</label>\n                                    <div className=\"relative\">\n                                        <input\n                                            type=\"datetime-local\"\n                                            {...register(\"startTime\")}\n                                            className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all text-gray-900 dark:text-white scheme-light dark:scheme-dark\"\n                                        />\n                                        <Calendar className=\"absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400 pointer-events-none\" />\n                                    </div>\n                                    {errors.startTime && <p className=\"text-xs text-red-500 mt-1\">{errors.startTime.message}</p>}\n                                </div>\n                                <div>\n                                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">End Time</label>\n                                    <div className=\"relative\">\n                                        <input\n                                            type=\"datetime-local\"\n                                            {...register(\"endTime\")}\n                                            className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all text-gray-900 dark:text-white scheme-light dark:scheme-dark\"\n                                        />\n                                        <Calendar className=\"absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400 pointer-events-none\" />\n                                    </div>\n                                    {errors.endTime && <p className=\"text-xs text-red-500 mt-1\">{errors.endTime.message}</p>}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                )}\n\n                {/* Step 2: Customization & Rules */}\n                {currentStep === 2 && (\n                    <div className=\"bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-lg p-6 space-y-6\">\n                        <h2 className=\"text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                            <Settings className=\"w-5 h-5 text-orange-600\" />\n                            Customization & Rules\n                        </h2>\n\n                        <div className=\"space-y-6\">\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center gap-2\">\n                                    <Image className=\"w-4 h-4\" />\n                                    Landing Page Background Image URL\n                                </label>\n                                <input\n                                    {...register(\"backgroundImage\")}\n                                    type=\"url\"\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all text-gray-900 dark:text-white\"\n                                    placeholder=\"https://example.com/image.jpg\"\n                                />\n                            </div>\n\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center gap-2\">\n                                    <FileText className=\"w-4 h-4\" />\n                                    Rich Text Description (Markdown)\n                                </label>\n                                <textarea\n                                    {...register(\"description\")}\n                                    rows={8}\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all resize-none font-mono text-sm text-gray-900 dark:text-white\"\n                                    placeholder=\"Describe the contest, topics covered, and any important information...\"\n                                />\n                            </div>\n\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center gap-2\">\n                                    <Award className=\"w-4 h-4\" />\n                                    Prizes\n                                </label>\n                                <textarea\n                                    {...register(\"prizes\")}\n                                    rows={4}\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all resize-none text-gray-900 dark:text-white\"\n                                    placeholder=\"List prizes, rewards, or recognition for winners...\"\n                                />\n                            </div>\n\n                            <div>\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center gap-2\">\n                                    <FileText className=\"w-4 h-4\" />\n                                    Rules\n                                </label>\n                                <textarea\n                                    {...register(\"rules\")}\n                                    rows={6}\n                                    className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all resize-none text-gray-900 dark:text-white\"\n                                    placeholder=\"Contest rules, guidelines, and scoring logic...\"\n                                />\n                            </div>\n\n                            {/* Visibility Settings */}\n                            <div className=\"border-t border-gray-200 dark:border-[#262626] pt-6\">\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-4\">Contest Visibility</label>\n                                <div className=\"flex items-center gap-4\">\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => setValue(\"hidden\", false)}\n                                        className={`flex items-center gap-2 px-4 py-2 rounded-lg border-2 transition-all ${!isHidden\n                                                ? 'border-orange-500 bg-orange-50 dark:bg-orange-500/10 text-orange-700 dark:text-orange-400'\n                                                : 'border-gray-200 dark:border-[#333] bg-white dark:bg-[#1a1a1a] text-gray-600 dark:text-gray-400 hover:border-gray-300 dark:hover:border-[#444]'\n                                            }`}\n                                    >\n                                        <Eye className=\"w-4 h-4\" />\n                                        <span className=\"font-medium\">Visible</span>\n                                    </button>\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => setValue(\"hidden\", true)}\n                                        className={`flex items-center gap-2 px-4 py-2 rounded-lg border-2 transition-all ${isHidden\n                                                ? 'border-orange-500 bg-orange-50 dark:bg-orange-500/10 text-orange-700 dark:text-orange-400'\n                                                : 'border-gray-200 dark:border-[#333] bg-white dark:bg-[#1a1a1a] text-gray-600 dark:text-gray-400 hover:border-gray-300 dark:hover:border-[#444]'\n                                            }`}\n                                    >\n                                        <EyeOff className=\"w-4 h-4\" />\n                                        <span className=\"font-medium\">Hidden</span>\n                                    </button>\n                                </div>\n                                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-2\">\n                                    {isHidden\n                                        ? \"Contest will be hidden from public view and only accessible to authorized users.\"\n                                        : \"Contest will be visible to the selected target audience.\"}\n                                </p>\n                            </div>\n\n                            {/* Target Audience */}\n                            <div className=\"border-t border-gray-200 dark:border-[#262626] pt-6\">\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-4\">Target Audience</label>\n                                <div className=\"space-y-3\">\n                                    {!isContestManager && (\n                                        <label className={`flex items-center gap-3 p-4 border-2 cursor-pointer transition-all rounded-lg ${visibility === 'PUBLIC' ? 'border-orange-500 bg-orange-50 dark:bg-orange-500/10' : 'border-gray-200 dark:border-[#333] hover:border-gray-300 dark:hover:border-[#444]'\n                                            }`}>\n                                            <input type=\"radio\" {...register(\"visibility\")} value=\"PUBLIC\" className=\"hidden\" />\n                                            <div className={`p-2 ${visibility === 'PUBLIC' ? 'bg-orange-600 text-white' : 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-500 dark:text-gray-400'} rounded`}>\n                                                <Globe className=\"w-4 h-4\" />\n                                            </div>\n                                            <div className=\"flex-1\">\n                                                <span className=\"block font-semibold text-gray-900 dark:text-white\">Public</span>\n                                                <span className=\"text-xs text-gray-500 dark:text-gray-400\">Visible to everyone</span>\n                                            </div>\n                                            {visibility === 'PUBLIC' && <CheckCircle2 className=\"w-5 h-5 text-orange-600\" />}\n                                        </label>\n                                    )}\n\n                                    {institutionId && (\n                                        <>\n                                            <label className={`flex items-center gap-3 p-4 border-2 cursor-pointer transition-all rounded-lg ${visibility === 'INSTITUTION' ? 'border-orange-500 bg-orange-50 dark:bg-orange-500/10' : 'border-gray-200 dark:border-[#333] hover:border-gray-300 dark:hover:border-[#444]'\n                                                }`}>\n                                                <input type=\"radio\" {...register(\"visibility\")} value=\"INSTITUTION\" className=\"hidden\" />\n                                                <div className={`p-2 ${visibility === 'INSTITUTION' ? 'bg-orange-600 text-white' : 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-500 dark:text-gray-400'} rounded`}>\n                                                    <School className=\"w-4 h-4\" />\n                                                </div>\n                                                <div className=\"flex-1\">\n                                                    <span className=\"block font-semibold text-gray-900 dark:text-white\">Entire Institute</span>\n                                                    <span className=\"text-xs text-gray-500 dark:text-gray-400\">Only for your organization</span>\n                                                </div>\n                                                {visibility === 'INSTITUTION' && <CheckCircle2 className=\"w-5 h-5 text-orange-600\" />}\n                                            </label>\n\n                                            <label className={`flex items-center gap-3 p-4 border-2 cursor-pointer transition-all rounded-lg ${visibility === 'CLASSROOM' ? 'border-orange-500 bg-orange-50 dark:bg-orange-500/10' : 'border-gray-200 dark:border-[#333] hover:border-gray-300 dark:hover:border-[#444]'\n                                                }`}>\n                                                <input type=\"radio\" {...register(\"visibility\")} value=\"CLASSROOM\" className=\"hidden\" />\n                                                <div className={`p-2 ${visibility === 'CLASSROOM' ? 'bg-orange-600 text-white' : 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-500 dark:text-gray-400'} rounded`}>\n                                                    <Users className=\"w-4 h-4\" />\n                                                </div>\n                                                <div className=\"flex-1\">\n                                                    <span className=\"block font-semibold text-gray-900 dark:text-white\">Specific Classroom</span>\n                                                    <span className=\"text-xs text-gray-500 dark:text-gray-400\">Target a single batch</span>\n                                                </div>\n                                                {visibility === 'CLASSROOM' && <CheckCircle2 className=\"w-5 h-5 text-orange-600\" />}\n                                            </label>\n                                        </>\n                                    )}\n                                </div>\n\n                                {visibility === \"CLASSROOM\" && (\n                                    <div className=\"pt-4\">\n                                        <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Select Classroom</label>\n                                        <select\n                                            {...register(\"classroomId\")}\n                                            className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all text-gray-900 dark:text-white\"\n                                        >\n                                            <option value=\"\" className=\"bg-white dark:bg-[#1a1a1a]\">Choose a classroom...</option>\n                                            {classrooms.map((c) => (\n                                                <option key={c.id} value={c.id} className=\"bg-white dark:bg-[#1a1a1a]\">\n                                                    {c.name} {c.section ? `(${c.section})` : \"\"}\n                                                </option>\n                                            ))}\n                                        </select>\n                                        {errors.classroomId && <p className=\"text-xs text-red-500 mt-1\">{errors.classroomId.message}</p>}\n                                    </div>\n                                )}\n                            </div>\n\n\n                            {/* Contest Security & Options */}\n                            <div className=\"border-t border-gray-200 dark:border-[#262626] pt-6\">\n                                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-4\">Security & Options</label>\n                                <div className=\"space-y-4\">\n                                    <div>\n                                        <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center gap-2\">\n                                            <span className=\"text-gray-900 dark:text-white\">Contest Password (Optional)</span>\n                                        </label>\n                                        <input\n                                            {...register(\"contestPassword\")}\n                                            type=\"text\"\n                                            className=\"w-full px-4 py-2 bg-white dark:bg-[#1a1a1a] border border-gray-300 dark:border-[#333] rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all font-mono text-sm text-gray-900 dark:text-white\"\n                                            placeholder=\"Enter a password to restrict access...\"\n                                        />\n                                        <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">If set, participants will need to enter this password to join.</p>\n                                    </div>\n\n                                    <div className=\"flex items-center gap-3\">\n                                        <input\n                                            type=\"checkbox\"\n                                            {...register(\"randomizeQuestions\")}\n                                            id=\"randomizeQuestions\"\n                                            className=\"w-4 h-4 text-orange-600 border-gray-300 dark:border-gray-600 rounded focus:ring-orange-500 bg-white dark:bg-[#0a0a0a]\"\n                                        />\n                                        <label htmlFor=\"randomizeQuestions\" className=\"text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer select-none\">\n                                            Randomize Question Order\n                                        </label>\n                                    </div>\n                                    <p className=\"text-xs text-gray-500 dark:text-gray-400 ml-7 -mt-3\">\n                                        If enabled, each participant will see questions in a different random order.\n                                    </p>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                )}\n\n                {/* Step 3: Problem Management */}\n                {currentStep === 3 && (\n                    <div className=\"bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-lg p-6 space-y-6\">\n                        <h2 className=\"text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                            <Layers className=\"w-5 h-5 text-orange-600\" />\n                            Problem Management\n                        </h2>\n                        <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                            Add problems exclusively for this contest. These problems will not appear in the public problem bank.\n                        </p>\n\n                        <div className=\"grid grid-cols-2 gap-4\">\n                            <button\n                                type=\"button\"\n                                onClick={() => setShowProblemForm(\"DSA\")}\n                                className=\"p-6 bg-white dark:bg-[#1a1a1a] border-2 border-gray-200 dark:border-[#333] rounded-lg hover:border-orange-500 dark:hover:border-orange-500 hover:bg-orange-50 dark:hover:bg-orange-500/10 transition-all text-left\"\n                            >\n                                <div className=\"flex items-center gap-3 mb-2\">\n                                    <div className=\"w-10 h-10 rounded-lg bg-orange-100 dark:bg-orange-500/20 text-orange-600 dark:text-orange-400 flex items-center justify-center\">\n                                        <Code className=\"w-5 h-5\" />\n                                    </div>\n                                    <h4 className=\"font-semibold text-gray-900 dark:text-white\">Add DSA Problem</h4>\n                                </div>\n                                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                                    Create a new DSA problem specifically for this contest\n                                </p>\n                            </button>\n\n                            <button\n                                type=\"button\"\n                                onClick={() => setShowProblemForm(\"SQL\")}\n                                className=\"p-6 bg-white dark:bg-[#1a1a1a] border-2 border-gray-200 dark:border-[#333] rounded-lg hover:border-blue-500 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-500/10 transition-all text-left\"\n                            >\n                                <div className=\"flex items-center gap-3 mb-2\">\n                                    <div className=\"w-10 h-10 rounded-lg bg-blue-100 dark:bg-blue-500/20 text-blue-600 dark:text-blue-400 flex items-center justify-center\">\n                                        <Database className=\"w-5 h-5\" />\n                                    </div>\n                                    <h4 className=\"font-semibold text-gray-900 dark:text-white\">Add SQL Problem</h4>\n                                </div>\n                                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                                    Create a new SQL problem specifically for this contest\n                                </p>\n                            </button>\n                        </div>\n\n                        {/* List of added problems */}\n                        {contestProblems.length > 0 && (\n                            <div className=\"border-t border-gray-200 dark:border-[#262626] pt-6\">\n                                <h3 className=\"text-sm font-semibold text-gray-700 dark:text-gray-300 mb-4\">\n                                    Added Problems ({contestProblems.length})\n                                </h3>\n                                <div className=\"space-y-2\">\n                                    {contestProblems.map((problem, index) => (\n                                        <div key={problem.id} className=\"flex items-center justify-between p-3 bg-gray-50 dark:bg-[#1a1a1a] border border-gray-200 dark:border-[#333] rounded-lg\">\n                                            <div className=\"flex items-center gap-3\">\n                                                <span className=\"w-6 h-6 flex items-center justify-center bg-white dark:bg-[#141414] border border-gray-300 dark:border-[#333] text-xs font-semibold text-gray-600 dark:text-gray-400 rounded\">\n                                                    {index + 1}\n                                                </span>\n                                                <div>\n                                                    <p className=\"font-semibold text-gray-900 dark:text-white text-sm\">{problem.title}</p>\n                                                    <span className={`text-xs font-semibold ${problem.domain === 'DSA' ? 'text-orange-600 dark:text-orange-400' : 'text-blue-600 dark:text-blue-400'\n                                                        }`}>\n                                                        {problem.domain}\n                                                    </span>\n                                                </div>\n                                            </div>\n                                            <button\n                                                type=\"button\"\n                                                onClick={() => removeProblem(problem.id)}\n                                                className=\"p-1.5 hover:bg-gray-200 dark:hover:bg-[#333] text-gray-400 hover:text-red-600 dark:hover:text-red-500 transition-colors rounded\"\n                                            >\n                                                <X className=\"w-4 h-4\" />\n                                            </button>\n                                        </div>\n                                    ))}\n                                </div>\n                            </div>\n                        )}\n\n                        {errors.problems && (\n                            <p className=\"text-xs text-red-500\">{errors.problems.message as string}</p>\n                        )}\n                    </div>\n                )}\n\n                {/* Navigation Buttons */}\n                <div className=\"flex items-center justify-between pt-6 border-t border-gray-200 dark:border-[#262626]\">\n                    <button\n                        type=\"button\"\n                        onClick={() => {\n                            if (currentStep > 1) {\n                                setCurrentStep(prev => prev - 1);\n                            } else {\n                                router.back();\n                            }\n                        }}\n                        className=\"flex items-center gap-2 px-6 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors\"\n                    >\n                        <ChevronLeft className=\"w-4 h-4\" />\n                        {currentStep === 1 ? \"Cancel\" : \"Previous\"}\n                    </button>\n\n                    <div className=\"flex items-center gap-2\">\n                        {currentStep < 3 ? (\n                            <button\n                                type=\"button\"\n                                onClick={handleNext}\n                                className=\"flex items-center gap-2 px-6 py-2 bg-orange-600 text-white font-semibold hover:bg-orange-700 transition-colors rounded-lg\"\n                            >\n                                Next\n                                <ChevronRight className=\"w-4 h-4\" />\n                            </button>\n                        ) : (\n                            <button\n                                type=\"submit\"\n                                disabled={isLoading || contestProblems.length === 0}\n                                className=\"flex items-center gap-2 px-8 py-2 bg-gray-900 dark:bg-white text-white dark:text-black font-semibold hover:bg-orange-600 dark:hover:bg-gray-200 transition-colors rounded-lg disabled:opacity-50 disabled:cursor-not-allowed\"\n                            >\n                                {isLoading ? (\n                                    <>\n                                        <Loader2 className=\"w-4 h-4 animate-spin\" />\n                                        Creating...\n                                    </>\n                                ) : (\n                                    <>\n                                        <Trophy className=\"w-4 h-4\" />\n                                        Create Contest\n                                    </>\n                                )}\n                            </button>\n                        )}\n                    </div>\n                </div>\n            </form>\n        </div>\n    );\n}\n\n"],"names":[],"mappings":"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"}}]
}