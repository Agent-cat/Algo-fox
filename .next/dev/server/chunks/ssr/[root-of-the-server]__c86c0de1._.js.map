{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst prismaClientSingleton = () => {\n    return new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    }).$extends({\n        query: {\n            $allModels: {\n                async $allOperations({ operation, model, args, query }) {\n                    const start = performance.now();\n                    const result = await query(args);\n                    const end = performance.now();\n\n                    // Warn about slow queries (>1 second)\n                    if (end - start > 1000) {\n                        console.warn(`Slow query: ${model}.${operation} took ${(end - start).toFixed(2)}ms`);\n                    }\n\n                    return result;\n                },\n            },\n        },\n    });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\ndeclare global {\n    var prisma_fox: PrismaClientSingleton | undefined;\n}\n\nconst prisma = globalThis.prisma_fox ?? prismaClientSingleton();\n\nexport { prisma };\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma_fox = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY,CAAC;QACpB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;IACtE,GAAG,QAAQ,CAAC;QACR,OAAO;YACH,YAAY;gBACR,MAAM,gBAAe,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;oBAClD,MAAM,QAAQ,YAAY,GAAG;oBAC7B,MAAM,SAAS,MAAM,MAAM;oBAC3B,MAAM,MAAM,YAAY,GAAG;oBAE3B,sCAAsC;oBACtC,IAAI,MAAM,QAAQ,MAAM;wBACpB,QAAQ,IAAI,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC,EAAE,UAAU,MAAM,EAAE,CAAC,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvF;oBAEA,OAAO;gBACX;YACJ;QACJ;IACJ;AACJ;AAQA,MAAM,SAAS,WAAW,UAAU,IAAI;;AAIxC,wCAA2C,WAAW,UAAU,GAAG"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\";\nimport { admin } from \"better-auth/plugins\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"./prisma\";\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\",\n  }),\n  emailAndPassword: {\n    enabled: true,\n    disableSignUp: true,\n  },\n  socialProviders: {\n    google: {\n      enabled: true,\n      clientId: process.env.GOOGLE_CLIENT_ID as string,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n    microsoft: {\n      enabled: true,\n      clientId: process.env.MICROSOFT_CLIENT_ID as string,\n      clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string,\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"STUDENT\",\n      },\n      institutionId: {\n        type: \"string\",\n        required: false,\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n\n  plugins: [\n    admin({\n      adminRoles: [\"ADMIN\"],\n      defaultRole: \"STUDENT\",\n      adminUserIds: [\"jvp0LDpaCm0Y2VpUVP75vCNQnDioEdpm\"], // vishnu\n    }),\n  ],\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEO,MAAM,OAAO,IAAA,qKAAU,EAAC;IAC7B,UAAU,IAAA,8MAAa,EAAC,uHAAM,EAAE;QAC9B,UAAU;IACZ;IACA,kBAAkB;QAChB,SAAS;QACT,eAAe;IACjB;IACA,iBAAiB;QACf,QAAQ;YACN,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;QACA,WAAW;YACT,SAAS;YACT,UAAU,QAAQ,GAAG,CAAC,mBAAmB;YACzC,cAAc,QAAQ,GAAG,CAAC,uBAAuB;QACnD;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;YAChB;YACA,eAAe;gBACb,MAAM;gBACN,UAAU;YACZ;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IAEA,SAAS;QACP,IAAA,6KAAK,EAAC;YACJ,YAAY;gBAAC;aAAQ;YACrB,aAAa;YACb,cAAc;gBAAC;aAAmC;QACpD;KACD;AACH"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,UAAU;QAAM;IAC3B;IAEA,MAAM,iBAAiB,MAAM,uHAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,OAAO;YACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;QACzB;QACA,QAAQ;YACN,IAAI;YACJ,WAAW;YACX,WAAW;YACX,WAAW;YACX,OAAO;QACT;IACF;IAEA,gHAAgH;IAChH,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,GAAG,IAAI;IAEnE,IAAI,cAAc,MAAM,GAAG,GAAG;QAC5B,OAAO;YACL,UAAU;YACV,qBAAqB,QAAQ,OAAO,CAAC,KAAK;YAC1C,UAAU,cAAc,GAAG,CAAC,CAAA,IAAK,CAAC;oBAChC,GAAG,CAAC;oBACJ,WAAW,EAAE,KAAK,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC9C,CAAC;QACH;IACF;IAEA,OAAO;QAAE,UAAU;IAAM;AAC3B;AAEO,eAAe,uBAAuB,MAA0C;IACrF,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACxC,SAAS,MAAM,IAAA,0IAAO;IACxB;IAEA,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,iBAAiB;QAC9B,2DAA2D;QAC3D,MAAM,uHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9B,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,OAAO;oBACL,KAAK,QAAQ,OAAO,CAAC,KAAK;gBAC5B;YACF;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA4B;IAC/D,OAAO,IAAI,WAAW,kBAAkB;QACtC,+BAA+B;QAC/B,kEAAkE;QAClE,MAAM,uHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBACL,OAAO,QAAQ,OAAO,CAAC,KAAK;YAC9B;QACF;QACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAA6B;IAChE;AACF;;;IArEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1979, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestDetails.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/contest/ContestDetails.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/contest/ContestDetails.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAyS,GACtU,uEACA","ignoreList":[0]}},
    {"offset": {"line": 1993, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestDetails.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/contest/ContestDetails.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/contest/ContestDetails.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAqR,GAClT,mDACA","ignoreList":[0]}},
    {"offset": {"line": 2007, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/BackButton.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/BackButton.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/BackButton.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA6R,GAC1T,2DACA","ignoreList":[0]}},
    {"offset": {"line": 2029, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/BackButton.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/components/BackButton.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/BackButton.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAyQ,GACtS,uCACA","ignoreList":[0]}},
    {"offset": {"line": 2043, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2051, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/app/%28workspace%29/contest/%5Bid%5D/page.tsx"],"sourcesContent":["import { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { redirect, notFound } from \"next/navigation\";\nimport { getContestDetail } from \"@/actions/contest\";\nimport ContestDetails from \"@/components/contest/ContestDetails\";\nimport BackButton from \"@/components/BackButton\";\nimport Link from \"next/link\";\nimport { Suspense } from \"react\";\n\n\ninterface PageProps {\n    params: Promise<{ id: string }>;\n}\n\nasync function ContestDetailContent({ params }: { params: Promise<{ id: string }> }) {\n    \"use cache: private\";\n\n    const { id } = await params;\n\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        redirect(\"/signin\");\n    }\n\n    const userRole = (session.user as any).role;\n    const allowedRoles = [\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"];\n    const isAdminOrInstructor = allowedRoles.includes(userRole);\n    const backLink = isAdminOrInstructor ? \"/dashboard/contests\" : \"/contests\";\n\n    const res = await getContestDetail(id);\n\n    if (!res.success) {\n        if (res.error === \"Contest not found\") {\n            notFound();\n        }\n        return (\n            <div className=\"container mx-auto py-20 px-4 text-center\">\n                <h1 className=\"text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2\">Access Denied</h1>\n                <p className=\"text-gray-600 dark:text-gray-400 mb-8\">{res.error}</p>\n                <Link href={backLink} className=\"text-orange-600 font-bold hover:underline\">\n                    Back to Contests\n                </Link>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"container mx-auto py-10 px-4 min-h-screen\">\n            {/* Back Button */}\n            <div className=\"mb-8\">\n                <BackButton>\n                    {isAdminOrInstructor ? \"All Arenas\" : \"Back to Contests\"}\n                </BackButton>\n            </div>\n\n            <ContestDetails\n                contest={res.contest}\n                user={session.user}\n            />\n        </div>\n    );\n}\n\nexport default function ContestDetailPage({ params }: PageProps) {\n    return (\n        <Suspense fallback={\n            <div className=\"container mx-auto py-20 px-4 text-center\">\n                <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-orange-600 mx-auto mb-4\"></div>\n                <p className=\"text-gray-600 dark:text-gray-400\">Loading contest details...</p>\n            </div>\n        }>\n            <ContestDetailContent params={params} />\n        </Suspense>\n    );\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAQA,MAAA,6BAAA,eAAe,qBAAqB,EAAE,MAAM,EAAuC;IAG/E,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IAErB,MAAM,UAAU,MAAM,mHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;QACtC,SAAS,MAAM,IAAA,0IAAO;IAC1B;IAEA,IAAI,CAAC,SAAS,MAAM;QAChB,IAAA,iMAAQ,EAAC;IACb;IAEA,MAAM,WAAW,AAAC,QAAQ,IAAI,CAAS,IAAI;IAC3C,MAAM,eAAe;QAAC;QAAS;QAAuB;QAAmB;KAAU;IACnF,MAAM,sBAAsB,aAAa,QAAQ,CAAC;IAClD,MAAM,WAAW,sBAAsB,wBAAwB;IAE/D,MAAM,MAAM,MAAM,IAAA,sIAAgB,EAAC;IAEnC,IAAI,CAAC,IAAI,OAAO,EAAE;QACd,IAAI,IAAI,KAAK,KAAK,qBAAqB;YACnC,IAAA,iMAAQ;QACZ;QACA,qBACI,8OAAC;YAAI,WAAU;;8BACX,8OAAC;oBAAG,WAAU;8BAA2D;;;;;;8BACzE,8OAAC;oBAAE,WAAU;8BAAyC,IAAI,KAAK;;;;;;8BAC/D,8OAAC,0LAAI;oBAAC,MAAM;oBAAU,WAAU;8BAA4C;;;;;;;;;;;;IAKxF;IAEA,qBACI,8OAAC;QAAI,WAAU;;0BAEX,8OAAC;gBAAI,WAAU;0BACX,cAAA,8OAAC,oIAAU;8BACN,sBAAsB,eAAe;;;;;;;;;;;0BAI9C,8OAAC,mJAAc;gBACX,SAAS,IAAI,OAAO;gBACpB,MAAM,QAAQ,IAAI;;;;;;;;;;;;AAIlC;IAlDA,2OAAA,SAAe;WAAf;;AAAA;;;;IAAe;AAoDA,SAAS,kBAAkB,EAAE,MAAM,EAAa;IAC3D,qBACI,8OAAC,iNAAQ;QAAC,wBACN,8OAAC;YAAI,WAAU;;8BACX,8OAAC;oBAAI,WAAU;;;;;;8BACf,8OAAC;oBAAE,WAAU;8BAAmC;;;;;;;;;;;;kBAGpD,cAAA,8OAAC;YAAqB,QAAQ;;;;;;;;;;;AAG1C"}},
    {"offset": {"line": 2221, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/.next-internal/server/app/%28workspace%29/contest/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {checkSessionConflict as '00424ba432501922f40bb512e30bdbd7d1847d3c3e'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '40acca00133b06cb19d5be722d10fe520a25103a8b'} from 'ACTIONS_MODULE0'\nexport {$$RSC_SERVER_CACHE_0 as 'c09f4ce10ded3e048806b8cd0760a73ac35e9a70dd'} from 'ACTIONS_MODULE1'\nexport {getVisibleContests as '00eefbb253a85123f8c3c600ca19869a5101d8c0d1'} from 'ACTIONS_MODULE2'\nexport {getInstitutionalClassrooms as '40224e3fe672716e149c2c2793410ece7e7ff96034'} from 'ACTIONS_MODULE2'\nexport {getParticipationStatus as '4041a53321b8a41efa0515551dc3e636f81f59f7d7'} from 'ACTIONS_MODULE2'\nexport {acceptContestRules as '407bfdebdef8125e9da675e434ddabed8c0d83ff51'} from 'ACTIONS_MODULE2'\nexport {createContestWithProblems as '407d6b79375f2016b6861524ddee55c2e99ceb5e5b'} from 'ACTIONS_MODULE2'\nexport {createContest as '407ff7fc9ba70fda023756de206f185bb7683b86bd'} from 'ACTIONS_MODULE2'\nexport {getContestDetail as '409d0a0373926b8940e890b689a1cac3144677e167'} from 'ACTIONS_MODULE2'\nexport {getSelectableProblems as '409f563bec9a985442cff8b7b83d7546b8276a02e1'} from 'ACTIONS_MODULE2'\nexport {finalizeContest as '40a47fbc0ae4e927cabd5fae0ee2325db6de07014c'} from 'ACTIONS_MODULE2'\nexport {finishContestAction as '40cb9402bcb3cefb68c56b22e13de3a9f637bd31ab'} from 'ACTIONS_MODULE2'\nexport {getContestRanking as '40edfea29c94aa36a1a52aa93c92827398e407c1c2'} from 'ACTIONS_MODULE2'\nexport {checkSubmissionEligibility as '40f7fe5a39b9ff511e9db90ca5a169ae86d7660b65'} from 'ACTIONS_MODULE2'\nexport {getContestParticipants as '40fcf50c7b1ee991289ef809f621af905c86ec6963'} from 'ACTIONS_MODULE2'\nexport {validateContestSession as '602cf4435ac48b07adb33a52140ca1f4538d93b7d6'} from 'ACTIONS_MODULE2'\nexport {verifyContestPassword as '604a0bcc1451e81e233f48280ac746b33b2aa18f12'} from 'ACTIONS_MODULE2'\nexport {getParticipantViolations as '607d884db8652712b1888554802e08210ff48e297a'} from 'ACTIONS_MODULE2'\nexport {unblockParticipant as '60995be1625901022cd2485061fb5f529d27001da0'} from 'ACTIONS_MODULE2'\nexport {startContestSession as '60ab32f1cc26748b4afce6a433ca3e6dc394836698'} from 'ACTIONS_MODULE2'\nexport {logContestViolation as '78bac990ae89cd8ae87b5bbd328ef9aee3e1937b8f'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_0 as '803cf50d552ccc152ed46f078e0fb03c1767a05eb9'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_1 as 'c00d8131bc66d78bc8131eec8f6d3c30fe0c4f51bb'} from 'ACTIONS_MODULE2'\nexport {$$RSC_SERVER_CACHE_2 as 'c08c3a89f87d0fda2e2465be36519f53224c7bbfb3'} from 'ACTIONS_MODULE2'\nexport {finishContestAction as '40cb9402bcb3cefb68c56b22e13de3a9f637bd31ab'} from 'ACTIONS_MODULE2'\nexport {startContestSession as '60ab32f1cc26748b4afce6a433ca3e6dc394836698'} from 'ACTIONS_MODULE2'\nexport {verifyContestPassword as '604a0bcc1451e81e233f48280ac746b33b2aa18f12'} from 'ACTIONS_MODULE2'\nexport {logContestViolation as '78bac990ae89cd8ae87b5bbd328ef9aee3e1937b8f'} from 'ACTIONS_MODULE2'\nexport {getParticipationStatus as '4041a53321b8a41efa0515551dc3e636f81f59f7d7'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AAEA;AACA"}}]
}