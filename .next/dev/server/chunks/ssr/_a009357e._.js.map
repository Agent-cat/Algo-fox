{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAijCsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA8mCsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/app/%28main%29/dashboard/contests/%5Bid%5D/participants/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport {\n    ArrowLeft, Users, AlertTriangle, Ban, Clock, CheckCircle2,\n    ChevronDown, ChevronUp, Eye, Unlock, Shield\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { toast } from \"sonner\";\nimport { getContestParticipants, unblockParticipant, getParticipantViolations } from \"@/actions/contest\";\n\ninterface Participant {\n    id: string;\n    userId: string;\n    totalViolations: number;\n    isFlagged: boolean;\n    isBlocked: boolean;\n    permanentlyBlocked: boolean;\n    tempBlockedUntil: string | null;\n    unblockedBy: string | null;\n    unblockedAt: string | null;\n    user: {\n        id: string;\n        name: string;\n        email: string;\n        image: string | null;\n    };\n    violations: {\n        id: string;\n        type: string;\n        message: string | null;\n        createdAt: string;\n    }[];\n}\n\nexport default function ContestParticipantsPage() {\n    const params = useParams();\n    const router = useRouter();\n    const contestId = params.id as string;\n\n    const [participants, setParticipants] = useState<Participant[]>([]);\n    const [loading, setLoading] = useState(true);\n    const [expandedId, setExpandedId] = useState<string | null>(null);\n    const [unblocking, setUnblocking] = useState<string | null>(null);\n\n    useEffect(() => {\n        loadParticipants();\n    }, [contestId]);\n\n    const loadParticipants = async () => {\n        setLoading(true);\n        const result = await getContestParticipants(contestId);\n        if (result.success && result.participants) {\n            // Map to handle Date to string conversion\n            const mapped = (result.participants as any[]).map(p => ({\n                ...p,\n                violations: p.violations.map((v: any) => ({\n                    ...v,\n                    createdAt: v.createdAt instanceof Date ? v.createdAt.toISOString() : v.createdAt\n                }))\n            }));\n            setParticipants(mapped);\n        } else {\n            toast.error(result.error || \"Failed to load participants\");\n        }\n        setLoading(false);\n    };\n\n    const handleUnblock = async (userId: string) => {\n        setUnblocking(userId);\n        const result = await unblockParticipant(contestId, userId);\n        if (result.success) {\n            toast.success(\"Participant unblocked successfully\");\n            loadParticipants();\n        } else {\n            toast.error(result.error || \"Failed to unblock participant\");\n        }\n        setUnblocking(null);\n    };\n\n    const getStatusBadge = (p: Participant) => {\n        if (p.permanentlyBlocked) {\n            return <span className=\"px-2 py-1 bg-red-100 dark:bg-red-500/10 text-red-700 dark:text-red-400 text-xs font-medium rounded-full flex items-center gap-1\">\n                <Ban className=\"w-3 h-3\" /> Permanently Blocked\n            </span>;\n        }\n        if (p.tempBlockedUntil && new Date(p.tempBlockedUntil) > new Date()) {\n            return <span className=\"px-2 py-1 bg-orange-100 dark:bg-orange-500/10 text-orange-700 dark:text-orange-400 text-xs font-medium rounded-full flex items-center gap-1\">\n                <Clock className=\"w-3 h-3\" /> Temp Blocked\n            </span>;\n        }\n        if (p.isBlocked) {\n            return <span className=\"px-2 py-1 bg-red-100 dark:bg-red-500/10 text-red-700 dark:text-red-400 text-xs font-medium rounded-full flex items-center gap-1\">\n                <Ban className=\"w-3 h-3\" /> Blocked\n            </span>;\n        }\n        if (p.isFlagged) {\n            return <span className=\"px-2 py-1 bg-yellow-100 dark:bg-yellow-500/10 text-yellow-700 dark:text-yellow-400 text-xs font-medium rounded-full flex items-center gap-1\">\n                <AlertTriangle className=\"w-3 h-3\" /> Flagged\n            </span>;\n        }\n        if (p.unblockedAt) {\n            return <span className=\"px-2 py-1 bg-green-100 dark:bg-green-500/10 text-green-700 dark:text-green-400 text-xs font-medium rounded-full flex items-center gap-1\">\n                <CheckCircle2 className=\"w-3 h-3\" /> Unblocked\n            </span>;\n        }\n        return <span className=\"px-2 py-1 bg-gray-100 dark:bg-[#1a1a1a] text-gray-700 dark:text-gray-300 text-xs font-medium rounded-full\">\n            Active\n        </span>;\n    };\n\n    const blockedCount = participants.filter(p => p.isBlocked || p.permanentlyBlocked).length;\n    const flaggedCount = participants.filter(p => p.isFlagged && !p.isBlocked).length;\n\n    return (\n        <div className=\"min-h-screen bg-gray-50 dark:bg-[#0a0a0a]\">\n            {/* Header */}\n            <div className=\"bg-white dark:bg-[#141414] border-b border-gray-200 dark:border-[#262626] sticky top-0 z-10\">\n                <div className=\"max-w-6xl mx-auto px-4 py-4\">\n                    <div className=\"flex items-center gap-4\">\n                        <button\n                            onClick={() => router.back()}\n                            className=\"p-2 hover:bg-gray-100 dark:hover:bg-[#1a1a1a] rounded-lg transition-colors text-gray-500 dark:text-gray-400\"\n                        >\n                            <ArrowLeft className=\"w-5 h-5\" />\n                        </button>\n                        <div>\n                            <h1 className=\"text-xl font-bold text-gray-900 dark:text-white\">Contest Participants</h1>\n                            <p className=\"text-sm text-gray-500 dark:text-gray-400\">View violations and manage blocked participants</p>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            {/* Stats */}\n            <div className=\"max-w-6xl mx-auto px-4 py-6\">\n                <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4 mb-6\">\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl p-4 border border-gray-200 dark:border-[#262626]\">\n                        <div className=\"flex items-center gap-3\">\n                            <div className=\"w-10 h-10 bg-blue-100 dark:bg-blue-500/10 rounded-lg flex items-center justify-center\">\n                                <Users className=\"w-5 h-5 text-blue-600 dark:text-blue-500\" />\n                            </div>\n                            <div>\n                                <p className=\"text-2xl font-bold text-gray-900 dark:text-gray-100\">{participants.length}</p>\n                                <p className=\"text-sm text-gray-500 dark:text-gray-400\">Total Participants</p>\n                            </div>\n                        </div>\n                    </div>\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl p-4 border border-gray-200 dark:border-[#262626]\">\n                        <div className=\"flex items-center gap-3\">\n                            <div className=\"w-10 h-10 bg-red-100 dark:bg-red-500/10 rounded-lg flex items-center justify-center\">\n                                <Ban className=\"w-5 h-5 text-red-600 dark:text-red-500\" />\n                            </div>\n                            <div>\n                                <p className=\"text-2xl font-bold text-gray-900 dark:text-gray-100\">{blockedCount}</p>\n                                <p className=\"text-sm text-gray-500 dark:text-gray-400\">Blocked</p>\n                            </div>\n                        </div>\n                    </div>\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl p-4 border border-gray-200 dark:border-[#262626]\">\n                        <div className=\"flex items-center gap-3\">\n                            <div className=\"w-10 h-10 bg-yellow-100 dark:bg-yellow-500/10 rounded-lg flex items-center justify-center\">\n                                <AlertTriangle className=\"w-5 h-5 text-yellow-600 dark:text-yellow-500\" />\n                            </div>\n                            <div>\n                                <p className=\"text-2xl font-bold text-gray-900 dark:text-gray-100\">{flaggedCount}</p>\n                                <p className=\"text-sm text-gray-500 dark:text-gray-400\">Flagged</p>\n                            </div>\n                        </div>\n                    </div>\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl p-4 border border-gray-200 dark:border-[#262626]\">\n                        <div className=\"flex items-center gap-3\">\n                            <div className=\"w-10 h-10 bg-green-100 dark:bg-green-500/10 rounded-lg flex items-center justify-center\">\n                                <Shield className=\"w-5 h-5 text-green-600 dark:text-green-500\" />\n                            </div>\n                            <div>\n                                <p className=\"text-2xl font-bold text-gray-900 dark:text-gray-100\">\n                                    {participants.filter(p => p.totalViolations === 0).length}\n                                </p>\n                                <p className=\"text-sm text-gray-500 dark:text-gray-400\">Clean</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n                {/* Participants List */}\n                <div className=\"bg-white dark:bg-[#141414] rounded-xl border border-gray-200 dark:border-[#262626] overflow-hidden\">\n                    {loading ? (\n                        <div className=\"p-8 text-center text-gray-500 dark:text-gray-400\">Loading participants...</div>\n                    ) : participants.length === 0 ? (\n                        <div className=\"p-8 text-center text-gray-500 dark:text-gray-400\">No participants yet</div>\n                    ) : (\n                        <div className=\"divide-y divide-gray-100 dark:divide-[#262626]\">\n                            {participants.map((p) => (\n                                <div key={p.id} className=\"hover:bg-gray-50 dark:hover:bg-[#1a1a1a]\">\n                                    <div\n                                        className=\"p-4 flex items-center justify-between cursor-pointer\"\n                                        onClick={() => setExpandedId(expandedId === p.id ? null : p.id)}\n                                    >\n                                        <div className=\"flex items-center gap-4\">\n                                            <div className=\"w-10 h-10 bg-gray-200 dark:bg-[#262626] rounded-full flex items-center justify-center overflow-hidden\">\n                                                {p.user.image ? (\n                                                    <img src={p.user.image} alt=\"\" className=\"w-full h-full object-cover\" referrerPolicy=\"no-referrer\" />\n                                                ) : (\n                                                    <span className=\"text-gray-600 dark:text-gray-400 font-medium\">\n                                                        {p.user.name?.charAt(0) || '?'}\n                                                    </span>\n                                                )}\n                                            </div>\n                                            <div>\n                                                <p className=\"font-medium text-gray-900 dark:text-gray-100\">{p.user.name}</p>\n                                                <p className=\"text-sm text-gray-500 dark:text-gray-400\">{p.user.email}</p>\n                                            </div>\n                                        </div>\n\n                                        <div className=\"flex items-center gap-4\">\n                                            {getStatusBadge(p)}\n                                            <div className=\"text-center\">\n                                                <p className={`text-lg font-bold ${\n                                                    p.totalViolations >= 6 ? 'text-red-600' :\n                                                    p.totalViolations >= 4 ? 'text-orange-600' :\n                                                    p.totalViolations >= 1 ? 'text-yellow-600' : 'text-green-600'\n                                                }`}>\n                                                    {p.totalViolations}\n                                                </p>\n                                                <p className=\"text-xs text-gray-500\">Violations</p>\n                                            </div>\n                                            {expandedId === p.id ? (\n                                                <ChevronUp className=\"w-5 h-5 text-gray-400\" />\n                                            ) : (\n                                                <ChevronDown className=\"w-5 h-5 text-gray-400\" />\n                                            )}\n                                        </div>\n                                    </div>\n\n                                    {/* Expanded details */}\n                                    {expandedId === p.id && (\n                                        <div className=\"px-4 pb-4 border-t border-gray-100 dark:border-[#262626] bg-gray-50 dark:bg-[#1a1a1a]\">\n                                            <div className=\"pt-4\">\n                                                {/* Action buttons */}\n                                                {(p.isBlocked || p.permanentlyBlocked) && (\n                                                    <div className=\"mb-4\">\n                                                        <button\n                                                            onClick={(e) => {\n                                                                e.stopPropagation();\n                                                                handleUnblock(p.userId);\n                                                            }}\n                                                            disabled={unblocking === p.userId}\n                                                            className=\"px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 transition-colors flex items-center gap-2 disabled:opacity-50\"\n                                                        >\n                                                            <Unlock className=\"w-4 h-4\" />\n                                                            {unblocking === p.userId ? 'Unblocking...' : 'Unblock Participant'}\n                                                        </button>\n                                                    </div>\n                                                )}\n\n                                                {/* Violations list */}\n                                                <p className=\"text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2\">Recent Violations:</p>\n                                                {p.violations.length === 0 ? (\n                                                    <p className=\"text-sm text-gray-500 dark:text-gray-400\">No violations recorded</p>\n                                                ) : (\n                                                    <div className=\"space-y-2\">\n                                                        {p.violations.map((v) => (\n                                                            <div key={v.id} className=\"flex items-center justify-between p-2 bg-white dark:bg-[#141414] rounded-lg border border-gray-200 dark:border-[#262626]\">\n                                                                <div className=\"flex items-center gap-2\">\n                                                                    <span className=\"px-2 py-0.5 bg-red-100 dark:bg-red-500/10 text-red-700 dark:text-red-400 text-xs rounded font-medium\">\n                                                                        {v.type.replace(/_/g, ' ')}\n                                                                    </span>\n                                                                    {v.message && (\n                                                                        <span className=\"text-sm text-gray-600 dark:text-gray-400\">{v.message}</span>\n                                                                    )}\n                                                                </div>\n                                                                <span className=\"text-xs text-gray-400 dark:text-gray-500\">\n                                                                    {new Date(v.createdAt).toLocaleTimeString()}\n                                                                </span>\n                                                            </div>\n                                                        ))}\n                                                    </div>\n                                                )}\n                                            </div>\n                                        </div>\n                                    )}\n                                </div>\n                            ))}\n                        </div>\n                    )}\n                </div>\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAVA;;;;;;;AAoCe,SAAS;IACpB,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,YAAY,OAAO,EAAE;IAE3B,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,iNAAQ,EAAgB,EAAE;IAClE,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAgB;IAC5D,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAgB;IAE5D,IAAA,kNAAS,EAAC;QACN;IACJ,GAAG;QAAC;KAAU;IAEd,MAAM,mBAAmB;QACrB,WAAW;QACX,MAAM,SAAS,MAAM,IAAA,yKAAsB,EAAC;QAC5C,IAAI,OAAO,OAAO,IAAI,OAAO,YAAY,EAAE;YACvC,0CAA0C;YAC1C,MAAM,SAAS,AAAC,OAAO,YAAY,CAAW,GAAG,CAAC,CAAA,IAAK,CAAC;oBACpD,GAAG,CAAC;oBACJ,YAAY,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC,IAAW,CAAC;4BACtC,GAAG,CAAC;4BACJ,WAAW,EAAE,SAAS,YAAY,OAAO,EAAE,SAAS,CAAC,WAAW,KAAK,EAAE,SAAS;wBACpF,CAAC;gBACL,CAAC;YACD,gBAAgB;QACpB,OAAO;YACH,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;QAChC;QACA,WAAW;IACf;IAEA,MAAM,gBAAgB,OAAO;QACzB,cAAc;QACd,MAAM,SAAS,MAAM,IAAA,qKAAkB,EAAC,WAAW;QACnD,IAAI,OAAO,OAAO,EAAE;YAChB,iJAAK,CAAC,OAAO,CAAC;YACd;QACJ,OAAO;YACH,iJAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;QAChC;QACA,cAAc;IAClB;IAEA,MAAM,iBAAiB,CAAC;QACpB,IAAI,EAAE,kBAAkB,EAAE;YACtB,qBAAO,8OAAC;gBAAK,WAAU;;kCACnB,8OAAC,uMAAG;wBAAC,WAAU;;;;;;oBAAY;;;;;;;QAEnC;QACA,IAAI,EAAE,gBAAgB,IAAI,IAAI,KAAK,EAAE,gBAAgB,IAAI,IAAI,QAAQ;YACjE,qBAAO,8OAAC;gBAAK,WAAU;;kCACnB,8OAAC,6MAAK;wBAAC,WAAU;;;;;;oBAAY;;;;;;;QAErC;QACA,IAAI,EAAE,SAAS,EAAE;YACb,qBAAO,8OAAC;gBAAK,WAAU;;kCACnB,8OAAC,uMAAG;wBAAC,WAAU;;;;;;oBAAY;;;;;;;QAEnC;QACA,IAAI,EAAE,SAAS,EAAE;YACb,qBAAO,8OAAC;gBAAK,WAAU;;kCACnB,8OAAC,yOAAa;wBAAC,WAAU;;;;;;oBAAY;;;;;;;QAE7C;QACA,IAAI,EAAE,WAAW,EAAE;YACf,qBAAO,8OAAC;gBAAK,WAAU;;kCACnB,8OAAC,qOAAY;wBAAC,WAAU;;;;;;oBAAY;;;;;;;QAE5C;QACA,qBAAO,8OAAC;YAAK,WAAU;sBAA4G;;;;;;IAGvI;IAEA,MAAM,eAAe,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,IAAI,EAAE,kBAAkB,EAAE,MAAM;IACzF,MAAM,eAAe,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,MAAM;IAEjF,qBACI,8OAAC;QAAI,WAAU;;0BAEX,8OAAC;gBAAI,WAAU;0BACX,cAAA,8OAAC;oBAAI,WAAU;8BACX,cAAA,8OAAC;wBAAI,WAAU;;0CACX,8OAAC;gCACG,SAAS,IAAM,OAAO,IAAI;gCAC1B,WAAU;0CAEV,cAAA,8OAAC,6NAAS;oCAAC,WAAU;;;;;;;;;;;0CAEzB,8OAAC;;kDACG,8OAAC;wCAAG,WAAU;kDAAkD;;;;;;kDAChE,8OAAC;wCAAE,WAAU;kDAA2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOxE,8OAAC;gBAAI,WAAU;;kCACX,8OAAC;wBAAI,WAAU;;0CACX,8OAAC;gCAAI,WAAU;0CACX,cAAA,8OAAC;oCAAI,WAAU;;sDACX,8OAAC;4CAAI,WAAU;sDACX,cAAA,8OAAC,6MAAK;gDAAC,WAAU;;;;;;;;;;;sDAErB,8OAAC;;8DACG,8OAAC;oDAAE,WAAU;8DAAuD,aAAa,MAAM;;;;;;8DACvF,8OAAC;oDAAE,WAAU;8DAA2C;;;;;;;;;;;;;;;;;;;;;;;0CAIpE,8OAAC;gCAAI,WAAU;0CACX,cAAA,8OAAC;oCAAI,WAAU;;sDACX,8OAAC;4CAAI,WAAU;sDACX,cAAA,8OAAC,uMAAG;gDAAC,WAAU;;;;;;;;;;;sDAEnB,8OAAC;;8DACG,8OAAC;oDAAE,WAAU;8DAAuD;;;;;;8DACpE,8OAAC;oDAAE,WAAU;8DAA2C;;;;;;;;;;;;;;;;;;;;;;;0CAIpE,8OAAC;gCAAI,WAAU;0CACX,cAAA,8OAAC;oCAAI,WAAU;;sDACX,8OAAC;4CAAI,WAAU;sDACX,cAAA,8OAAC,yOAAa;gDAAC,WAAU;;;;;;;;;;;sDAE7B,8OAAC;;8DACG,8OAAC;oDAAE,WAAU;8DAAuD;;;;;;8DACpE,8OAAC;oDAAE,WAAU;8DAA2C;;;;;;;;;;;;;;;;;;;;;;;0CAIpE,8OAAC;gCAAI,WAAU;0CACX,cAAA,8OAAC;oCAAI,WAAU;;sDACX,8OAAC;4CAAI,WAAU;sDACX,cAAA,8OAAC,gNAAM;gDAAC,WAAU;;;;;;;;;;;sDAEtB,8OAAC;;8DACG,8OAAC;oDAAE,WAAU;8DACR,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,eAAe,KAAK,GAAG,MAAM;;;;;;8DAE7D,8OAAC;oDAAE,WAAU;8DAA2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAOxE,8OAAC;wBAAI,WAAU;kCACV,wBACG,8OAAC;4BAAI,WAAU;sCAAmD;;;;;mCAClE,aAAa,MAAM,KAAK,kBACxB,8OAAC;4BAAI,WAAU;sCAAmD;;;;;iDAElE,8OAAC;4BAAI,WAAU;sCACV,aAAa,GAAG,CAAC,CAAC,kBACf,8OAAC;oCAAe,WAAU;;sDACtB,8OAAC;4CACG,WAAU;4CACV,SAAS,IAAM,cAAc,eAAe,EAAE,EAAE,GAAG,OAAO,EAAE,EAAE;;8DAE9D,8OAAC;oDAAI,WAAU;;sEACX,8OAAC;4DAAI,WAAU;sEACV,EAAE,IAAI,CAAC,KAAK,iBACT,8OAAC;gEAAI,KAAK,EAAE,IAAI,CAAC,KAAK;gEAAE,KAAI;gEAAG,WAAU;gEAA6B,gBAAe;;;;;qFAErF,8OAAC;gEAAK,WAAU;0EACX,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,MAAM;;;;;;;;;;;sEAIvC,8OAAC;;8EACG,8OAAC;oEAAE,WAAU;8EAAgD,EAAE,IAAI,CAAC,IAAI;;;;;;8EACxE,8OAAC;oEAAE,WAAU;8EAA4C,EAAE,IAAI,CAAC,KAAK;;;;;;;;;;;;;;;;;;8DAI7E,8OAAC;oDAAI,WAAU;;wDACV,eAAe;sEAChB,8OAAC;4DAAI,WAAU;;8EACX,8OAAC;oEAAE,WAAW,CAAC,kBAAkB,EAC7B,EAAE,eAAe,IAAI,IAAI,iBACzB,EAAE,eAAe,IAAI,IAAI,oBACzB,EAAE,eAAe,IAAI,IAAI,oBAAoB,kBAC/C;8EACG,EAAE,eAAe;;;;;;8EAEtB,8OAAC;oEAAE,WAAU;8EAAwB;;;;;;;;;;;;wDAExC,eAAe,EAAE,EAAE,iBAChB,8OAAC,6NAAS;4DAAC,WAAU;;;;;iFAErB,8OAAC,mOAAW;4DAAC,WAAU;;;;;;;;;;;;;;;;;;wCAMlC,eAAe,EAAE,EAAE,kBAChB,8OAAC;4CAAI,WAAU;sDACX,cAAA,8OAAC;gDAAI,WAAU;;oDAEV,CAAC,EAAE,SAAS,IAAI,EAAE,kBAAkB,mBACjC,8OAAC;wDAAI,WAAU;kEACX,cAAA,8OAAC;4DACG,SAAS,CAAC;gEACN,EAAE,eAAe;gEACjB,cAAc,EAAE,MAAM;4DAC1B;4DACA,UAAU,eAAe,EAAE,MAAM;4DACjC,WAAU;;8EAEV,8OAAC,sNAAM;oEAAC,WAAU;;;;;;gEACjB,eAAe,EAAE,MAAM,GAAG,kBAAkB;;;;;;;;;;;;kEAMzD,8OAAC;wDAAE,WAAU;kEAA8D;;;;;;oDAC1E,EAAE,UAAU,CAAC,MAAM,KAAK,kBACrB,8OAAC;wDAAE,WAAU;kEAA2C;;;;;6EAExD,8OAAC;wDAAI,WAAU;kEACV,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC,kBACf,8OAAC;gEAAe,WAAU;;kFACtB,8OAAC;wEAAI,WAAU;;0FACX,8OAAC;gFAAK,WAAU;0FACX,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM;;;;;;4EAEzB,EAAE,OAAO,kBACN,8OAAC;gFAAK,WAAU;0FAA4C,EAAE,OAAO;;;;;;;;;;;;kFAG7E,8OAAC;wEAAK,WAAU;kFACX,IAAI,KAAK,EAAE,SAAS,EAAE,kBAAkB;;;;;;;+DAVvC,EAAE,EAAE;;;;;;;;;;;;;;;;;;;;;;mCArEhC,EAAE,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgG9C"}}]
}