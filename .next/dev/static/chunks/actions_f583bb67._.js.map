{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/submission.action.ts"],"sourcesContent":["\"use server\";\n\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { auth } from \"@/lib/auth\";\n\nimport { revalidatePath, revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { after } from \"next/server\"; // For background tasks\n\nasync function getCachedSubmissionInternal(id: string) {\n    \"use cache\"\n    cacheTag(`submission-${id}`);\n    // @ts-ignore\n    cacheLife(\"default\"); // or \"submission\" if defined\n\n    return SubmissionService.getSubmissionById(id);\n}\n\nexport async function getSubmission(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    const submission = await getCachedSubmissionInternal(id);\n\n    // Security check\n    if (submission && submission.userId !== session.user.id) {\n        return null;\n    }\n\n    return submission;\n}\n\nexport async function getProblemSubmissionsAction(problemId: string, take: number = 20, cursor?: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 60, revalidate: 60 }); // 1 minute default, but we rely on on-demand revalidation ideally\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return [];\n    }\n\n    const userId = session.user.id;\n\n    const tagKey = `problem-submissions-${userId}-${problemId}${cursor ? `-cursor-${cursor}` : \"\"}-take-${take}`;\n    cacheTag(tagKey, `user-submissions-${userId}`, `problem-${problemId}`);\n\n    return SubmissionService.getProblemSubmissions(problemId, userId, take, cursor);\n}\n\nexport async function markConceptAsCompleted(problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    // Use a default language (e.g., JavaScript ID 63) for concept submissions since language doesn't matter\n    const DEFAULT_CONCEPT_LANG_ID = 63;\n\n    try {\n        // Create a submission with ACCEPTED status\n        const submission = await SubmissionService.createSubmission(\n            userId,\n            problemId,\n            DEFAULT_CONCEPT_LANG_ID,\n            \"// CONCEPT COMPLETED\",\n            \"SUBMIT\"\n        );\n\n        // Update status to ACCEPTED\n        await SubmissionService.updateSubmissionStatus(submission.id, \"ACCEPTED\", 0, 0);\n\n        // Move heavy stats updates to background\n        after(async () => {\n             await SubmissionService.incrementProblemSolved(problemId, userId);\n             // Revalidating paths/tags inside after() ensures the next request is fresh,\n             // but current UI might need revalidatePath synchronous if it relies on server reload.\n             // However, separating side-effects is key.\n             // Using revalidateTag inside after works for ISR.\n             revalidateTag(`problem-${problemId}`,\"max\");\n             revalidateTag(`user-submissions-${userId}`,\"max\");\n             revalidateTag(`problem-submissions-${userId}-${problemId}`,\"max\");\n        });\n\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        // These might fail in standard runtime if cache tags aren't updated synchronously?\n        // Actually, revalidating path is enough for UI. Tags are for cached data.\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to mark concept as completed:\", error);\n        return { success: false, error: \"Failed to mark as completed\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAmBsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/submission.action.ts"],"sourcesContent":["\"use server\";\n\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { auth } from \"@/lib/auth\";\n\nimport { revalidatePath, revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { after } from \"next/server\"; // For background tasks\n\nasync function getCachedSubmissionInternal(id: string) {\n    \"use cache\"\n    cacheTag(`submission-${id}`);\n    // @ts-ignore\n    cacheLife(\"default\"); // or \"submission\" if defined\n\n    return SubmissionService.getSubmissionById(id);\n}\n\nexport async function getSubmission(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    const submission = await getCachedSubmissionInternal(id);\n\n    // Security check\n    if (submission && submission.userId !== session.user.id) {\n        return null;\n    }\n\n    return submission;\n}\n\nexport async function getProblemSubmissionsAction(problemId: string, take: number = 20, cursor?: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 60, revalidate: 60 }); // 1 minute default, but we rely on on-demand revalidation ideally\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return [];\n    }\n\n    const userId = session.user.id;\n\n    const tagKey = `problem-submissions-${userId}-${problemId}${cursor ? `-cursor-${cursor}` : \"\"}-take-${take}`;\n    cacheTag(tagKey, `user-submissions-${userId}`, `problem-${problemId}`);\n\n    return SubmissionService.getProblemSubmissions(problemId, userId, take, cursor);\n}\n\nexport async function markConceptAsCompleted(problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    // Use a default language (e.g., JavaScript ID 63) for concept submissions since language doesn't matter\n    const DEFAULT_CONCEPT_LANG_ID = 63;\n\n    try {\n        // Create a submission with ACCEPTED status\n        const submission = await SubmissionService.createSubmission(\n            userId,\n            problemId,\n            DEFAULT_CONCEPT_LANG_ID,\n            \"// CONCEPT COMPLETED\",\n            \"SUBMIT\"\n        );\n\n        // Update status to ACCEPTED\n        await SubmissionService.updateSubmissionStatus(submission.id, \"ACCEPTED\", 0, 0);\n\n        // Move heavy stats updates to background\n        after(async () => {\n             await SubmissionService.incrementProblemSolved(problemId, userId);\n             // Revalidating paths/tags inside after() ensures the next request is fresh,\n             // but current UI might need revalidatePath synchronous if it relies on server reload.\n             // However, separating side-effects is key.\n             // Using revalidateTag inside after works for ISR.\n             revalidateTag(`problem-${problemId}`,\"max\");\n             revalidateTag(`user-submissions-${userId}`,\"max\");\n             revalidateTag(`problem-submissions-${userId}-${problemId}`,\"max\");\n        });\n\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        // These might fail in standard runtime if cache tags aren't updated synchronously?\n        // Actually, revalidating path is enough for UI. Tags are for cached data.\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to mark concept as completed:\", error);\n        return { success: false, error: \"Failed to mark as completed\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAsCsB,8BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}}]
}