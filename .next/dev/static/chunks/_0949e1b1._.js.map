{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/auth-client.ts"],"sourcesContent":["\"use client\";\nimport { createAuthClient } from \"better-auth/react\";\nimport { adminClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n  plugins: [adminClient()],\n});\n"],"names":[],"mappings":";;;;AACA;AACA;AAAA;AAFA;;;AAGO,MAAM,aAAa,IAAA,0MAAgB,EAAC;IACzC,SAAS;QAAC,IAAA,uLAAW;KAAG;AAC1B"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/Submissions.tsx"],"sourcesContent":["\"use client\";\n\nimport { authClient } from '@/lib/auth-client';\nimport { SubmissionResult } from '@prisma/client';\nimport { Loader2, RefreshCw } from 'lucide-react';\nimport { useEffect, useState } from 'react';\nimport Link from 'next/link';\n\ninterface Submission {\n    id: string;\n    status: SubmissionResult;\n    time: number | null;\n    memory: number | null;\n    createdAt: string;\n    language: {\n        name: string;\n    };\n}\n\ninterface SubmissionsProps {\n    problemId: string;\n}\n\nexport default function Submissions({ problemId }: SubmissionsProps) {\n    const { data: session } = authClient.useSession();\n    // Use a separate state to handle the list locally if needed, but optimally this should be a client component that receives initial data or fetches via action.\n    // Given the requirement to be \"nice and optimized\", using the server action in useEffect is good,\n    // but React Server Components would be better if this was a page. Since it's a tab content,\n    // we'll fetch on mount using the action.\n\n    // Actually, to make it truly optimized, we should probably fetch this data in the parent server component\n    // and pass it down, but the Tab system is client-side.\n    // So client-side fetching via Server Action is the way to go here for SPA-like feel without full reload.\n\n    // Import dynamically to avoid server-only module errors in client component?\n    // No, Actions can be imported in Client Components.\n\n    const [submissions, setSubmissions] = useState<any[]>([]);\n    const [loading, setLoading] = useState(true);\n    const [loadingMore, setLoadingMore] = useState(false);\n    const [hasMore, setHasMore] = useState(false);\n    const PAGE_SIZE = 15;\n\n    const loadSubmissions = async (cursor?: string) => {\n        if (!problemId) return;\n        if (cursor) setLoadingMore(true);\n        else setLoading(true);\n\n        try {\n            const { getProblemSubmissionsAction } = await import(\"@/actions/submission.action\");\n            const data = await getProblemSubmissionsAction(problemId, PAGE_SIZE, cursor);\n\n            if (cursor) {\n                setSubmissions(prev => [...prev, ...data]);\n            } else {\n                setSubmissions(data);\n            }\n\n            setHasMore(data.length === PAGE_SIZE);\n        } catch (error) {\n            console.error(\"Failed to load submissions\", error);\n        } finally {\n            setLoading(false);\n            setLoadingMore(false);\n        }\n    };\n\n    useEffect(() => {\n        loadSubmissions();\n        const handleUpdate = () => loadSubmissions();\n        window.addEventListener(\"pointsUpdated\", handleUpdate);\n        return () => window.removeEventListener(\"pointsUpdated\", handleUpdate);\n    }, [problemId]);\n\n    if (!session?.user) {\n        return <div className=\"p-8 text-center text-gray-500 dark:text-gray-400\">Please sign in to view submissions.</div>;\n    }\n\n    if (loading) {\n        return <div className=\"flex justify-center p-12\"><Loader2 className=\"animate-spin text-orange-500\" /></div>;\n    }\n\n    return (\n        <div className=\"h-full flex flex-col bg-white dark:bg-[#0a0a0a]\">\n            <div className=\"p-5 border-b border-gray-100 dark:border-[#262626] flex justify-between items-center bg-gray-50/50 dark:bg-[#0a0a0a]\">\n                <div className=\"flex items-center gap-2\">\n                    <span className=\"w-1 h-3 bg-orange-500 rounded-full\" />\n                    <h3 className=\"font-bold text-gray-900 dark:text-gray-100 uppercase text-xs tracking-widest\">My Submissions</h3>\n                </div>\n                <button\n                    onClick={() => loadSubmissions()}\n                    className=\"p-1.5 hover:bg-white dark:hover:bg-[#1a1a1a] hover:shadow-sm border border-transparent hover:border-gray-200 dark:hover:border-[#333] rounded-lg transition-all\"\n                >\n                    <RefreshCw className={`w-4 h-4 text-gray-500 dark:text-gray-400 ${loading ? 'animate-spin' : ''}`} />\n                </button>\n            </div>\n            <div className=\"overflow-y-auto flex-1 custom-scrollbar\">\n                {submissions.length === 0 ? (\n                    <div className=\"p-12 text-center text-gray-500 dark:text-gray-400 text-sm\">No submissions recorded yet.</div>\n                ) : (\n                    <div className=\"w-full text-sm text-left\">\n                        {/* HEADER */}\n                        <div className=\"grid grid-cols-5 gap-4 px-6 py-4 text-[10px] text-gray-400 dark:text-gray-500 uppercase bg-gray-100/50 dark:bg-[#141414] border-b border-gray-100 dark:border-[#262626] font-black tracking-widest\">\n                            <div>Status</div>\n                            <div>Language</div>\n                            <div>Time</div>\n                            <div>Memory</div>\n                            <div className=\"text-right\">Date</div>\n                        </div>\n                        {/* ROWS */}\n                        <div className=\"divide-y divide-gray-100 dark:divide-[#262626]\">\n                            {submissions.map((sub) => (\n                                <Link\n                                    key={sub.id}\n                                    href={`/submissions/${sub.id}`}\n                                    className=\"grid grid-cols-5 gap-4 px-6 py-4 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] transition-colors group items-center\"\n                                >\n                                    <div className=\"font-medium\">\n                                        <span className={`\n                                            px-2.5 py-1 rounded text-[10px] font-black uppercase tracking-tight\n                                            ${sub.status === 'ACCEPTED' ? 'text-emerald-700 bg-emerald-50 dark:bg-emerald-500/10 dark:text-emerald-500 border border-emerald-100 dark:border-emerald-500/20' :\n                                                sub.status === 'PENDING' ? 'text-amber-700 bg-amber-50 dark:bg-amber-500/10 dark:text-amber-500 border border-amber-100 dark:border-amber-500/20' :\n                                                    'text-rose-700 bg-rose-50 dark:bg-rose-500/10 dark:text-rose-500 border border-rose-100 dark:border-rose-500/20'}\n                                        `}>\n                                            {sub.status.replace(/_/g, \" \")}\n                                        </span>\n                                    </div>\n                                    <div className=\"text-gray-600 dark:text-gray-300 font-medium\">{sub.language.name}</div>\n                                    <div className=\"text-gray-500 dark:text-gray-400 font-mono text-xs\">{sub.time ? `${Number(sub.time).toFixed(3)}ms` : '-'}</div>\n                                    <div className=\"text-gray-500 dark:text-gray-400 font-mono text-xs\">{sub.memory ? `${sub.memory}KB` : '-'}</div>\n                                    <div className=\"text-gray-400 dark:text-gray-500 text-[10px] font-bold text-right uppercase tracking-tighter\">\n                                        {new Date(sub.createdAt).toLocaleDateString()}\n                                        <div className=\"opacity-60\">{new Date(sub.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>\n                                    </div>\n                                </Link>\n                            ))}\n                        </div>\n\n                        {/* LOAD MORE */}\n                        {hasMore && (\n                            <div className=\"p-6 flex justify-center border-t border-gray-50 dark:border-[#262626] bg-gray-50/20 dark:bg-[#141414]\">\n                                <button\n                                    onClick={() => loadSubmissions(submissions[submissions.length - 1].id)}\n                                    disabled={loadingMore}\n                                    className=\"flex items-center gap-3 px-8 py-3 bg-white dark:bg-[#1a1a1a] border border-gray-200 dark:border-[#333] text-[10px] font-black uppercase tracking-[0.2em] text-gray-500 dark:text-gray-400 hover:text-orange-600 dark:hover:text-orange-500 hover:border-orange-200 dark:hover:border-orange-500/30 hover:shadow-sm transition-all disabled:opacity-50\"\n                                >\n                                    {loadingMore ? (\n                                        <>\n                                            <Loader2 className=\"w-3.5 h-3.5 animate-spin\" />\n                                            Loading...\n                                        </>\n                                    ) : (\n                                        \"Load More Activity\"\n                                    )}\n                                </button>\n                            </div>\n                        )}\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/points.ts"],"sourcesContent":["import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n"],"names":[],"mappings":";;;;;;AAEO,SAAS,uBAAuB,UAAsB;IACzD,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,OAAO;IACf;AACJ;AAGO,SAAS,eAAe,UAAsB;IACjD,MAAM,SAAS,uBAAuB;IACtC,OAAO,GAAG,OAAO,IAAI,CAAC;AAC1B"}},
    {"offset": {"line": 403, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA+BsB,qBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAsJsB,cAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAgPsB,aAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA6QsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 463, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/discussion.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidateTag, unstable_cache } from \"next/cache\";\n\n// Type definitions\nexport type CommentWithUser = {\n    id: string;\n    content: string;\n    createdAt: Date;\n    updatedAt: Date;\n    userId: string;\n    parentId: string | null;\n    upvoteCount: number;\n    isPinned: boolean;\n    user: {\n        id: string;\n        name: string;\n        image: string | null;\n        role: string;\n    };\n    replies?: CommentWithUser[];\n    userVote?: \"UP\" | \"DOWN\" | null;\n};\n\n/**\n * Fetch comments for a problem, organized as a tree.\n * Uses Next.js 16 cacheTag for on-demand revalidation.\n */\nexport async function getProblemComments(problemId: string, currentUserId?: string) {\n    const fetchComments = unstable_cache(\n        async () => {\n            return await prisma.comment.findMany({\n                where: { problemId },\n                include: {\n                    user: {\n                        select: {\n                            id: true,\n                            name: true,\n                            image: true,\n                            role: true,\n                        }\n                    },\n                    votes: true // Fetch votes to calculate userVote manually if needed, or use separate query\n                },\n                orderBy: [\n                    { isPinned: \"desc\" }, // Pinned first\n                    { upvoteCount: \"desc\" }, // Then by votes\n                    { createdAt: \"desc\" }\n                ]\n            });\n        },\n        [`problem-comments-${problemId}`],\n        { tags: [`comments-${problemId}`] } // Cache tag for invalidation\n    );\n\n    const rawComments = await fetchComments();\n\n    // Process comments to add userVote status and organize into tree\n    const commentsWithVoteState = rawComments.map(comment => {\n        let userVote: \"UP\" | \"DOWN\" | null = null;\n        if (currentUserId) {\n            const vote = comment.votes.find(v => v.userId === currentUserId);\n            if (vote) userVote = vote.type;\n        }\n\n        // Remove votes array from result to reduce payload\n        const { votes: _, ...rest } = comment;\n        return { ...rest, userVote };\n    });\n\n    // Build Tree Structure\n    const commentMap = new Map();\n    const rootComments: any[] = [];\n\n    // Initialize map\n    commentsWithVoteState.forEach(comment => {\n        commentMap.set(comment.id, { ...comment, replies: [] });\n    });\n\n    // Link children to parents\n    commentsWithVoteState.forEach(comment => {\n        if (comment.parentId) {\n            const parent = commentMap.get(comment.parentId);\n            if (parent) {\n                parent.replies.push(commentMap.get(comment.id));\n            }\n        } else {\n            rootComments.push(commentMap.get(comment.id));\n        }\n    });\n\n    return rootComments as CommentWithUser[];\n}\n\n/**\n * Post a new comment or reply\n */\nexport async function postComment(problemId: string, content: string, parentId?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const newComment = await prisma.comment.create({\n            data: {\n                content,\n                problemId,\n                userId: session.user.id,\n                parentId: parentId || null\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true,\n                        role: true,\n                    }\n                }\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n\n        // Return the formatted comment to allow optimistic updates on client\n        return {\n            success: true,\n            comment: {\n                ...newComment,\n                votes: [], // Empty votes for new comment\n                userVote: null,\n                replies: []\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to post comment:\", error);\n        return { success: false, error: \"Failed to post comment\" };\n    }\n}\n\n/**\n * Toggle Vote (Upvote/Downvote)\n */\nexport async function voteComment(commentId: string, problemId: string, type: \"UP\" | \"DOWN\") {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Check existing vote\n        const existingVote = await prisma.commentVote.findUnique({\n            where: {\n                userId_commentId: {\n                    userId,\n                    commentId\n                }\n            }\n        });\n\n        // Use transaction to update vote and count atomically\n        await prisma.$transaction(async (tx) => {\n            if (existingVote) {\n                if (existingVote.type === type) {\n                    // Remove vote (toggle off)\n                    await tx.commentVote.delete({\n                        where: { id: existingVote.id }\n                    });\n\n                    // Update count (reverse the vote)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                decrement: type === \"UP\" ? 1 : -1 // wait, actually upvoteCount logic usually just counts upvotes - downvotes\n                                // Let's assume upvoteCount is a cache of \"score\"\n                            }\n                        }\n                    });\n                } else {\n                    // Change vote\n                    await tx.commentVote.update({\n                        where: { id: existingVote.id },\n                        data: { type }\n                    });\n\n                    // Update count (+2 or -2 because we are swinging from one side to other)\n                    await tx.comment.update({\n                        where: { id: commentId },\n                        data: {\n                            upvoteCount: {\n                                increment: type === \"UP\" ? 2 : -2\n                            }\n                        }\n                    });\n                }\n            } else {\n                // New vote\n                await tx.commentVote.create({\n                    data: {\n                        userId,\n                        commentId,\n                        type\n                    }\n                });\n\n                await tx.comment.update({\n                    where: { id: commentId },\n                    data: {\n                        upvoteCount: {\n                            increment: type === \"UP\" ? 1 : -1\n                        }\n                    }\n                });\n            }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to vote:\", error);\n        return { success: false, error: \"Failed to vote\" };\n    }\n}\n\n/**\n * Pin a comment (Admin only)\n */\nexport async function pinComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user || session.user.role !== \"ADMIN\") {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Toggle pin status\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Comment not found\" };\n\n        await prisma.comment.update({\n            where: { id: commentId },\n            data: { isPinned: !comment.isPinned }\n        });\n\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to pin comment\" };\n    }\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(commentId: string, problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const comment = await prisma.comment.findUnique({ where: { id: commentId } });\n        if (!comment) return { success: false, error: \"Not found\" };\n\n        const canDelete = session.user.role === \"ADMIN\" || comment.userId === session.user.id;\n\n        if (!canDelete) {\n            return { success: false, error: \"Unauthorized\" };\n        }\n\n        await prisma.comment.delete({ where: { id: commentId } });\n        revalidateTag(`comments-${problemId}`, \"max\");\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to delete\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAoGsB,cAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 478, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/problems/discussion/CommentInput.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { Send, Loader2 } from \"lucide-react\";\nimport { toast } from \"sonner\";\nimport { postComment } from \"@/actions/discussion\";\n\ninterface CommentInputProps {\n    problemId: string;\n    parentId?: string;\n    onSuccess?: (comment?: any) => void;\n    onCancel?: () => void;\n    placeholder?: string;\n    autoFocus?: boolean;\n    compact?: boolean;\n}\n\nexport function CommentInput({ problemId, parentId, onSuccess, onCancel, placeholder, autoFocus, compact }: CommentInputProps) {\n    const [content, setContent] = useState(\"\");\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    const handleSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n        if (!content.trim()) return;\n\n        setIsSubmitting(true);\n        try {\n            const res = await postComment(problemId, content, parentId);\n            if (res.success) {\n                setContent(\"\");\n                toast.success(\"Comment posted!\");\n                onSuccess?.(res.comment);\n            } else {\n                toast.error(res.error || \"Failed to post comment\");\n            }\n        } catch (error) {\n            toast.error(\"Something went wrong\");\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n\n    if (compact) {\n        return (\n            <form onSubmit={handleSubmit} className=\"flex gap-2 items-center w-full\">\n                <input\n                    value={content}\n                    onChange={(e) => setContent(e.target.value)}\n                    placeholder={placeholder || \"Type a comment...\"}\n                    className=\"flex-1 px-4 py-2.5 bg-gray-50 dark:bg-[#1a1a1a] border border-gray-200 dark:border-[#333] rounded-full focus:outline-none focus:ring-2 focus:ring-orange-500/20 focus:border-orange-500 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-400 transition-all\"\n                    autoFocus={autoFocus}\n                />\n                <button\n                    type=\"submit\"\n                    disabled={!content.trim() || isSubmitting}\n                    className=\"p-2.5 bg-orange-600 text-white rounded-full hover:bg-orange-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors shadow-sm\"\n                >\n                    {isSubmitting ? <Loader2 className=\"w-4 h-4 animate-spin\" /> : <Send className=\"w-4 h-4\" />}\n                </button>\n            </form>\n        );\n    }\n\n    return (\n        <form onSubmit={handleSubmit} className=\"w-full\">\n            <div className=\"relative\">\n                <textarea\n                    value={content}\n                    onChange={(e) => setContent(e.target.value)}\n                    placeholder={placeholder || \"Write a comment...\"}\n                    className=\"w-full min-h-[100px] p-4 bg-gray-50 dark:bg-[#1a1a1a] border border-gray-200 dark:border-[#333] rounded-xl focus:outline-none focus:ring-2 focus:ring-orange-500/20 focus:border-orange-500 resize-y text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-400\"\n                    autoFocus={autoFocus}\n                />\n                <div className=\"absolute bottom-3 right-3 flex items-center gap-2\">\n                    {onCancel && (\n                        <button\n                            type=\"button\"\n                            onClick={onCancel}\n                            className=\"px-3 py-1.5 text-xs font-semibold text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200 transition-colors\"\n                        >\n                            Cancel\n                        </button>\n                    )}\n                    <button\n                        type=\"submit\"\n                        disabled={!content.trim() || isSubmitting}\n                        className=\"px-4 py-1.5 bg-orange-600 text-white text-xs font-bold rounded-lg hover:bg-orange-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 transition-colors\"\n                    >\n                        {isSubmitting ? <Loader2 className=\"w-3 h-3 animate-spin\" /> : <Send className=\"w-3 h-3\" />}\n                        Post\n                    </button>\n                </div>\n            </div>\n        </form>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AACA;;;AALA;;;;;AAiBO,SAAS,aAAa,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,OAAO,EAAqB;;IACzH,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IAEjD,MAAM,eAAe,OAAO;QACxB,EAAE,cAAc;QAChB,IAAI,CAAC,QAAQ,IAAI,IAAI;QAErB,gBAAgB;QAChB,IAAI;YACA,MAAM,MAAM,MAAM,IAAA,iKAAW,EAAC,WAAW,SAAS;YAClD,IAAI,IAAI,OAAO,EAAE;gBACb,WAAW;gBACX,oJAAK,CAAC,OAAO,CAAC;gBACd,YAAY,IAAI,OAAO;YAC3B,OAAO;gBACH,oJAAK,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI;YAC7B;QACJ,EAAE,OAAO,OAAO;YACZ,oJAAK,CAAC,KAAK,CAAC;QAChB,SAAU;YACN,gBAAgB;QACpB;IACJ;IAEA,IAAI,SAAS;QACT,qBACI,6LAAC;YAAK,UAAU;YAAc,WAAU;;8BACpC,6LAAC;oBACG,OAAO;oBACP,UAAU,CAAC,IAAM,WAAW,EAAE,MAAM,CAAC,KAAK;oBAC1C,aAAa,eAAe;oBAC5B,WAAU;oBACV,WAAW;;;;;;8BAEf,6LAAC;oBACG,MAAK;oBACL,UAAU,CAAC,QAAQ,IAAI,MAAM;oBAC7B,WAAU;8BAET,6BAAe,6LAAC,+NAAO;wBAAC,WAAU;;;;;6CAA4B,6LAAC,6MAAI;wBAAC,WAAU;;;;;;;;;;;;;;;;;IAI/F;IAEA,qBACI,6LAAC;QAAK,UAAU;QAAc,WAAU;kBACpC,cAAA,6LAAC;YAAI,WAAU;;8BACX,6LAAC;oBACG,OAAO;oBACP,UAAU,CAAC,IAAM,WAAW,EAAE,MAAM,CAAC,KAAK;oBAC1C,aAAa,eAAe;oBAC5B,WAAU;oBACV,WAAW;;;;;;8BAEf,6LAAC;oBAAI,WAAU;;wBACV,0BACG,6LAAC;4BACG,MAAK;4BACL,SAAS;4BACT,WAAU;sCACb;;;;;;sCAIL,6LAAC;4BACG,MAAK;4BACL,UAAU,CAAC,QAAQ,IAAI,MAAM;4BAC7B,WAAU;;gCAET,6BAAe,6LAAC,+NAAO;oCAAC,WAAU;;;;;yDAA4B,6LAAC,6MAAI;oCAAC,WAAU;;;;;;gCAAa;;;;;;;;;;;;;;;;;;;;;;;;AAOpH;GA9EgB;KAAA"}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/problems/discussion/CommentItem.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport Image from \"next/image\";\nimport { formatDistanceToNow } from \"date-fns\";\nimport { ArrowBigUp, ArrowBigDown, MessageSquare, Trash2, Pin, PinOff } from \"lucide-react\"; // Using ArrowBigUp/Down for voting similar to Reddit\nimport { CommentWithUser, voteComment, pinComment, deleteComment } from \"@/actions/discussion\";\nimport { CommentInput } from \"./CommentInput\";\nimport { toast } from \"sonner\";\nimport { authClient } from \"@/lib/auth-client\";\n\ninterface CommentItemProps {\n    comment: CommentWithUser;\n    problemId: string;\n    depth?: number;\n    onRefresh?: () => void;\n}\n\n\n\nexport function CommentItem({ comment, problemId, depth = 0, onRefresh }: CommentItemProps) {\n    const { data: session } = authClient.useSession();\n    const [isReplying, setIsReplying] = useState(false);\n    const [voteState, setVoteState] = useState<\"UP\" | \"DOWN\" | null>(comment.userVote || null);\n    const [score, setScore] = useState(comment.upvoteCount);\n    const [isVoting, setIsVoting] = useState(false);\n\n    // Optimistic Replies State\n    const [localReplies, setLocalReplies] = useState<CommentWithUser[]>(comment.replies || []);\n\n    // Sync local replies if prop changes (e.g. on full refresh)\n    useEffect(() => {\n        if (comment.replies) {\n            setLocalReplies(comment.replies);\n        }\n    }, [comment.replies]);\n\n    const isOwner = session?.user?.id === comment.userId;\n    const isAdmin = session?.user?.role === \"ADMIN\";\n\n    const handleVote = async (type: \"UP\" | \"DOWN\") => {\n        if (!session?.user) return toast.error(\"Please login to vote\");\n        if (isVoting) return;\n\n        // Optimistic update\n        const previousVote = voteState;\n        const previousScore = score;\n\n        let newScore = score;\n        let newVote: \"UP\" | \"DOWN\" | null = type;\n\n        if (voteState === type) {\n            // Toggle off\n            newVote = null;\n            newScore -= (type === \"UP\" ? 1 : -1);\n        } else if (voteState) {\n            // Flip vote\n            newScore += (type === \"UP\" ? 2 : -2);\n        } else {\n            // New vote\n            newScore += (type === \"UP\" ? 1 : -1);\n        }\n\n        setVoteState(newVote);\n        setScore(newScore);\n        setIsVoting(true);\n\n        try {\n            const res = await voteComment(comment.id, problemId, type);\n            if (!res.success) throw new Error(res.error);\n        } catch (error) {\n            // Revert\n            setVoteState(previousVote);\n            setScore(previousScore);\n            toast.error(\"Failed to vote\");\n        } finally {\n            setIsVoting(false);\n        }\n    };\n\n    const handlePin = async () => {\n        if (!confirm(comment.isPinned ? \"Unpin this comment?\" : \"Pin this comment?\")) return;\n        const res = await pinComment(comment.id, problemId);\n        if (res.success) {\n            toast.success(\"Updated pin status\");\n            onRefresh?.();\n        } else {\n            toast.error(\"Failed to update pin status\");\n        }\n    };\n\n    const handleDelete = async () => {\n        if (!confirm(\"Delete this comment permanently?\")) return;\n        const res = await deleteComment(comment.id, problemId);\n        if (res.success) {\n            toast.success(\"Comment deleted\");\n            onRefresh?.();\n        } else {\n            toast.error(\"Failed to delete comment\");\n        }\n    };\n\n    return (\n        <div className={`flex flex-col ${depth > 0 ? \"ml-4 md:ml-8 border-l-2 border-gray-100 dark:border-[#262626] pl-4 md:pl-6 pt-2\" : \"\"}`}>\n            <div className={`relative group p-4 rounded-xl transition-all ${comment.isPinned ? \"bg-orange-50/50 dark:bg-orange-500/5 border border-orange-100 dark:border-orange-500/10\" : \"hover:bg-gray-50/50 dark:hover:bg-[#1a1a1a]/50\"}`}>\n\n                {/* Pin Badge */}\n                {comment.isPinned && (\n                    <div className=\"absolute top-2 right-4 flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider text-orange-600 dark:text-orange-500\">\n                        <Pin className=\"w-3 h-3 fill-current\" />\n                        Pinned\n                    </div>\n                )}\n\n                <div className=\"flex gap-4\">\n                    {/* AVATAR */}\n                    <div className=\"flex-shrink-0\">\n                        <div className=\"w-8 h-8 rounded-full bg-gray-200 dark:bg-[#333] overflow-hidden\">\n                            {comment.user.image ? (\n                                <Image src={comment.user.image} alt={comment.user.name} width={32} height={32} className=\"object-cover\" />\n                            ) : (\n                                <div className=\"w-full h-full flex items-center justify-center text-xs font-bold text-gray-500\">\n                                    {comment.user.name.charAt(0).toUpperCase()}\n                                </div>\n                            )}\n                        </div>\n                    </div>\n\n                    {/* CONTENT */}\n                    <div className=\"flex-1 min-w-0\">\n                        <div className=\"flex items-center gap-2 mb-1\">\n                            <span className=\"text-sm font-bold text-gray-900 dark:text-gray-100\">{comment.user.name}</span>\n                            {comment.user.role === \"ADMIN\" && (\n                                <span className=\"px-1.5 py-0.5 rounded text-[10px] font-bold bg-purple-100 text-purple-700 dark:bg-purple-500/10 dark:text-purple-400\">ADMIN</span>\n                            )}\n                            <span className=\"text-xs text-gray-400\"> {formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}</span>\n                        </div>\n\n                        <div className=\"text-sm text-gray-800 dark:text-gray-300 leading-relaxed whitespace-pre-wrap\">\n                            {comment.content}\n                        </div>\n\n                        {/* ACTIONS */}\n                        <div className=\"flex items-center gap-4 mt-3\">\n                            {/* VOTE */}\n                            <div className=\"flex items-center gap-1 bg-gray-100 dark:bg-[#262626] rounded-lg p-0.5\">\n                                <button\n                                    onClick={() => handleVote(\"UP\")}\n                                    className={`p-1 rounded hover:bg-gray-200 dark:hover:bg-[#333] transition-colors ${voteState === \"UP\" ? \"text-orange-600 dark:text-orange-500\" : \"text-gray-500 dark:text-gray-400\"}`}\n                                >\n                                    <ArrowBigUp className={`w-5 h-5 ${voteState === \"UP\" ? \"fill-current\" : \"\"}`} />\n                                </button>\n                                <span className={`text-xs font-bold w-6 text-center ${voteState === \"UP\" ? \"text-orange-600 dark:text-orange-500\" : voteState === \"DOWN\" ? \"text-blue-600 dark:text-blue-500\" : \"text-gray-600 dark:text-gray-400\"}`}>\n                                    {score}\n                                </span>\n                                <button\n                                    onClick={() => handleVote(\"DOWN\")}\n                                    className={`p-1 rounded hover:bg-gray-200 dark:hover:bg-[#333] transition-colors ${voteState === \"DOWN\" ? \"text-blue-600 dark:text-blue-500\" : \"text-gray-500 dark:text-gray-400\"}`}\n                                >\n                                    <ArrowBigDown className={`w-5 h-5 ${voteState === \"DOWN\" ? \"fill-current\" : \"\"}`} />\n                                </button>\n                            </div>\n\n                            <button\n                                onClick={() => setIsReplying(!isReplying)}\n                                className=\"flex items-center gap-1.5 text-xs font-medium text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200 transition-colors\"\n                            >\n                                <MessageSquare className=\"w-4 h-4\" />\n                                Reply\n                            </button>\n\n                            {(isOwner || isAdmin) && (\n                                <button\n                                    onClick={handleDelete}\n                                    className=\"flex items-center gap-1.5 text-xs font-medium text-gray-400 hover:text-red-600 dark:hover:text-red-500 transition-colors ml-auto md:ml-0\"\n                                >\n                                    <Trash2 className=\"w-3.5 h-3.5\" />\n                                    Delete\n                                </button>\n                            )}\n\n                            {isAdmin && (\n                                <button\n                                    onClick={handlePin}\n                                    className={`flex items-center gap-1.5 text-xs font-medium transition-colors ${comment.isPinned ? \"text-orange-600\" : \"text-gray-400 hover:text-gray-900 dark:hover:text-white\"}`}\n                                >\n                                    {comment.isPinned ? <PinOff className=\"w-3.5 h-3.5\" /> : <Pin className=\"w-3.5 h-3.5\" />}\n                                    {comment.isPinned ? \"Unpin\" : \"Pin\"}\n                                </button>\n                            )}\n                        </div>\n                    </div>\n                </div>\n\n                {isReplying && (\n                    <div className=\"mt-4 pl-12\">\n                        <CommentInput\n                            problemId={problemId}\n                            parentId={comment.id}\n                            onSuccess={(newReply) => {\n                                setIsReplying(false);\n                                if (newReply) {\n                                    setLocalReplies(prev => [...prev, newReply]);\n                                } else {\n                                    onRefresh?.();\n                                }\n                            }}\n                            onCancel={() => setIsReplying(false)}\n                            autoFocus\n                        />\n                    </div>\n                )}\n            </div>\n\n            {/* REPLIES - Use localReplies instead of comment.replies */}\n            {localReplies && localReplies.length > 0 && (\n                <div className=\"flex flex-col mb-4\">\n                    {localReplies.map(reply => (\n                        <CommentItem\n                            key={reply.id}\n                            comment={reply}\n                            problemId={problemId}\n                            depth={depth + 1}\n                            onRefresh={onRefresh}\n                        />\n                    ))}\n                </div>\n            )}\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1061, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/problems/discussion/CommentTree.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { getProblemComments, CommentWithUser } from \"@/actions/discussion\";\nimport { CommentItem } from \"./CommentItem\";\nimport { CommentInput } from \"./CommentInput\";\nimport { Loader2, MessageSquareOff } from \"lucide-react\";\n\nimport { authClient } from \"@/lib/auth-client\"; // Importing for client usage\n\ninterface CommentTreeProps {\n    problemId: string;\n}\n\nexport function CommentTree({ problemId }: CommentTreeProps) {\n    const { data: session } = authClient.useSession();\n    const [comments, setComments] = useState<CommentWithUser[]>([]);\n    const [isLoading, setIsLoading] = useState(true);\n\n    const fetchComments = async () => {\n        setIsLoading(true);\n        try {\n            const data = await getProblemComments(problemId, session?.user?.id);\n            setComments(data);\n        } catch (error) {\n            console.error(\"Failed to fetch comments\", error);\n        } finally {\n            setIsLoading(false);\n        }\n    };\n\n    useEffect(() => {\n        fetchComments();\n    }, [problemId, session?.user?.id]);\n\n    // Listen for invalidation/refetch if needed via custom events?\n    // Actually posting a comment triggers revalidateTag on server,\n    // but client needs to re-fetch to see it unless we do optimistic updates.\n    // For now, passing an onSuccess callback to inputs to trigger refetch.\n\n    // HOWEVER, in Next.js Server Actions with revalidateTag,\n    // if this component was a Server Component it would update automatically.\n    // Since it's a Client Component fetching data via Server Action in useEffect,\n    // we need to manually refetch.\n\n    // Better approach: Make the `getProblemComments` a data requirement of a wrapper server component?\n    // But the prompt asked for \"caching nextjs 16 usecache\" which we did in the action.\n    // Let's stick to client fetching for interactivity or wrap it.\n\n    // Actually, `CommentTree` should probably be a Server Component that fetches initial data,\n    // but the user interaction (voting, posting) happens on client.\n    // BUT since I am modifying `ProblemDescription` which is a Client Component\n    // (it deals with tabs state), I can't easily nest a Server Component inside it\n    // unless passed as children.\n    // Given the architecture, I'll fetch on client for now or use SWR-like pattern.\n    // Since we want to keep it simple, I'll just refetch on success.\n\n    const handleRefetch = (newComment?: CommentWithUser) => {\n        if (newComment) {\n            // Optimistic update\n            setComments(prev => [newComment, ...prev]);\n        } else {\n            fetchComments();\n        }\n    };\n\n    return (\n        <div className=\"flex flex-col h-full\">\n            {/* Comments List */}\n            <div className=\"flex-1 overflow-y-auto pb-24\">\n                <div className=\"flex items-center justify-between mb-4 px-2\">\n                    <h3 className=\"text-lg font-bold text-gray-900 dark:text-gray-100\">\n                        {comments.length} Comments\n                    </h3>\n                    <div className=\"text-xs text-gray-400\">\n                        Sorted by Best\n                    </div>\n                </div>\n\n                {isLoading ? (\n                    <div className=\"flex justify-center py-12\">\n                        <Loader2 className=\"w-8 h-8 animate-spin text-orange-500\" />\n                    </div>\n                ) : comments.length === 0 ? (\n                    <div className=\"flex flex-col items-center justify-center py-12 text-center opacity-60\">\n                        <MessageSquareOff className=\"w-12 h-12 text-gray-300 dark:text-gray-600 mb-2\" />\n                        <p className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">No comments yet. Be the first to start the conversation!</p>\n                    </div>\n                ) : (\n                    <div className=\"space-y-4\">\n                        {comments.map(comment => (\n                            <CommentItem\n                                key={comment.id}\n                                comment={comment}\n                                problemId={problemId}\n                                onRefresh={fetchComments}\n                            />\n                        ))}\n                    </div>\n                )}\n            </div>\n\n            {/* Sticky Bottom Input */}\n            <div className=\"sticky bottom-0 left-0 right-0 bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md border-t border-gray-200 dark:border-[#262626] p-4 -mx-6 -mb-6\">\n                {session?.user ? (\n                    <CommentInput problemId={problemId} onSuccess={handleRefetch} compact />\n                ) : (\n                   <div className=\"text-center py-3 bg-gray-50 dark:bg-[#1a1a1a] rounded-lg border border-dashed border-gray-200 dark:border-[#333]\">\n                        <p className=\"text-sm text-gray-500 dark:text-gray-400\">Please sign in to join the discussion.</p>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n}\n\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA,kNAAgD,6BAA6B;;;AAR7E;;;;;;;AAcO,SAAS,YAAY,EAAE,SAAS,EAAoB;;IACvD,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,sIAAU,CAAC,UAAU;IAC/C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAoB,EAAE;IAC9D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAE3C,MAAM,gBAAgB;QAClB,aAAa;QACb,IAAI;YACA,MAAM,OAAO,MAAM,IAAA,wKAAkB,EAAC,WAAW,SAAS,MAAM;YAChE,YAAY;QAChB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC9C,SAAU;YACN,aAAa;QACjB;IACJ;IAEA,IAAA,0KAAS;iCAAC;YACN;QACJ;gCAAG;QAAC;QAAW,SAAS,MAAM;KAAG;IAEjC,+DAA+D;IAC/D,+DAA+D;IAC/D,0EAA0E;IAC1E,uEAAuE;IAEvE,yDAAyD;IACzD,0EAA0E;IAC1E,8EAA8E;IAC9E,+BAA+B;IAE/B,mGAAmG;IACnG,oFAAoF;IACpF,+DAA+D;IAE/D,2FAA2F;IAC3F,gEAAgE;IAChE,4EAA4E;IAC5E,+EAA+E;IAC/E,6BAA6B;IAC7B,gFAAgF;IAChF,iEAAiE;IAEjE,MAAM,gBAAgB,CAAC;QACnB,IAAI,YAAY;YACZ,oBAAoB;YACpB,YAAY,CAAA,OAAQ;oBAAC;uBAAe;iBAAK;QAC7C,OAAO;YACH;QACJ;IACJ;IAEA,qBACI,6LAAC;QAAI,WAAU;;0BAEX,6LAAC;gBAAI,WAAU;;kCACX,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAG,WAAU;;oCACT,SAAS,MAAM;oCAAC;;;;;;;0CAErB,6LAAC;gCAAI,WAAU;0CAAwB;;;;;;;;;;;;oBAK1C,0BACG,6LAAC;wBAAI,WAAU;kCACX,cAAA,6LAAC,+NAAO;4BAAC,WAAU;;;;;;;;;;+BAEvB,SAAS,MAAM,KAAK,kBACpB,6LAAC;wBAAI,WAAU;;0CACX,6LAAC,yPAAgB;gCAAC,WAAU;;;;;;0CAC5B,6LAAC;gCAAE,WAAU;0CAAuD;;;;;;;;;;;6CAGxE,6LAAC;wBAAI,WAAU;kCACV,SAAS,GAAG,CAAC,CAAA,wBACV,6LAAC,sKAAW;gCAER,SAAS;gCACT,WAAW;gCACX,WAAW;+BAHN,QAAQ,EAAE;;;;;;;;;;;;;;;;0BAWnC,6LAAC;gBAAI,WAAU;0BACV,SAAS,qBACN,6LAAC,wKAAY;oBAAC,WAAW;oBAAW,WAAW;oBAAe,OAAO;;;;;yCAEtE,6LAAC;oBAAI,WAAU;8BACV,cAAA,6LAAC;wBAAE,WAAU;kCAA2C;;;;;;;;;;;;;;;;;;;;;;AAMhF;GApGgB;;QACc,sIAAU,CAAC;;;KADzB"}},
    {"offset": {"line": 1279, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/ProblemDescription.tsx"],"sourcesContent":["\"use client\";\n\nimport Markdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport remarkBreaks from 'remark-breaks';\nimport rehypeRaw from 'rehype-raw';\nimport { Problem } from '@prisma/client';\nimport { BadgeCheck, FileText, List, ShieldAlert } from 'lucide-react';\nimport Submissions from './Submissions';\nimport { getPointsLabel } from '@/lib/points';\nimport { CommentTree } from '../problems/discussion/CommentTree';\nimport { useState } from 'react';\nimport SolutionCodeGroup from \"@/components/markdown/SolutionCodeGroup\";\nimport { remarkSolutionDirective } from \"@/lib/markdown-plugins\";\nimport { preprocessMarkdown } from \"@/lib/markdown-utils\";\nimport remarkDirective from 'remark-directive';\n\ntype Tab = \"description\" | \"solutions\" | \"submissions\";\n\ninterface ProblemDescriptionProps {\n    problem: Problem & {\n        tags?: { name: string; slug: string }[];\n        solution?: string | null;\n    };\n    activeTab: Tab;\n    onTabChange: (tab: Tab) => void;\n    isSolved: boolean;\n    contestId?: string;\n}\n\nexport default function ProblemDescription({ problem, activeTab, onTabChange, isSolved, contestId }: ProblemDescriptionProps) {\n    const [solutionTab, setSolutionTab] = useState<\"official\" | \"community\">(\"official\");\n\n    const getDifficultyColor = (difficulty: string) => {\n        switch (difficulty) {\n            case \"EASY\": return \"text-emerald-600 bg-emerald-50 dark:bg-emerald-500/10 border-emerald-100 dark:border-emerald-500/30\";\n            case \"MEDIUM\": return \"text-amber-600 bg-amber-50 dark:bg-amber-500/10 border-amber-100 dark:border-amber-500/30\";\n            case \"HARD\": return \"text-rose-600 bg-rose-50 dark:bg-rose-500/10 border-rose-100 dark:border-rose-500/30\";\n            default: return \"text-gray-600 bg-gray-50 dark:bg-gray-500/10 border-gray-100 dark:border-gray-500/30\";\n        }\n    };\n\n    return (\n        <div className=\"h-full flex flex-col bg-white dark:bg-[#0a0a0a]\">\n            {/* HEADER TABS */}\n            <div className={`flex items-center gap-1 border-b border-gray-300 dark:border-[#262626] border-dashed px-4 py-2 ${contestId ? 'bg-orange-50/30 dark:bg-orange-500/5' : 'bg-gray-50/50 dark:bg-[#0a0a0a]'}`}>\n                <button\n                    onClick={() => onTabChange(\"description\")}\n                    className={`flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-lg transition-colors border ${activeTab === \"description\" ? \"bg-white dark:bg-[#141414] text-gray-900 dark:text-gray-100 shadow-sm border-gray-200 dark:border-[#262626]\" : \"text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 border-transparent\"}`}\n                >\n                    <FileText className=\"w-4 h-4\" />\n                    Description\n                </button>\n                {!contestId && (\n                    <button\n                        id=\"solutions-tab\"\n                        onClick={() => onTabChange(\"solutions\")}\n                        className={`flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-lg transition-colors border ${activeTab === \"solutions\" ? \"bg-white dark:bg-[#141414] text-gray-900 dark:text-gray-100 shadow-sm border-gray-200 dark:border-[#262626]\" : \"text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 border-transparent\"} disabled:opacity-50 disabled:cursor-not-allowed`}\n                        disabled={problem.difficulty === \"CONCEPT\"}\n                    >\n                        <BadgeCheck className=\"w-4 h-4\" />\n                        Solutions\n                    </button>\n                )}\n                <button\n                    onClick={() => onTabChange(\"submissions\")}\n                    className={`flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-lg transition-colors border ${activeTab === \"submissions\" ? \"bg-white dark:bg-[#141414] text-gray-900 dark:text-gray-100 shadow-sm border-gray-200 dark:border-[#262626]\" : \"text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 border-transparent\"}`}\n                >\n                    <List className=\"w-4 h-4\" />\n                    {contestId ? \"My Verdicts\" : \"Submissions\"}\n                </button>\n                {contestId && (\n                    <div className=\"ml-auto flex items-center gap-2 px-2 py-1 bg-orange-100 dark:bg-orange-500/20 rounded text-orange-700 dark:text-orange-400 font-bold text-[10px] uppercase tracking-wider\">\n                        <ShieldAlert className=\"w-3 h-3\" />\n                        Secure\n                    </div>\n                )}\n            </div>\n\n            {/* CONTENT */}\n            <div className=\"flex-1 overflow-y-auto custom-scrollbar\">\n                {activeTab === \"description\" && (\n                    <div className=\"px-6 py-6 space-y-6\">\n                        <div>\n                            <h1 className=\"text-2xl font-bold text-gray-900 dark:text-gray-100 mb-4\">{problem.title}</h1>\n                            <div className=\"flex items-center gap-3\">\n                                <span className={`px-3 py-1 rounded-full text-xs font-bold border ${getDifficultyColor(problem.difficulty)}`}>\n                                    {problem.difficulty.charAt(0) + problem.difficulty.slice(1).toLowerCase()}\n                                </span>\n                                <span className=\"text-sm text-gray-600 dark:text-gray-400 font-medium\">\n                                    {getPointsLabel(problem.difficulty)}\n                                </span>\n\n                                {problem.tags && problem.tags.length > 0 && (\n                                    <div className=\"flex items-center gap-2\">\n                                        <div className=\"w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-600\" />\n                                        {problem.tags.map(tag => (\n                                            <span key={tag.slug} className=\"text-xs font-medium text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-[#1a1a1a] px-2.5 py-1 rounded-full border border-gray-200 dark:border-[#262626]\">\n                                                {tag.name}\n                                            </span>\n                                        ))}\n                                    </div>\n                                )}\n                            </div>\n                        </div>\n\n                        <div className=\"prose prose-[1rem] max-w-none prose-slate dark:prose-invert prose-headings:font-bold prose-headings:text-gray-900 dark:prose-headings:text-gray-100 prose-p:text-gray-800 dark:prose-p:text-gray-300 prose-code:text-gray-900 dark:prose-code:text-gray-100 prose-code:bg-gray-100 dark:prose-code:bg-[#1a1a1a] prose-code:px-1 prose-code:py-0.5 select-none prose-code:rounded prose-code:font-mono prose-pre:bg-gray-50 dark:prose-pre:bg-[#141414] prose-pre:text-gray-900 dark:prose-pre:text-gray-100 prose-pre:border prose-pre:border-gray-200 dark:prose-pre:border-[#262626]\">\n                            <Markdown\n                                remarkPlugins={[remarkGfm, remarkBreaks]}\n                                rehypePlugins={[rehypeRaw]}\n                            >\n                                {problem.description}\n                            </Markdown>\n                        </div>\n                    </div>\n                )}\n\n                {activeTab === \"submissions\" && <Submissions problemId={problem.id} />}\n\n                {activeTab === \"solutions\" && (\n                    <div className=\"flex flex-col h-full\">\n                        {/* Sub-tabs */}\n                        <div className=\"flex items-center gap-4 px-6 border-b border-gray-100 dark:border-[#262626] bg-gray-50/30 dark:bg-[#141414]/50\">\n                            <button\n                                onClick={() => setSolutionTab(\"official\")}\n                                className={`py-3 text-sm font-bold border-b-2 transition-colors ${solutionTab === \"official\" ? \"border-orange-500 text-orange-600 dark:text-orange-500\" : \"border-transparent text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200\"}`}\n                            >\n                                Official Solution\n                            </button>\n                            <button\n                                onClick={() => setSolutionTab(\"community\")}\n                                className={`py-3 text-sm font-bold border-b-2 transition-colors ${solutionTab === \"community\" ? \"border-orange-500 text-orange-600 dark:text-orange-500\" : \"border-transparent text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200\"}`}\n                            >\n                                Community\n                            </button>\n                        </div>\n\n                        <div className=\"flex-1 overflow-y-auto px-6 py-6 custom-scrollbar\">\n                            {solutionTab === \"official\" ? (\n                                isSolved ? (\n                                    <div className=\"prose max-w-none prose-slate dark:prose-invert\n                                        prose-headings:font-bold prose-headings:tracking-tight prose-headings:text-gray-900 dark:prose-headings:text-gray-100\n                                        prose-p:text-gray-700 dark:prose-p:text-gray-300 prose-p:leading-7\n                                        prose-li:text-gray-700 dark:prose-li:text-gray-300\n                                        prose-strong:text-gray-900 dark:prose-strong:text-white prose-strong:font-bold\n                                        prose-code:text-orange-600 dark:prose-code:text-orange-400 prose-code:bg-orange-50 dark:prose-code:bg-orange-950/30 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-code:font-mono prose-code:font-medium prose-code:before:content-none prose-code:after:content-none\n                                        prose-pre:bg-white dark:prose-pre:bg-[#0a0a0a] prose-pre:p-0 prose-pre:m-0 prose-pre:border-none prose-pre:shadow-none prose-pre:rounded-lg prose-pre:my-6\n                                        prose-img:rounded-lg prose-img:border prose-img:border-gray-100 dark:prose-img:border-[#262626] prose-img:my-6\n                                        prose-blockquote:border-l-2 prose-blockquote:border-orange-500 prose-blockquote:bg-gray-50 dark:prose-blockquote:bg-[#1a1a1a] prose-blockquote:px-6 prose-blockquote:py-4 prose-blockquote:text-gray-700 dark:prose-blockquote:text-gray-300 prose-blockquote:not-italic prose-blockquote:my-6\">\n                                        {problem.solution ? (\n                                            <Markdown\n                                                remarkPlugins={[\n                                                    remarkGfm,\n                                                    remarkBreaks,\n                                                    remarkDirective,\n                                                    remarkSolutionDirective\n                                                ]}\n                                                rehypePlugins={[rehypeRaw]}\n                                                components={{\n                                                    // @ts-ignore\n                                                    'solution-group': SolutionCodeGroup\n                                                }}\n                                            >\n                                                {preprocessMarkdown(problem.solution)}\n                                            </Markdown>\n                                        ) : (\n                                            <div className=\"text-gray-500 dark:text-gray-400 italic text-center py-10\">\n                                                No official solution has been provided for this problem yet.\n                                            </div>\n                                        )}\n                                    </div>\n                                ) : (\n                                    <div className=\"flex flex-col items-center justify-center py-20 px-10 text-center space-y-4\">\n                                        <div className=\"w-16 h-16 bg-gray-100 dark:bg-[#1a1a1a] rounded-full flex items-center justify-center\">\n                                            <BadgeCheck className=\"w-8 h-8 text-gray-400\" />\n                                        </div>\n                                        <h2 className=\"text-xl font-bold text-gray-900 dark:text-gray-100\">Solution Locked</h2>\n                                        <p className=\"text-gray-600 dark:text-gray-400 max-w-xs\">\n                                            You need to successfully solve this problem to unlock the official solution.\n                                        </p>\n                                    </div>\n                                )\n                            ) : (\n                                // Community Tab\n                                <CommentTree problemId={problem.id} />\n                            )}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div >\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1667, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/languages.ts"],"sourcesContent":["\nexport interface Language {\n    id: number; // Judge0 ID\n    name: string;\n    monacoLanguage: string; // Monaco Editor language identifier\n    boilerplate: string;\n}\n\nexport const LANGUAGES: Language[] = [\n    {\n        id: 63,\n        name: \"JavaScript\",\n        monacoLanguage: \"javascript\",\n        boilerplate: `const fs = require(\"fs\");\n\nconst input = fs.readFileSync(0, \"utf8\").trim().split(/\\\\s+/);\n\n// write your code here\n\nconsole.log();`\n    },\n\n    {\n        id: 62,\n        name: \"Java\",\n        monacoLanguage: \"java\",\n        boilerplate: `import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        // write your code here\n\n        \n    }\n}`\n    },\n\n    {\n        id: 71,\n        name: \"Python\",\n        monacoLanguage: \"python\",\n        boilerplate: `import sys\n\ndata = sys.stdin.read().split()\n\n# write your code here\n\nprint()`\n    },\n\n    {\n        id: 50,\n        name: \"C\",\n        monacoLanguage: \"c\",\n        boilerplate: `#include <stdio.h>\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 54,\n        name: \"C++\",\n        monacoLanguage: \"cpp\",\n        boilerplate: `#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n    // write your code here\n\n    return 0;\n}`\n    },\n\n    {\n        id: 73,\n        name: \"Rust\",\n        monacoLanguage: \"rust\",\n        boilerplate: `use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    // write your code here\n}`\n    },\n\n    {\n        id: 60,\n        name: \"Go\",\n        monacoLanguage: \"go\",\n        boilerplate: `package main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    in := bufio.NewReader(os.Stdin)\n\n    // write your code here\n\n}`\n    },\n    {\n        id: 82,\n        name: \"SQL\",\n        monacoLanguage: \"sql\",\n        boilerplate: `` // Empty boilerplate for SQL\n    }\n];\n\nexport function getLanguageById(id: number): Language | undefined {\n    return LANGUAGES.find(lang => lang.id === id);\n}\n\nexport function getLanguageByName(name: string): Language | undefined {\n    return LANGUAGES.find(lang => lang.name === name);\n}\n\nexport const DEFAULT_LANGUAGE_ID = 63;\n\n"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,YAAwB;IACjC;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;cAMR,CAAC;IACX;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;CASrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;OAMf,CAAC;IACJ;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;CAQrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;CAOrB,CAAC;IACE;IAEA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,CAAC;;;;;;;;;;;;CAYrB,CAAC;IACE;IACA;QACI,IAAI;QACJ,MAAM;QACN,gBAAgB;QAChB,aAAa,EAAE,CAAC,4BAA4B;IAChD;CACH;AAEM,SAAS,gBAAgB,EAAU;IACtC,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;AAC9C;AAEO,SAAS,kBAAkB,IAAY;IAC1C,OAAO,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;AAChD;AAEO,MAAM,sBAAsB"}},
    {"offset": {"line": 1796, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/DriverCodeModal.tsx"],"sourcesContent":["\"use client\";\n\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { X, Code2, Copy, Check } from \"lucide-react\";\nimport { useEffect, useRef, useState } from \"react\";\nimport dynamic from \"next/dynamic\";\nimport { Loader2 } from \"lucide-react\";\nimport { useTheme } from \"next-themes\";\nimport { toast } from \"sonner\";\nimport { getLanguageById } from \"@/lib/languages\";\n\n// Dynamically import Monaco Editor to prevent SSR issues\nconst Editor = dynamic(\n  () => import(\"@monaco-editor/react\").then((mod) => mod.default),\n  {\n    ssr: false,\n    loading: () => (\n      <div className=\"flex items-center justify-center h-full\">\n        <Loader2 className=\"w-6 h-6 text-orange-500 animate-spin\" />\n      </div>\n    ),\n  }\n);\n\ninterface DriverCodeModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  driverCode: string;\n  languageId: number;\n}\n\nexport default function DriverCodeModal({\n  isOpen,\n  onClose,\n  driverCode,\n  languageId,\n}: DriverCodeModalProps) {\n  const modalRef = useRef<HTMLDivElement>(null);\n  const { resolvedTheme } = useTheme();\n  const [isCopied, setIsCopied] = useState(false);\n\n  const currentLanguage = getLanguageById(languageId);\n  const theme = resolvedTheme === \"dark\" ? \"vs-dark\" : \"vs-light\";\n\n  // Close on click outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        modalRef.current &&\n        !modalRef.current.contains(event.target as Node)\n      ) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n    }\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [isOpen, onClose]);\n\n  // Prevent body scroll when open\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = \"hidden\";\n    } else {\n      document.body.style.overflow = \"unset\";\n    }\n  }, [isOpen]);\n\n  const handleCopy = () => {\n    navigator.clipboard.writeText(driverCode);\n    setIsCopied(true);\n    toast.success(\"Driver code copied to clipboard\", {\n      className: \"rounded-xl border border-gray-200 dark:border-white/10 shadow-lg\",\n    });\n    setTimeout(() => setIsCopied(false), 2000);\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4\">\n          <motion.div\n            ref={modalRef}\n            initial={{ opacity: 0, scale: 0.95, y: 10 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 10 }}\n            transition={{ duration: 0.2 }}\n            className=\"w-full max-w-4xl h-[80vh] bg-white dark:bg-[#141414] rounded-xl shadow-2xl border border-gray-200 dark:border-[#262626] overflow-hidden flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"px-6 py-4 border-b border-gray-100 dark:border-[#262626] flex items-center justify-between bg-gray-50/50 dark:bg-[#1a1a1a]\">\n              <div className=\"flex items-center gap-2\">\n                <div className=\"p-2 bg-orange-50 dark:bg-orange-500/10 rounded-lg\">\n                    <Code2 className=\"w-5 h-5 text-orange-600 dark:text-orange-500\" />\n                </div>\n                <div>\n                    <h2 className=\"text-lg font-bold text-gray-900 dark:text-gray-100\">\n                    Driver Code\n                    </h2>\n                    <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                        This is the code that runs your solution\n                    </p>\n                </div>\n              </div>\n              <div className=\"flex items-center gap-2\">\n                <button\n                    onClick={handleCopy}\n                    className=\"p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-[#262626] rounded-lg transition-colors flex items-center gap-2 text-sm font-medium\"\n                >\n                    {isCopied ? <Check className=\"w-4 h-4\" /> : <Copy className=\"w-4 h-4\" />}\n                    {isCopied ? \"Copied\" : \"Copy\"}\n                </button>\n                <div className=\"w-px h-6 bg-gray-200 dark:bg-[#333] mx-1\" />\n                <button\n                    onClick={onClose}\n                    className=\"p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-[#262626] rounded-lg transition-colors\"\n                >\n                    <X className=\"w-5 h-5\" />\n                </button>\n              </div>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 relative bg-white dark:bg-[#1e1e1e]\">\n                 <Editor\n                    height=\"100%\"\n                    language={currentLanguage?.monacoLanguage || \"plaintext\"}\n                    value={driverCode}\n                    theme={theme}\n                    options={{\n                        readOnly: true,\n                        minimap: { enabled: false },\n                        fontSize: 14,\n                        lineNumbers: \"on\",\n                        scrollBeyondLastLine: false,\n                        automaticLayout: true,\n                        padding: { top: 16, bottom: 16 },\n                    }}\n                />\n            </div>\n\n            {/* Footer */}\n            <div className=\"px-6 py-3 bg-gray-50 dark:bg-[#1a1a1a] border-t border-gray-100 dark:border-[#262626] flex justify-between items-center text-xs text-gray-500 dark:text-gray-400\">\n                <p>Read-only mode</p>\n                <button\n                    onClick={onClose}\n                    className=\"px-4 py-2 text-sm font-bold text-white bg-gray-900 dark:bg-white dark:text-black rounded-lg hover:bg-black dark:hover:bg-gray-200 transition-colors\"\n                >\n                    Close\n                </button>\n            </div>\n          </motion.div>\n        </div>\n      )}\n    </AnimatePresence>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2124, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/lib/db.ts"],"sourcesContent":["\nimport Dexie, { type Table } from 'dexie';\n\nexport interface CodeDraft {\n    id: string; // Composite key: problemId_languageId\n    problemId: string;\n    languageId: number;\n    code: string;\n    updatedAt: number;\n}\n\nconst EXPIRATION_TIME_MS = 6 * 60 * 60 * 1000; // 6 hours\nconst DB_NAME = 'AlgoFoxDB';\n\nclass AlgoFoxDB extends Dexie {\n    codeDrafts!: Table<CodeDraft>;\n\n    constructor() {\n        super(DB_NAME);\n\n        // Version 2: new schema with id as primary key\n        // Start directly at version 2 to avoid primary key migration issues\n        this.version(2).stores({\n            codeDrafts: 'id, problemId, languageId, updatedAt'\n        });\n    }\n}\n\n// Only create database instance on client side (browser)\nlet db: AlgoFoxDB | null = null;\n\nfunction getDB(): AlgoFoxDB {\n    // Only create database in browser environment\n    if (typeof window === 'undefined') {\n        throw new Error('IndexedDB is only available in browser environment');\n    }\n\n    if (!db) {\n        db = new AlgoFoxDB();\n\n        // Initialize database with error handling for schema migration\n        db.open().catch(async (error: any) => {\n            // If migration fails due to primary key change, delete and recreate\n            if (error.name === 'UpgradeError' ||\n                error.message?.includes('primary key') ||\n                error.message?.includes('Not yet support for changing primary key')) {\n                console.warn('Database schema migration failed, recreating database...');\n                try {\n                    await Dexie.delete(DB_NAME);\n                    // Reload page to reinitialize with new schema\n                    if (typeof window !== 'undefined') {\n                        window.location.reload();\n                    }\n                } catch (deleteError) {\n                    console.error('Failed to recreate database:', deleteError);\n                }\n            } else {\n                console.error('Failed to open database:', error);\n            }\n        });\n    }\n\n    return db;\n}\n\n// Export getter function that only creates DB in browser\nexport { getDB };\n\nexport async function saveCodeDraft(userId: string, problemId: string, languageId: number, code: string) {\n    // Only save in browser environment\n    if (typeof window === 'undefined' || !userId) {\n        return;\n    }\n\n    try {\n        const db = getDB();\n        if (!db.isOpen()) {\n            await db.open();\n        }\n\n        const now = Date.now();\n        const id = `${userId}_${problemId}_${languageId}`;\n\n        // Clean up expired entries (optimistic, don't wait)\n        db.codeDrafts.where('updatedAt').below(now - EXPIRATION_TIME_MS).delete();\n\n        // Also verify if we need to migrate/cleanup old format entries (optional but nice)\n        // For now, simple key change is sufficient to segregate data.\n\n        await db.codeDrafts.put({\n            id,\n            problemId,\n            languageId,\n            code,\n            updatedAt: now\n        });\n    } catch (error: any) {\n        // If still failing, just log and continue (database will be recreated on reload)\n        console.error('Failed to save code draft:', error);\n    }\n}\n\nexport async function getCodeDraft(userId: string, problemId: string, languageId: number): Promise<string | null> {\n    // Only get in browser environment\n    if (typeof window === 'undefined' || !userId) {\n        return null;\n    }\n\n    try {\n        const db = getDB();\n        if (!db.isOpen()) {\n            await db.open();\n        }\n\n        const id = `${userId}_${problemId}_${languageId}`;\n        const draft = await db.codeDrafts.get(id);\n\n        if (!draft) return null;\n\n        const now = Date.now();\n        if (now - draft.updatedAt > EXPIRATION_TIME_MS) {\n            // Expired\n            await db.codeDrafts.delete(id);\n            return null;\n        }\n\n        return draft.code;\n    } catch (error: any) {\n        // Log error but don't throw - return null to allow app to continue\n        console.error('Failed to get code draft:', error);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AACA;;AAUA,MAAM,qBAAqB,IAAI,KAAK,KAAK,MAAM,UAAU;AACzD,MAAM,UAAU;AAEhB,MAAM,kBAAkB,yJAAK;IACzB,WAA8B;IAE9B,aAAc;QACV,KAAK,CAAC;QAEN,+CAA+C;QAC/C,oEAAoE;QACpE,IAAI,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC;YACnB,YAAY;QAChB;IACJ;AACJ;AAEA,yDAAyD;AACzD,IAAI,KAAuB;AAE3B,SAAS;IACL,8CAA8C;IAC9C;;IAIA,IAAI,CAAC,IAAI;QACL,KAAK,IAAI;QAET,+DAA+D;QAC/D,GAAG,IAAI,GAAG,KAAK,CAAC,OAAO;YACnB,oEAAoE;YACpE,IAAI,MAAM,IAAI,KAAK,kBACf,MAAM,OAAO,EAAE,SAAS,kBACxB,MAAM,OAAO,EAAE,SAAS,6CAA6C;gBACrE,QAAQ,IAAI,CAAC;gBACb,IAAI;oBACA,MAAM,yJAAK,CAAC,MAAM,CAAC;oBACnB,8CAA8C;oBAC9C,wCAAmC;wBAC/B,OAAO,QAAQ,CAAC,MAAM;oBAC1B;gBACJ,EAAE,OAAO,aAAa;oBAClB,QAAQ,KAAK,CAAC,gCAAgC;gBAClD;YACJ,OAAO;gBACH,QAAQ,KAAK,CAAC,4BAA4B;YAC9C;QACJ;IACJ;IAEA,OAAO;AACX;;AAKO,eAAe,cAAc,MAAc,EAAE,SAAiB,EAAE,UAAkB,EAAE,IAAY;IACnG,mCAAmC;IACnC,IAAI,+CAAkB,eAAe,CAAC,QAAQ;QAC1C;IACJ;IAEA,IAAI;QACA,MAAM,KAAK;QACX,IAAI,CAAC,GAAG,MAAM,IAAI;YACd,MAAM,GAAG,IAAI;QACjB;QAEA,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,KAAK,GAAG,OAAO,CAAC,EAAE,UAAU,CAAC,EAAE,YAAY;QAEjD,oDAAoD;QACpD,GAAG,UAAU,CAAC,KAAK,CAAC,aAAa,KAAK,CAAC,MAAM,oBAAoB,MAAM;QAEvE,mFAAmF;QACnF,8DAA8D;QAE9D,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;YACpB;YACA;YACA;YACA;YACA,WAAW;QACf;IACJ,EAAE,OAAO,OAAY;QACjB,iFAAiF;QACjF,QAAQ,KAAK,CAAC,8BAA8B;IAChD;AACJ;AAEO,eAAe,aAAa,MAAc,EAAE,SAAiB,EAAE,UAAkB;IACpF,kCAAkC;IAClC,IAAI,+CAAkB,eAAe,CAAC,QAAQ;QAC1C,OAAO;IACX;IAEA,IAAI;QACA,MAAM,KAAK;QACX,IAAI,CAAC,GAAG,MAAM,IAAI;YACd,MAAM,GAAG,IAAI;QACjB;QAEA,MAAM,KAAK,GAAG,OAAO,CAAC,EAAE,UAAU,CAAC,EAAE,YAAY;QACjD,MAAM,QAAQ,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;QAEtC,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,MAAM,KAAK,GAAG;QACpB,IAAI,MAAM,MAAM,SAAS,GAAG,oBAAoB;YAC5C,UAAU;YACV,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;YAC3B,OAAO;QACX;QAEA,OAAO,MAAM,IAAI;IACrB,EAAE,OAAO,OAAY;QACjB,mEAAmE;QACnE,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACX;AACJ"}},
    {"offset": {"line": 2238, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/CodeEditor.tsx"],"sourcesContent":["\"use client\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport dynamic from \"next/dynamic\";\nimport {\n  AlignLeft,\n  RotateCcw,\n  Maximize2,\n  ChevronDown,\n  Loader2,\n  Settings,\n  Minimize2,\n  Code2,\n} from \"lucide-react\";\nimport DriverCodeModal from \"./DriverCodeModal\";\nimport { getCodeDraft, saveCodeDraft } from \"@/lib/db\";\nimport { toast } from \"sonner\";\nimport {\n  LANGUAGES,\n  getLanguageById,\n  DEFAULT_LANGUAGE_ID,\n} from \"@/lib/languages\";\nimport { ProblemDomain } from \"@prisma/client\";\nimport { useTheme } from \"next-themes\";\n\n// Dynamically import Monaco Editor to prevent SSR issues\nconst Editor = dynamic(\n  () => import(\"@monaco-editor/react\").then((mod) => mod.default),\n  {\n    ssr: false,\n    loading: () => (\n      <div className=\"flex items-center justify-center h-full\">\n        <Loader2 className=\"w-6 h-6 text-orange-500 animate-spin\" />\n      </div>\n    ),\n  }\n);\n\nconst LANGUAGE_STORAGE_KEY = \"algofox_selected_language\";\nconst SQL_LANGUAGE_ID = 82; // SQL language ID\n\ninterface FunctionTemplate {\n  languageId: number;\n  functionTemplate: string;\n  driverCode: string;\n}\n\ninterface CodeEditorProps {\n  onChange?: (value: string | undefined) => void;\n  onLanguageChange?: (languageId: number) => void;\n  defaultValue?: string;\n  value?: string;\n  languageId?: number;\n  problemId?: string;\n  domain?: ProblemDomain;\n  functionTemplates?: FunctionTemplate[];\n  readOnly?: boolean;\n  userId?: string; // Add userId to props\n  settings?: {\n    fontSize: number;\n    tabSize: number;\n    theme?: \"vs-light\" | \"vs-dark\";\n    keybinding: \"standard\" | \"vim\";\n  };\n  onOpenSettings?: () => void;\n}\n\nconst AUTOSAVE_DELAY = 1000; // 1 second\n\nexport default function CodeEditor({\n  onChange,\n  onLanguageChange,\n  defaultValue,\n  value: controlledValue,\n  languageId = DEFAULT_LANGUAGE_ID,\n  problemId,\n  domain,\n  functionTemplates,\n  readOnly = false,\n  settings,\n  onOpenSettings,\n  userId = \"\",\n}: CodeEditorProps) {\n  // Get system theme\n  const { resolvedTheme } = useTheme();\n\n  // Determine the effective Monaco theme - use system dark mode if settings.theme not explicitly set\n  const effectiveTheme =\n    settings?.theme || (resolvedTheme === \"dark\" ? \"vs-dark\" : \"vs-light\");\n\n  // Filter languages based on domain: SQL problems only show SQL language\n  const availableLanguages =\n    domain === \"SQL\"\n      ? LANGUAGES.filter((lang) => lang.id === SQL_LANGUAGE_ID)\n      : LANGUAGES.filter((lang) => lang.id !== SQL_LANGUAGE_ID);\n\n  // For SQL problems, default to SQL language\n  const effectiveLanguageId =\n    domain === \"SQL\"\n      ? languageId === SQL_LANGUAGE_ID\n        ? languageId\n        : SQL_LANGUAGE_ID\n      : languageId;\n\n  // We rely on the parent key={languageId} to remount this component when language changes\n  // sc so we can use languageId prop directly.\n  const currentLanguage =\n    getLanguageById(effectiveLanguageId) || availableLanguages[0];\n\n  // Helper: get the boilerplate for the current language\n  // If function template exists for this language, use it; otherwise use default\n  const getBoilerplate = (): string => {\n    if (domain === \"SQL\") return \"\";\n    // Check if we have a function template for this language\n    if (functionTemplates && functionTemplates.length > 0) {\n      const template = functionTemplates.find(\n        (t) => t.languageId === effectiveLanguageId\n      );\n      if (template && template.functionTemplate) {\n        return template.functionTemplate;\n      }\n    }\n    // Fall back to default boilerplate from languages.ts\n    return currentLanguage.boilerplate;\n  };\n\n  const getDriverCode = (): string | null => {\n    if (domain === \"SQL\") return null;\n    if (functionTemplates && functionTemplates.length > 0) {\n      const template = functionTemplates.find(\n        (t) => t.languageId === effectiveLanguageId\n      );\n      if (template && template.driverCode) {\n        return template.driverCode;\n      }\n    }\n    return null;\n  };\n\n  const currentDriverCode = getDriverCode();\n\n  // Initialize code state\n  // If readOnly, prioritize controlledValue.\n  // Else, use domain/boilerplate logic.\n  const initialCode =\n    readOnly && controlledValue !== undefined\n      ? controlledValue\n      : domain === \"SQL\"\n      ? defaultValue || \"\"\n      : defaultValue || getBoilerplate();\n\n  const [code, setCode] = useState(initialCode);\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n  const editorRef = React.useRef<any>(null);\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const [isRestoring, setIsRestoring] = useState(false);\n  const [isMounted, setIsMounted] = useState(false);\n  const [editorError, setEditorError] = useState(false);\n  const mountRetryRef = useRef(0);\n  const MAX_RETRIES = 3;\n\n  // Initialize loading state: ALWAYS FALSE for Optimistic UI\n  // We want the editor to show up immediately.\n  const [isLoading, setIsLoading] = useState(false);\n\n  const [isSaving, setIsSaving] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n  const editorContainerRef = useRef<HTMLDivElement>(null);\n  const [isFullScreen, setIsFullScreen] = useState(false);\n  const [isDriverCodeModalOpen, setIsDriverCodeModalOpen] = useState(false);\n\n  // Track component mount state with a small delay to ensure DOM is ready\n  useEffect(() => {\n    // Small delay to ensure Monaco services are ready\n    const timer = setTimeout(() => {\n      setIsMounted(true);\n    }, 50);\n\n    return () => {\n      clearTimeout(timer);\n      setIsMounted(false);\n      setEditorError(false);\n      mountRetryRef.current = 0;\n      // Clean up editor ref - improved disposal logic\n      if (editorRef.current) {\n        try {\n          const editor = editorRef.current;\n          // Check if editor has a model before attempting disposal\n          if (editor && typeof editor.getModel === \"function\") {\n            const model = editor.getModel();\n            // Only dispose if model exists and is not already disposed\n            if (model && typeof model.isDisposed === \"function\" && !model.isDisposed()) {\n              // Dispose the model first\n              if (typeof model.dispose === \"function\") {\n                try {\n                  model.dispose();\n                } catch (e) {\n                  // Silently ignore model disposal errors\n                }\n              }\n            }\n          }\n          // Then dispose the editor itself\n          if (typeof editor.dispose === \"function\") {\n            try {\n              editor.dispose();\n            } catch (e) {\n              // Silently ignore editor disposal errors\n            }\n          }\n        } catch (error) {\n          // Ignore all disposal errors - they're harmless during unmount\n        } finally {\n          editorRef.current = null;\n        }\n      }\n    };\n  }, []);\n\n  // Suppress Monaco Editor cancellation and disposal errors (they're harmless)\n  useEffect(() => {\n    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n      const reason = event.reason;\n      const reasonStr = reason?.toString() || \"\";\n      const reasonMsg = reason?.message || \"\";\n\n      // Suppress Monaco Editor errors\n      if (\n        reasonMsg === \"Canceled\" ||\n        reasonStr.includes(\"Canceled\") ||\n        reasonStr.includes(\"InstantiationService has been disposed\") ||\n        reasonMsg.includes(\"InstantiationService has been disposed\") ||\n        reasonStr.includes(\"domNode\") ||\n        reasonMsg.includes(\"domNode\")\n      ) {\n        event.preventDefault();\n        // Retry mounting if component is still mounted\n        if (isMounted && mountRetryRef.current < MAX_RETRIES) {\n          mountRetryRef.current++;\n          setTimeout(() => {\n            if (isMounted) {\n              setEditorError(false);\n            }\n          }, 100 * mountRetryRef.current);\n        }\n        return;\n      }\n    };\n\n    const handleError = (event: ErrorEvent) => {\n      const message = event.message || \"\";\n      if (\n        message.includes(\"InstantiationService\") ||\n        message.includes(\"domNode\") ||\n        message.includes(\"Monaco\")\n      ) {\n        event.preventDefault();\n        return true;\n      }\n      return false;\n    };\n\n    window.addEventListener(\"unhandledrejection\", handleUnhandledRejection);\n    window.addEventListener(\"error\", handleError);\n    return () => {\n      window.removeEventListener(\n        \"unhandledrejection\",\n        handleUnhandledRejection\n      );\n      window.removeEventListener(\"error\", handleError);\n    };\n  }, [isMounted]);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropdownRef.current &&\n        !dropdownRef.current.contains(event.target as Node)\n      ) {\n        setIsDropdownOpen(false);\n      }\n    }\n\n    if (isDropdownOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () =>\n        document.removeEventListener(\"mousedown\", handleClickOutside);\n    }\n  }, [isDropdownOpen]);\n\n  // Handle full screen change\n  useEffect(() => {\n    const handleFullScreenChange = () => {\n      setIsFullScreen(\n        document.fullscreenElement === editorContainerRef.current\n      );\n    };\n\n    document.addEventListener(\"fullscreenchange\", handleFullScreenChange);\n    return () =>\n      document.removeEventListener(\"fullscreenchange\", handleFullScreenChange);\n  }, []);\n\n  // LOAD SAVED CODE (Only if NOT readOnly)\n  useEffect(() => {\n    if (readOnly) return; // Skip loading draft if read-only\n\n    let isMounted = true;\n    let cancelled = false;\n\n    // If no problemId, we are good with just the initial state (boilerplate)\n    if (!problemId) {\n      // ... (keeping existing logic for no problemId)\n      // If no problemId, set code based on domain\n      if (domain === \"SQL\") {\n        setCode(\"\");\n        if (editorRef.current && isMounted) {\n          try {\n            const editor = editorRef.current;\n            const model = editor.getModel?.();\n            if (model && !model.isDisposed()) {\n              editor.setValue(\"\");\n            }\n          } catch (error) {\n            console.debug(\"setValue error (safe to ignore):\", error);\n          }\n        }\n        if (onChange) onChange(\"\");\n      } else {\n        const langBoilerplate = getBoilerplate();\n        setCode(langBoilerplate);\n        if (editorRef.current && isMounted) {\n          try {\n            const editor = editorRef.current;\n            const model = editor.getModel?.();\n            if (model && !model.isDisposed()) {\n              editor.setValue(langBoilerplate);\n            }\n          } catch (error) {\n            console.debug(\"setValue error (safe to ignore):\", error);\n          }\n        }\n        if (onChange) onChange(langBoilerplate);\n      }\n      return;\n    }\n\n    async function loadDraft(retryCount = 0) {\n      // For SQL, if no saved code, just set empty and return immediately\n      // NOTE: We do NOT set isLoading to true here anymore\n\n      try {\n        if (retryCount === 0) setIsRestoring(true); // Helper spinner can still show\n\n        // Fetch draft in background\n        const savedCode = await getCodeDraft(\n          userId,\n          problemId!,\n          effectiveLanguageId\n        );\n\n        // Check if component is still mounted and effect hasn't been cancelled\n        if (!isMounted || cancelled) {\n          setIsRestoring(false);\n          return;\n        }\n\n        // Logic to set code if savedCode exists\n        // If it's a retry and we still don't have it, try again\n        if (!savedCode && retryCount === 0) {\n          await new Promise((resolve) => setTimeout(resolve, 200));\n          if (!isMounted || cancelled) {\n            setIsRestoring(false);\n            return;\n          }\n          return loadDraft(1);\n        }\n\n        // If we found saved code, update the editor!\n        if (savedCode) {\n          // Only toast if the saved code is different from what's currently shown (boilerplate)\n          // This prevents annoying toasts if they match\n          //  toast.info(\"Draft restored\");\n          const codeToSet = savedCode;\n          setCode(codeToSet);\n\n          if (editorRef.current) {\n            try {\n              const editor = editorRef.current;\n              const model = editor.getModel?.();\n              if (model && !model.isDisposed()) {\n                const currentContent = editor.getValue();\n                if (currentContent !== codeToSet) {\n                  editor.setValue(codeToSet);\n                  toast.success(\"Saved draft restored\");\n                }\n              }\n            } catch (error) {\n              console.debug(\"setValue error (safe to ignore):\", error);\n            }\n          }\n          if (onChange) onChange(codeToSet);\n        }\n        // If NO saved code, we implicitly stick with the boilerplate we already showed.\n        // No need to \"clear\" it unless it's SQL maybe?\n      } catch (error) {\n        console.error(\"Failed to load code draft:\", error);\n        // On error, we just keep the boilerplate.\n      } finally {\n        if (isMounted && !cancelled) {\n          setIsRestoring(false);\n          // setIsLoading(false); // No longer used\n        }\n      }\n    }\n\n    loadDraft();\n\n    return () => {\n      isMounted = false;\n      cancelled = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [problemId, effectiveLanguageId, readOnly, isMounted, userId]);\n\n  // HANDLE AUTOSAVE (Only if NOT readOnly)\n  const debouncedSave = (value: string) => {\n    if (!problemId || readOnly) return; // Skip saving logic entirely if readOnly\n\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    saveTimeoutRef.current = setTimeout(async () => {\n      setIsSaving(true);\n      try {\n        // Save to DB and wait for at least 500ms to show the spinner\n        await Promise.all([\n          saveCodeDraft(userId, problemId, effectiveLanguageId, value),\n          new Promise((resolve) => setTimeout(resolve, 500)),\n        ]);\n      } catch (err) {\n        console.error(\"Autosave failed:\", err);\n      } finally {\n        setIsSaving(false);\n      }\n    }, AUTOSAVE_DELAY);\n  };\n\n  const handleLanguageChange = (newLanguageId: number) => {\n    // In read-only mode, we likely disable changing lang, but if allowed:\n    if (newLanguageId === effectiveLanguageId) {\n      setIsDropdownOpen(false);\n      return;\n    }\n\n    setIsDropdownOpen(false);\n    if (onLanguageChange) {\n      onLanguageChange(newLanguageId);\n    }\n  };\n\n  const handleEditorDidMount = (editor: any, monaco: any) => {\n    if (!isMounted) return;\n\n    try {\n      editorRef.current = editor;\n      setEditorError(false);\n      mountRetryRef.current = 0;\n\n      // SECURE COPY/PASTE LOGIC\n      // We generate a unique session token for this editor instance\n      const SESSION_TOKEN_KEY = \"algofox_secure_token\";\n      const instanceToken = Math.random().toString(36).substring(2) + Date.now().toString(36);\n\n      // We attach to the CONTAINER (editorContainerRef) for robust capture.\n      // 1. Mark container as allowed for DevToolsBlocker\n      if (editorContainerRef.current) {\n          const container = editorContainerRef.current;\n          container.setAttribute(\"data-allow-clipboard\", \"true\");\n\n          // Also allow internal domNode just to be safe with traversal logic\n          const domNode = editor.getDomNode();\n          if (domNode) {\n             domNode.setAttribute(\"data-allow-clipboard\", \"true\");\n          }\n\n          // 2. Attach Capture Phase Listeners\n          // We must remove previous listeners to avoid duplicates on re-mounts if any,\n          // but since this is a functional component mount, simple addEventListener is fine\n          // (closure captures unique instanceToken).\n\n          const handleCopy = (e: ClipboardEvent) => {\n              if (e.clipboardData) {\n                  const selection = editor.getModel()?.getValueInRange(editor.getSelection());\n                  if (selection) {\n                      e.clipboardData.setData('text/plain', selection);\n                      // Inject our secure token\n                      e.clipboardData.setData('application/x-algofox-token', instanceToken);\n                      e.preventDefault();\n                  }\n              }\n          };\n\n          const handleCut = (e: ClipboardEvent) => {\n             if (e.clipboardData) {\n                  const selection = editor.getModel()?.getValueInRange(editor.getSelection());\n                  if (selection) {\n                      e.clipboardData.setData('text/plain', selection);\n                      e.clipboardData.setData('application/x-algofox-token', instanceToken);\n                      e.preventDefault();\n                      editor.trigger('source', 'cut', {});\n                  }\n              }\n          };\n\n          const handlePaste = (e: ClipboardEvent) => {\n              // Parse token\n              const token = e.clipboardData?.getData('application/x-algofox-token');\n\n              if (token === instanceToken) {\n                  // Verified! Allow to succeed.\n                  return;\n              } else {\n                  // External or Invalid\n                  e.preventDefault();\n                  e.stopPropagation();\n                  toast.error(\"Paste blocked: You can only paste code copied from this editor.\");\n              }\n          };\n\n          container.addEventListener(\"copy\", handleCopy as any, true);\n          container.addEventListener(\"cut\", handleCut as any, true);\n          container.addEventListener(\"paste\", handlePaste as any, true);\n\n          // Note: In a production app, we should save these handler refs to remove them in cleanup\n          // but for now relying on component unmount and container lifecycle is acceptable\n      }\n\n      // In readOnly mode, the editor might strictly follow `value` prop if we passed one,\n      // but setting it explicitly ensures it matches state.\n      if (code && editor) {\n        try {\n          const model = editor.getModel?.();\n          if (model && !model.isDisposed()) {\n            editor.setValue(code);\n          }\n        } catch (error) {\n          // Editor might be disposed, ignore\n          console.debug(\"Editor setValue error (safe to ignore):\", error);\n        }\n      }\n    } catch (error) {\n      console.debug(\"Editor mount error (safe to ignore):\", error);\n      // Retry mounting if we haven't exceeded max retries\n      if (mountRetryRef.current < MAX_RETRIES && isMounted) {\n        mountRetryRef.current++;\n        setTimeout(() => {\n          if (isMounted) {\n            setEditorError(false);\n          }\n        }, 100 * mountRetryRef.current);\n      } else {\n        setEditorError(true);\n      }\n    }\n  };\n\n  const handleEditorWillMount = (monaco: any) => {\n    // Ensure Monaco is ready before mounting\n    if (!isMounted) return;\n  };\n\n  // Cleanup editor on unmount\n  useEffect(() => {\n    return () => {\n      if (editorRef.current) {\n        try {\n          const editor = editorRef.current;\n          // Check if editor has a model before attempting disposal\n          if (editor && typeof editor.getModel === \"function\") {\n            const model = editor.getModel();\n            // Only dispose if model exists and is not already disposed\n            if (model && typeof model.isDisposed === \"function\" && !model.isDisposed()) {\n              // Dispose the model first\n              if (typeof model.dispose === \"function\") {\n                try {\n                  model.dispose();\n                } catch (e) {\n                  // Silently ignore model disposal errors\n                }\n              }\n            }\n          }\n          // Then dispose the editor itself\n          if (typeof editor.dispose === \"function\") {\n            try {\n              editor.dispose();\n            } catch (e) {\n              // Silently ignore editor disposal errors\n            }\n          }\n        } catch (error) {\n          // Ignore all disposal errors\n        } finally {\n          editorRef.current = null;\n        }\n      }\n      // Clear any pending save operations\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n        saveTimeoutRef.current = null;\n      }\n    };\n  }, []);\n\n  const handleFormat = () => {\n    if (editorRef.current) {\n      try {\n        const editor = editorRef.current;\n        const model = editor.getModel?.();\n        // Check if editor and model are still valid\n        if (model && !model.isDisposed()) {\n          editor.getAction(\"editor.action.formatDocument\")?.run();\n        }\n      } catch (error) {\n        console.debug(\"Format error (safe to ignore):\", error);\n      }\n    }\n  };\n\n  const handleReset = () => {\n    if (readOnly) return; // Disable reset in read-only\n\n    const resetCode = domain === \"SQL\" ? \"\" : getBoilerplate();\n    setCode(resetCode);\n    if (onChange) onChange(resetCode);\n    if (editorRef.current) {\n      try {\n        const editor = editorRef.current;\n        const model = editor.getModel?.();\n        // Check if editor and model are still valid\n        if (model && !model.isDisposed()) {\n          editor.setValue(resetCode);\n        }\n      } catch (error) {\n        console.debug(\"Reset error (safe to ignore):\", error);\n      }\n    }\n\n    if (problemId) {\n      saveCodeDraft(userId, problemId, effectiveLanguageId, resetCode).then(\n        () => {\n          toast.success(\"Code reset to default\");\n        }\n      );\n    }\n  };\n\n  const handleFullScreen = () => {\n    if (!editorContainerRef.current) return;\n\n    if (!document.fullscreenElement) {\n      editorContainerRef.current.requestFullscreen().catch((err) => {\n        console.error(\n          `Error attempting to enable full-screen mode: ${err.message} (${err.name})`\n        );\n      });\n    } else {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      }\n    }\n  };\n\n  return (\n    <div\n      ref={editorContainerRef}\n      className={`h-full flex flex-col bg-white dark:bg-[#1e1e1e] border-l border-gray-200 dark:border-[#262626] ${\n        isFullScreen ? \"fixed inset-0 z-50\" : \"\"\n      }`}\n    >\n      {/* EDITOR TOOLBAR */}\n      <div className=\"flex items-center justify-between px-4 py-2 border-b border-gray-100 dark:border-[#262626] bg-gray-50/50 dark:bg-[#1a1a1a]\">\n        <div className=\"flex items-center gap-3\">\n          <div className=\"relative\" ref={dropdownRef}>\n            <button\n              id=\"language-dropdown\"\n              onClick={() => !readOnly && setIsDropdownOpen(!isDropdownOpen)}\n              disabled={readOnly}\n              className={`flex items-center gap-2 text-xs font-medium text-gray-700 dark:text-gray-300 px-2 py-1 rounded transition-colors ${\n                readOnly\n                  ? \"opacity-70 cursor-default\"\n                  : \"hover:bg-gray-200 dark:hover:bg-[#262626]\"\n              }`}\n            >\n              {currentLanguage.name}\n              {!readOnly && (\n                <ChevronDown\n                  className={`w-3 h-3 transition-transform ${\n                    isDropdownOpen ? \"rotate-180\" : \"\"\n                  }`}\n                />\n              )}\n            </button>\n            {isDropdownOpen && !readOnly && (\n              <div className=\"absolute top-full left-0 mt-1 bg-white dark:bg-[#1a1a1a] border border-gray-200 dark:border-[#262626] rounded-lg shadow-lg z-50 min-w-30\">\n                {availableLanguages.map((lang) => (\n                  <button\n                    key={lang.id}\n                    onClick={() => handleLanguageChange(lang.id)}\n                    className={`w-full text-left px-3 py-2 text-xs hover:bg-gray-100 dark:hover:bg-[#262626] transition-colors first:rounded-t-lg last:rounded-b-lg ${\n                      effectiveLanguageId === lang.id\n                        ? \"bg-blue-50 dark:bg-blue-500/10 text-blue-700 dark:text-blue-400 font-medium\"\n                        : \"text-gray-700 dark:text-gray-300\"\n                    }`}\n                  >\n                    {lang.name}\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Driver Code Button */}\n          {currentDriverCode && !readOnly && (\n            <button\n              onClick={() => setIsDriverCodeModalOpen(true)}\n              className=\"flex items-center gap-2 text-xs font-medium text-gray-700 dark:text-gray-300 px-2 py-1 hover:bg-gray-200 dark:hover:bg-[#262626] rounded transition-colors\"\n              title=\"View Driver Code\"\n            >\n              <Code2 className=\"w-3.5 h-3.5 text-orange-600 dark:text-orange-500\" />\n              <span className=\"hidden sm:inline\">View Driver Code</span>\n            </button>\n          )}\n\n          {isSaving && (\n            <div className=\"flex items-center gap-1.5 text-xs text-orange-500 font-medium\">\n              <Loader2 className=\"w-3 h-3 animate-spin\" />\n              <span>Saving...</span>\n            </div>\n          )}\n        </div>\n\n        <div className=\"flex items-center gap-2 text-gray-500\">\n          {isRestoring && (\n            <Loader2 className=\"w-3 h-3 animate-spin text-gray-400 mr-2\" />\n          )}\n          <button\n            onClick={handleFormat}\n            className=\"p-1.5 hover:bg-gray-200 dark:hover:bg-[#262626] rounded transition-colors text-gray-500 dark:text-gray-400\"\n            title=\"Format Code\"\n          >\n            <AlignLeft className=\"w-4 h-4\" />\n          </button>\n          {!readOnly && (\n            <button\n              onClick={handleReset}\n              className=\"p-1.5 hover:bg-gray-200 dark:hover:bg-[#262626] rounded transition-colors text-gray-500 dark:text-gray-400\"\n              title=\"Reset to Default\"\n            >\n              <RotateCcw className=\"w-4 h-4\" />\n            </button>\n          )}\n          <button\n            onClick={handleFullScreen}\n            className=\"p-1.5 hover:bg-gray-200 dark:hover:bg-[#262626] rounded transition-colors text-gray-500 dark:text-gray-400\"\n            title={isFullScreen ? \"Exit Full Screen\" : \"Full Screen\"}\n          >\n            {isFullScreen ? (\n              <Minimize2 className=\"w-4 h-4\" />\n            ) : (\n              <Maximize2 className=\"w-4 h-4\" />\n            )}\n          </button>\n          {!readOnly && (\n            <button\n              onClick={onOpenSettings}\n              className=\"p-1.5 hover:bg-gray-200 dark:hover:bg-[#262626] rounded transition-colors text-gray-500 dark:text-gray-400\"\n              title=\"Editor Settings\"\n            >\n              <Settings className=\"w-4 h-4\" />\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* MONACO EDITOR */}\n      <div className=\"flex-1 relative\">\n        {isLoading ? (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-white dark:bg-[#1e1e1e] z-10\">\n            <div className=\"flex flex-col items-center gap-3\">\n              <Loader2 className=\"w-8 h-8 text-orange-500 animate-spin\" />\n              <p className=\"text-sm text-gray-500 dark:text-gray-400 font-medium\">\n                Loading your code...\n              </p>\n            </div>\n          </div>\n        ) : editorError && mountRetryRef.current >= MAX_RETRIES ? (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-white dark:bg-[#1e1e1e] z-10\">\n            <div className=\"flex flex-col items-center gap-3 text-center p-4\">\n              <p className=\"text-sm text-gray-500 dark:text-gray-400 font-medium\">\n                Editor failed to load. Please refresh the page.\n              </p>\n              <button\n                onClick={() => {\n                  setEditorError(false);\n                  mountRetryRef.current = 0;\n                  setIsMounted(true);\n                }}\n                className=\"px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors text-sm font-medium\"\n              >\n                Retry\n              </button>\n            </div>\n          </div>\n        ) : isMounted ? (\n          <Editor\n            key={`editor-${effectiveLanguageId}-${problemId || \"no-problem\"}-${\n              mountRetryRef.current\n            }`}\n            height=\"100%\"\n            language={currentLanguage.monacoLanguage}\n            value={code}\n            theme={effectiveTheme}\n            onMount={handleEditorDidMount}\n            beforeMount={handleEditorWillMount}\n            onChange={(value) => {\n              if (!isMounted) return;\n              const newVal = value || \"\";\n              setCode(newVal);\n              if (onChange) onChange(newVal);\n              debouncedSave(newVal);\n            }}\n            options={{\n              minimap: { enabled: false },\n              fontSize: settings?.fontSize || 19,\n              lineNumbers: \"on\",\n              roundedSelection: true,\n              scrollBeyondLastLine: false,\n              readOnly: readOnly, // Apply readOnly prop here\n              automaticLayout: true,\n              padding: { top: 16 },\n              tabSize: settings?.tabSize || 4,\n            }}\n            loading={\n              <div className=\"flex items-center justify-center h-full\">\n                <Loader2 className=\"w-6 h-6 text-orange-500 animate-spin\" />\n              </div>\n            }\n            onValidate={() => {}} // Suppress validation errors during disposal\n          />\n        ) : (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-white dark:bg-[#1e1e1e] z-10\">\n            <div className=\"flex flex-col items-center gap-3\">\n              <Loader2 className=\"w-8 h-8 text-orange-500 animate-spin\" />\n              <p className=\"text-sm text-gray-500 dark:text-gray-400 font-medium\">\n                Initializing editor...\n              </p>\n            </div>\n          </div>\n        )}\n      </div>\n\n      <DriverCodeModal\n        isOpen={isDriverCodeModalOpen}\n        onClose={() => setIsDriverCodeModalOpen(false)}\n        languageId={effectiveLanguageId}\n        driverCode={currentDriverCode || \"\"}\n      />\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3218, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/analytics.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\n\nexport async function getUserTopicStats(userId?: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const targetUserId = userId || session?.user?.id;\n\n  if (!targetUserId) return null;\n\n  // Fetch all accepted submissions with problem tags\n  const submissions = await prisma.submission.findMany({\n    where: {\n      userId: targetUserId,\n      status: \"ACCEPTED\",\n    },\n    include: {\n      problem: {\n        include: {\n          tags: true,\n        },\n      },\n    },\n  });\n\n  // Aggregate by tag\n  const tagCounts: Record<string, number> = {};\n  const totalSolved = submissions.length;\n\n  submissions.forEach((sub) => {\n    sub.problem.tags.forEach((tag) => {\n      tagCounts[tag.name] = (tagCounts[tag.name] || 0) + 1;\n    });\n  });\n\n  // Convert to array and take top 6\n  const data = Object.entries(tagCounts)\n    .map(([subject, count]) => ({\n      subject, // Tag name\n      A: count, // User's count\n      fullMark: Math.max(count * 1.5, 10), // Arbitrary scaling for chart visual\n    }))\n    .sort((a, b) => b.A - a.A)\n    .slice(0, 6); // Top 6 tags\n\n  return data;\n}\n\nexport async function getUserProgressHistory(userId?: string) {\n  const session = await auth.api.getSession({\n    headers: await headers()\n  });\n  const targetUserId = userId || session?.user?.id;\n\n  if (!targetUserId) return null;\n\n  const submissions = await prisma.submission.findMany({\n    where: {\n      userId: targetUserId,\n      status: \"ACCEPTED\",\n    },\n    orderBy: {\n      createdAt: \"asc\",\n    },\n    select: {\n      createdAt: true,\n    },\n  });\n\n  // Group by date (cumulative)\n  const history: { date: string; count: number }[] = [];\n  let cumulative = 0;\n  const map = new Map<string, number>();\n\n  submissions.forEach((sub) => {\n    const date = sub.createdAt.toISOString().split(\"T\")[0]; // YYYY-MM-DD\n    map.set(date, (map.get(date) || 0) + 1);\n  });\n\n  // Create cumulative data points\n  // We can just pick every accepted submission as a point, or group by day\n  // Grouping by day is cleaner\n  const sortedDates = Array.from(map.keys()).sort();\n\n  for (const date of sortedDates) {\n    const dailyCount = map.get(date) || 0;\n    cumulative += dailyCount;\n    history.push({\n        date: new Date(date).toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" }),\n        count: cumulative\n    });\n  }\n\n  // Return last 30 data points to avoid clutter, or sample them if huge\n  return history.slice(-30);\n}\n\n// Peer Comparison (Percentiles)\nexport async function getProblemStats(problemId: string, runtime: number, memory: number) {\n    const totalSubmissions = await prisma.submission.count({\n        where: { problemId, status: \"ACCEPTED\" }\n    });\n\n    if (totalSubmissions <= 1) return { runtimePercentile: 100, memoryPercentile: 100 };\n\n    // Runtime Percentile (Higher is better)\n    const slowerSubmissions = await prisma.submission.count({\n        where: {\n            problemId,\n            status: \"ACCEPTED\",\n            time: { gt: runtime }\n        }\n    });\n\n    // Memory Percentile (Higher is better)\n    const heavierSubmissions = await prisma.submission.count({\n        where: {\n            problemId,\n            status: \"ACCEPTED\",\n            memory: { gt: memory }\n        }\n    });\n\n    const runtimePercentile = Math.round((slowerSubmissions / totalSubmissions) * 100);\n    const memoryPercentile = Math.round((heavierSubmissions / totalSubmissions) * 100);\n\n    return { runtimePercentile, memoryPercentile };\n}\n"],"names":[],"mappings":";;;;;;;IAsGsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 3233, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/analytics/PeerComparisonCard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { getProblemStats } from \"@/actions/analytics\";\nimport { Zap, Database, TrendingUp } from \"lucide-react\";\n\ninterface PeerComparisonCardProps {\n    problemId: string;\n    runtime: number;\n    memory?: number; \n}\n\nexport default function PeerComparisonCard({ problemId, runtime, memory = 0 }: PeerComparisonCardProps) {\n    const [stats, setStats] = useState<{ runtimePercentile: number; memoryPercentile: number } | null>(null);\n\n    useEffect(() => {\n        if (problemId) {\n            getProblemStats(problemId, runtime, memory).then(setStats);\n        }\n    }, [problemId, runtime, memory]);\n\n    if (!stats) return null;\n\n    return (\n        <div className=\"bg-white dark:bg-[#141414] border border-gray-100 dark:border-[#262626] rounded-xl p-5 shadow-sm dark:shadow-none space-y-5 animate-in fade-in slide-in-from-bottom-4 duration-500\">\n            <h4 className=\"text-sm font-bold text-gray-800 dark:text-gray-100 flex items-center gap-2\">\n                <TrendingUp className=\"w-4 h-4 text-orange-500\" />\n                Submission Performance\n            </h4>\n\n            {/* Runtime Stat */}\n            <div className=\"space-y-2\">\n                <div className=\"flex items-center justify-between text-sm\">\n                    <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                        <span className=\"font-medium\">Runtime: <span className=\"text-gray-900 dark:text-gray-200\">{runtime.toFixed(2)}ms</span></span>\n                    </div>\n                    <div className=\"text-right\">\n                        <span className=\"font-bold text-gray-900 dark:text-white\">Beats {stats.runtimePercentile}%</span>\n                    </div>\n                </div>\n                <div className=\"h-2 bg-gray-100 dark:bg-[#262626] rounded-full overflow-hidden\">\n                    <div\n                        className=\"h-full bg-orange-500 rounded-full transition-all duration-1000 ease-out\"\n                        style={{ width: `${stats.runtimePercentile}%` }}\n                    />\n                </div>\n            </div>\n\n            {/* Memory Stat */}\n            <div className=\"space-y-2\">\n                <div className=\"flex items-center justify-between text-sm\">\n                    <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                        <span className=\"font-medium\">Memory: <span className=\"text-gray-900 dark:text-gray-200\">{memory.toFixed(1)}KB</span></span>\n                    </div>\n                    <div className=\"text-right\">\n                        <span className=\"font-bold text-gray-900 dark:text-white\">Beats {stats.memoryPercentile}%</span>\n                    </div>\n                </div>\n                <div className=\"h-2 bg-gray-100 dark:bg-[#262626] rounded-full overflow-hidden\">\n                    <div\n                        className=\"h-full bg-orange-500 rounded-full transition-all duration-1000 ease-out\"\n                        style={{ width: `${stats.memoryPercentile}%` }}\n                    />\n                </div>\n            </div>\n\n            {(stats.runtimePercentile > 80 || stats.memoryPercentile > 80) && (\n                 <p className=\"text-xs text-gray-500 dark:text-gray-400 text-center pt-2 border-t border-dashed border-gray-200 dark:border-[#333]\">\n                     Incredible! Your solution is highly optimized.\n                </p>\n            )}\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAYe,SAAS,mBAAmB,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,EAA2B;;IAClG,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAiE;IAEnG,IAAA,0KAAS;wCAAC;YACN,IAAI,WAAW;gBACX,IAAA,qKAAe,EAAC,WAAW,SAAS,QAAQ,IAAI,CAAC;YACrD;QACJ;uCAAG;QAAC;QAAW;QAAS;KAAO;IAE/B,IAAI,CAAC,OAAO,OAAO;IAEnB,qBACI,6LAAC;QAAI,WAAU;;0BACX,6LAAC;gBAAG,WAAU;;kCACV,6LAAC,mOAAU;wBAAC,WAAU;;;;;;oBAA4B;;;;;;;0BAKtD,6LAAC;gBAAI,WAAU;;kCACX,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC;oCAAK,WAAU;;wCAAc;sDAAS,6LAAC;4CAAK,WAAU;;gDAAoC,QAAQ,OAAO,CAAC;gDAAG;;;;;;;;;;;;;;;;;;0CAElH,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC;oCAAK,WAAU;;wCAA0C;wCAAO,MAAM,iBAAiB;wCAAC;;;;;;;;;;;;;;;;;;kCAGjG,6LAAC;wBAAI,WAAU;kCACX,cAAA,6LAAC;4BACG,WAAU;4BACV,OAAO;gCAAE,OAAO,GAAG,MAAM,iBAAiB,CAAC,CAAC,CAAC;4BAAC;;;;;;;;;;;;;;;;;0BAM1D,6LAAC;gBAAI,WAAU;;kCACX,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC;oCAAK,WAAU;;wCAAc;sDAAQ,6LAAC;4CAAK,WAAU;;gDAAoC,OAAO,OAAO,CAAC;gDAAG;;;;;;;;;;;;;;;;;;0CAEhH,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC;oCAAK,WAAU;;wCAA0C;wCAAO,MAAM,gBAAgB;wCAAC;;;;;;;;;;;;;;;;;;kCAGhG,6LAAC;wBAAI,WAAU;kCACX,cAAA,6LAAC;4BACG,WAAU;4BACV,OAAO;gCAAE,OAAO,GAAG,MAAM,gBAAgB,CAAC,CAAC,CAAC;4BAAC;;;;;;;;;;;;;;;;;YAKxD,CAAC,MAAM,iBAAiB,GAAG,MAAM,MAAM,gBAAgB,GAAG,EAAE,mBACxD,6LAAC;gBAAE,WAAU;0BAAsH;;;;;;;;;;;;AAMpJ;GA7DwB;KAAA"}},
    {"offset": {"line": 3472, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/TestCases.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { CheckCircle2, XCircle, Terminal, Lock, Clock, AlertCircle, Code2 } from 'lucide-react';\nimport { ProblemTestCase, TestCase } from '@prisma/client';\nimport PeerComparisonCard from '@/components/analytics/PeerComparisonCard';\n\ninterface TestCasesProps {\n    cases?: ProblemTestCase[];\n    results?: TestCase[];\n    mode?: \"RUN\" | \"SUBMIT\" | null;\n    status?: string | null;\n    problemId?: string;\n}\n\nexport default function TestCases({ cases, results, mode, status, problemId }: TestCasesProps) {\n    const [activeTab, setActiveTab] = useState<number | \"console\">(0);\n\n    // Check if there's any compilation error or error message\n    const hasError = useMemo(() => {\n        // If overall status implies error, return true\n        if (status === \"COMPILE_ERROR\" || status === \"RUNTIME_ERROR\") return true;\n\n        if (!results || results.length === 0) return false;\n        // Check if any test case has COMPILE_ERROR status, RUNTIME_ERROR status, or error message\n        const hasErr = results.some(r =>\n            r.status === \"COMPILE_ERROR\" ||\n            r.status === \"RUNTIME_ERROR\" ||\n            (r.errorMessage && r.errorMessage.trim().length > 0)\n        );\n        return hasErr;\n    }, [results, status]);\n\n    const errorMessage = useMemo(() => {\n        // If system error (status error but no results), can't get specific message from test cases\n        if ((status === \"COMPILE_ERROR\" || status === \"RUNTIME_ERROR\") && (!results || results.length === 0)) {\n            return \"Execution failed. The server might be unreachable or the code caused a fatal system error.\";\n        }\n\n        if (!results || results.length === 0) return null;\n        // Find the first error message (prefer COMPILE_ERROR)\n        // For compilation errors, all test cases usually have the same error\n        const compileError = results.find(r => r.status === \"COMPILE_ERROR\" && r.errorMessage && r.errorMessage.trim().length > 0);\n        if (compileError?.errorMessage) return compileError.errorMessage.trim();\n\n        const runtimeError = results.find(r => r.status === \"RUNTIME_ERROR\" && r.errorMessage && r.errorMessage.trim().length > 0);\n        if (runtimeError?.errorMessage) return runtimeError.errorMessage.trim();\n\n        // Try to find any error message\n        const anyError = results.find(r => r.errorMessage && r.errorMessage.trim().length > 0);\n        if (anyError?.errorMessage) return anyError.errorMessage.trim();\n\n        return null;\n    }, [results, status]);\n\n    // Get error details for console (defined before useEffect that uses it)\n    const errorDetails = useMemo(() => {\n        // Handle system level errors (no results)\n        if ((status === \"COMPILE_ERROR\" || status === \"RUNTIME_ERROR\") && (!results || results.length === 0)) {\n            return {\n                type: status === \"COMPILE_ERROR\" ? \"Compilation Error\" : \"Runtime Error\",\n                status: status,\n                message: \"System Error: The execution environment returned an error without test case details. This often indicates a connection issue with the judge server or a fatal crash.\",\n                testCaseIndex: undefined,\n                time: undefined,\n                memory: undefined\n            };\n        }\n\n        if (!results || results.length === 0) return null;\n\n        // Find error with most details - check for COMPILE_ERROR first (even without errorMessage)\n        const compileError = results.find(r => r.status === \"COMPILE_ERROR\");\n        if (compileError) {\n            return {\n                type: \"Compilation Error\",\n                status: \"COMPILE_ERROR\",\n                message: compileError.errorMessage || \"Compilation failed\",\n                testCaseIndex: compileError.index,\n                time: undefined,\n                memory: undefined\n            };\n        }\n\n        // Find RUNTIME_ERROR (even without errorMessage)\n        const runtimeError = results.find(r => r.status === \"RUNTIME_ERROR\");\n        if (runtimeError) {\n            // Provide more descriptive default message if errorMessage is missing\n            const errorMsg = runtimeError.errorMessage?.trim();\n            const defaultMsg = errorMsg\n                ? errorMsg\n                : \"A runtime error occurred. This usually means:\\n- Division by zero\\n- Array index out of bounds\\n- Null pointer exception\\n- Stack overflow\\n- Other execution-time errors\";\n\n            return {\n                type: \"Runtime Error\",\n                status: \"RUNTIME_ERROR\",\n                message: defaultMsg,\n                testCaseIndex: runtimeError.index,\n                time: runtimeError.time,\n                memory: runtimeError.memory\n            };\n        }\n\n        // Find any error with error message\n        const anyError = results.find(r => r.errorMessage && r.errorMessage.trim().length > 0);\n        if (anyError) {\n            return {\n                type: \"Error\",\n                status: anyError.status,\n                message: anyError.errorMessage,\n                testCaseIndex: anyError.index,\n                time: anyError.time,\n                memory: anyError.memory\n            };\n        }\n\n        // Find any error status (even without message)\n        const anyErrorStatus = results.find(r =>\n            r.status !== \"ACCEPTED\" &&\n            r.status !== \"PENDING\" &&\n            (r.status === \"WRONG_ANSWER\" || r.status === \"TIME_LIMIT_EXCEEDED\" || r.status === \"MEMORY_LIMIT_EXCEEDED\")\n        );\n        if (anyErrorStatus) {\n            return {\n                type: anyErrorStatus.status.replace(/_/g, \" \"),\n                status: anyErrorStatus.status,\n                message: anyErrorStatus.errorMessage || `${anyErrorStatus.status.replace(/_/g, \" \")} occurred`,\n                testCaseIndex: anyErrorStatus.index,\n                time: anyErrorStatus.time,\n                memory: anyErrorStatus.memory\n            };\n        }\n\n        return null;\n    }, [results, status]);\n\n    // Auto-switch to console tab when error is first detected\n    // Reset to first test case when results are cleared\n    useEffect(() => {\n        if (!results || results.length === 0) {\n            // No results, go back to first test case\n            setActiveTab(0);\n        } else if (hasError) {\n            // Always switch to console when there's an error\n            // This ensures runtime errors are visible\n            setActiveTab(\"console\");\n        }\n    }, [hasError, results]);\n\n    // Calculate runtime and memory\n    const { submissionRuntime, submissionMemory } = useMemo(() => {\n        if (!results || status !== \"ACCEPTED\") return { submissionRuntime: 0, submissionMemory: 0 };\n        const time = results.reduce((acc, curr) => acc + (curr.time || 0), 0);\n        const mem = results.reduce((max, curr) => Math.max(max, curr.memory || 0), 0);\n        return { submissionRuntime: time, submissionMemory: mem };\n    }, [results, status]);\n\n    // Ensure cases is always an array\n    const safeCases = cases || [];\n\n    // Filter to show only public (non-hidden) test cases in the UI\n    const publicCases = safeCases.filter(tc => !tc.hidden);\n\n    // Determine which test cases to display:\n    // - If no results: show only public test cases\n    // - If results exist and mode is SUBMIT: show all test cases (public + hidden) but hide contents\n    // - If results exist and mode is RUN: show only public test cases (map results to public cases)\n    let displayCases: ProblemTestCase[];\n    let totalCount: number;\n    let resultsMap: Map<number, TestCase> | null = null;\n\n    if (results && results.length > 0) {\n        // Create a map of original index -> result for easier lookup\n        resultsMap = new Map(results.map(r => [r.index, r]));\n\n        if (mode === \"SUBMIT\") {\n            // For SUBMIT mode, show all test cases (we'll hide contents for hidden ones)\n            displayCases = safeCases;\n            totalCount = safeCases.length;\n        } else {\n            // For RUN mode, show only public test cases\n            // Results are stored with original indices, so we need to map them\n            displayCases = publicCases;\n            totalCount = publicCases.length;\n        }\n    } else {\n        // No results yet, show only public test cases\n        displayCases = publicCases;\n        totalCount = publicCases.length;\n    }\n\n    // Generate indices array [0, 1, 2...]\n    const indices = Array.from({ length: totalCount }, (_, i) => i);\n\n    return (\n        <div className=\"h-full flex flex-col bg-white dark:bg-[#0a0a0a] border-t border-gray-200 dark:border-[#262626]\">\n            {/* Header */}\n            <div className=\"flex items-center gap-4 px-4 py-2 bg-gray-50/50 dark:bg-[#0a0a0a] border-b border-gray-100 dark:border-[#1a1a1a]\">\n                <div className=\"flex items-center gap-2 text-sm font-semibold text-gray-700 dark:text-gray-300\">\n                    <Terminal className=\"w-4 h-4 text-orange-500\" />\n                    Test Cases\n                </div>\n            </div>\n\n            {/* Tabs and Content */}\n            <div className=\"px-4 py-3 flex-1 flex flex-col overflow-hidden\">\n                <div className=\"flex gap-2 mb-4 overflow-x-auto pb-1 custom-scrollbar\">\n                    {/* Console Tab - ALWAYS show FIRST if there's an error, with prominent styling */}\n                    {hasError && (\n                        <button\n                            onClick={() => setActiveTab(\"console\")}\n                            className={`\n                                flex items-center gap-2 px-4 py-1.5 rounded-lg text-xs font-medium transition-all whitespace-nowrap border\n                                ${activeTab === \"console\"\n                                    ? 'bg-red-100 text-red-900 border-red-300 shadow-sm font-semibold'\n                                    : 'text-red-600 border-red-200 bg-red-50 hover:bg-red-100 hover:text-red-700 font-medium'\n                                }\n                            `}\n                        >\n                            <AlertCircle className=\"w-3.5 h-3.5\" />\n                            Console\n                        </button>\n                    )}\n                    {indices.map((displayIndex) => {\n                        const testCase = displayCases[displayIndex];\n                        // Find the original index of this test case in safeCases\n                        const originalIndex = safeCases.findIndex(tc => tc.id === testCase.id);\n                        // Get result using original index\n                        const result = resultsMap?.get(originalIndex);\n                        const isHidden = testCase.hidden;\n                        const status = result?.status;\n\n                        return (\n                            <button\n                                key={displayIndex}\n                                onClick={() => setActiveTab(displayIndex)}\n                                className={`\n                                    flex items-center gap-2 px-4 py-1.5 rounded-lg text-xs font-medium transition-all whitespace-nowrap border\n                                    ${activeTab === displayIndex\n                                        ? 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-900 dark:text-gray-100 border-gray-200 dark:border-[#262626] shadow-sm'\n                                        : 'text-gray-500 dark:text-gray-400 border-transparent hover:bg-gray-50 dark:hover:bg-[#141414] hover:text-gray-700 dark:hover:text-gray-300'\n                                    }\n                                    ${status === 'ACCEPTED' ? 'bg-green-50 dark:bg-green-500/10 border-green-200 dark:border-green-500/30' : ''}\n                                    ${status === 'PROCESSING' ? 'bg-orange-50 dark:bg-orange-500/10 border-orange-200 dark:border-orange-500/30' : ''}\n                                    ${status && status !== 'ACCEPTED' && status !== 'PENDING' && status !== 'PROCESSING' ? 'bg-red-50 dark:bg-red-500/10 border-red-200 dark:border-red-500/30' : ''}\n                                `}\n                            >\n                                {status === 'ACCEPTED' && <CheckCircle2 className=\"w-3.5 h-3.5 text-green-500\" />}\n                                {status && status !== 'ACCEPTED' && status !== 'PENDING' && status !== 'PROCESSING' && <XCircle className=\"w-3.5 h-3.5 text-red-500\" />}\n                                {status === 'PENDING' && <Clock className=\"w-3.5 h-3.5 text-gray-400\" />}\n                                {status === 'PROCESSING' && <div className=\"w-3 h-3 border-2 border-orange-300 border-t-orange-500 rounded-full animate-spin\" />}\n\n                                {mode === \"SUBMIT\" && isHidden ? `Case ${originalIndex + 1}` : (isHidden ? \"Hidden Case\" : `Case ${originalIndex + 1}`)}\n                            </button>\n                        );\n                    })}\n                </div>\n\n                {/* Peer Comparison Stats (Only on Accepted Submission) */}\n                {status === \"ACCEPTED\" && mode === \"SUBMIT\" && problemId && (\n                    <div className=\"mb-4\">\n                        <PeerComparisonCard\n                            problemId={problemId}\n                            runtime={submissionRuntime}\n                            memory={submissionMemory}\n                        />\n                    </div>\n                )}\n\n                {/* Content */}\n                <div className=\"flex-1 overflow-hidden\">\n                    {activeTab === \"console\" && hasError ? (\n                        errorDetails ? (\n                            /* Console Content - Full error details */\n                            <div className=\"h-full flex flex-col bg-white dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-[#262626] overflow-hidden shadow-sm\">\n                                {/* Console Header */}\n                                <div className=\"flex items-center gap-2 px-4 py-2 bg-gray-50 dark:bg-[#141414] border-b border-gray-200 dark:border-[#262626]\">\n                                    <Code2 className=\"w-4 h-4 text-gray-500\" />\n                                    <span className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Console Output</span>\n                                    <div className=\"ml-auto flex items-center gap-2\">\n                                        <div className={`px-2 py-0.5 rounded text-xs font-medium ${errorDetails.status === \"COMPILE_ERROR\" || errorDetails.status === \"RUNTIME_ERROR\"\n                                            ? \"bg-red-50 text-red-700 border border-red-200\"\n                                            : \"bg-amber-50 text-amber-700 border border-amber-200\"\n                                            }`}>\n                                            {errorDetails.type}\n                                        </div>\n                                    </div>\n                                </div>\n\n                                {/* Console Content */}\n                                <div className=\"flex-1 overflow-auto p-4\">\n                                    <div className=\"space-y-4\">\n                                        {/* Error Type */}\n                                        <div className=\"flex items-center gap-2\">\n                                            <AlertCircle className={`w-4 h-4 ${errorDetails.status === \"COMPILE_ERROR\" || errorDetails.status === \"RUNTIME_ERROR\" ? \"text-red-500\" : \"text-amber-500\"\n                                                }`} />\n                                            <span className={`text-sm font-semibold ${errorDetails.status === \"COMPILE_ERROR\" || errorDetails.status === \"RUNTIME_ERROR\" ? \"text-red-700\" : \"text-amber-700\"\n                                                }`}>\n                                                {errorDetails.type}\n                                            </span>\n                                        </div>\n\n                                        {/* Error Location */}\n                                        {errorDetails.testCaseIndex !== undefined && (\n                                            <div className=\"text-xs text-gray-500\">\n                                                <span className=\"font-medium text-gray-700\">Test Case:</span> {errorDetails.testCaseIndex + 1}\n                                            </div>\n                                        )}\n\n                                        {/* Error Stats */}\n                                        {((errorDetails.time !== null && errorDetails.time !== undefined) || (errorDetails.memory !== null && errorDetails.memory !== undefined)) && (\n                                            <div className=\"flex items-center gap-4 text-xs text-gray-500\">\n                                                {errorDetails.time !== null && errorDetails.time !== undefined && (\n                                                    <span className=\"flex items-center gap-1\">\n                                                        <Clock className=\"w-3 h-3\" />\n                                                        Time: {errorDetails.time}s\n                                                    </span>\n                                                )}\n                                                {errorDetails.memory && (\n                                                    <span>Memory: {errorDetails.memory}KB</span>\n                                                )}\n                                            </div>\n                                        )}\n\n                                        {/* Error Message */}\n                                        <div className=\"mt-4\">\n                                            <div className=\"text-xs text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide font-semibold\">Error Details</div>\n                                            <div className=\"bg-red-50/50 dark:bg-red-500/10 border border-red-100 dark:border-red-500/30 rounded-lg p-4 font-mono text-sm text-red-900 dark:text-red-300 whitespace-pre-wrap overflow-x-auto\">\n                                                {errorDetails.message}\n                                            </div>\n                                        </div>\n\n                                        {/* Error Status */}\n                                        <div className=\"text-xs text-gray-500\">\n                                            <span className=\"font-medium text-gray-700\">Status:</span>{\" \"}\n                                            <span className=\"font-mono text-gray-600\">\n                                                {errorDetails.status.replace(/_/g, \" \")}\n                                            </span>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        ) : (\n                            /* Fallback: Show error info even when errorDetails is null */\n                            <div className=\"h-full flex flex-col bg-white rounded-lg border border-gray-200 overflow-hidden shadow-sm\">\n                                <div className=\"flex items-center gap-2 px-4 py-2 bg-gray-50 border-b border-gray-200\">\n                                    <Code2 className=\"w-4 h-4 text-amber-500\" />\n                                    <span className=\"text-sm font-semibold text-gray-700\">Console</span>\n                                    <div className=\"ml-auto\">\n                                        <div className=\"px-2 py-0.5 rounded text-xs font-medium bg-amber-50 text-amber-700 border border-amber-200\">\n                                            Error Detected\n                                        </div>\n                                    </div>\n                                </div>\n                                <div className=\"flex-1 overflow-auto p-4\">\n                                    <div className=\"space-y-4\">\n                                        <div className=\"flex items-center gap-2\">\n                                            <AlertCircle className=\"w-4 h-4 text-amber-500\" />\n                                            <span className=\"text-sm font-semibold text-amber-700\">Runtime or Compilation Error</span>\n                                        </div>\n                                        <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-4\">\n                                            <div className=\"text-xs text-gray-500 mb-2 uppercase tracking-wide font-semibold\">Error Information</div>\n                                            <div className=\"text-sm space-y-2\">\n                                                {results && results.length > 0 && (\n                                                    <>\n                                                        {results.some(r => r.status === \"RUNTIME_ERROR\") && (\n                                                            <div>\n                                                                <span className=\"text-gray-500\">Status: </span>\n                                                                <span className=\"text-red-600 font-mono font-medium\">RUNTIME_ERROR</span>\n                                                            </div>\n                                                        )}\n                                                        {results.some(r => r.status === \"COMPILE_ERROR\") && (\n                                                            <div>\n                                                                <span className=\"text-gray-500\">Status: </span>\n                                                                <span className=\"text-red-600 font-mono font-medium\">COMPILE_ERROR</span>\n                                                            </div>\n                                                        )}\n                                                        {/* Show error messages from all test cases with errors */}\n                                                        {results.filter(r => (r.status === \"RUNTIME_ERROR\" || r.status === \"COMPILE_ERROR\") && r.errorMessage).map((errorResult, idx) => (\n                                                            <div key={idx} className=\"mt-3 p-3 bg-red-50 border border-red-100 rounded\">\n                                                                <div className=\"text-xs text-gray-500 mb-1\">Test Case {errorResult.index + 1}:</div>\n                                                                <div className=\"text-sm text-red-700 font-mono whitespace-pre-wrap\">{errorResult.errorMessage}</div>\n                                                            </div>\n                                                        ))}\n                                                        {!results.some(r => (r.status === \"RUNTIME_ERROR\" || r.status === \"COMPILE_ERROR\") && r.errorMessage) && (\n                                                            <div className=\"mt-4 text-xs text-gray-500\">\n                                                                No detailed error message available. Check the test case tabs above for more information.\n                                                            </div>\n                                                        )}\n                                                    </>\n                                                )}\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        )\n                    ) : (() => {\n                        if (typeof activeTab !== \"number\") return null;\n                        const displayIndex = activeTab;\n                        if (displayIndex >= totalCount) return <div className='text-gray-400 text-sm'>Select a case</div>;\n\n                        const testCase = displayCases[displayIndex];\n                        // Find the original index of this test case in safeCases\n                        const originalIndex = safeCases.findIndex(tc => tc.id === testCase.id);\n                        // Get result using original index\n                        const result = resultsMap?.get(originalIndex);\n                        const isHidden = testCase.hidden;\n\n                        // In SUBMIT mode, hide contents for all test cases (public and hidden)\n                        const hideContents = mode === \"SUBMIT\";\n\n                        return (\n                            <div className=\"space-y-6\">\n                                {/* Result Status Banner */}\n                                {result && (\n                                    <div className={`\n                                        p-3 rounded-lg border text-sm font-medium flex items-center justify-between\n                                        ${result.status === 'ACCEPTED' ? 'bg-green-50 text-green-700 border-green-100 dark:bg-green-500/10 dark:text-green-400 dark:border-green-500/20' :\n                                            result.status === 'PENDING' ? 'bg-gray-50 text-gray-600 border-gray-100 dark:bg-gray-800/50 dark:text-gray-400 dark:border-gray-700' :\n                                            result.status === 'PROCESSING' ? 'bg-orange-50 text-orange-700 border-orange-100 dark:bg-orange-500/10 dark:text-orange-400 dark:border-orange-500/20' :\n                                                'bg-red-50 text-red-700 border-red-100 dark:bg-red-500/10 dark:text-red-400 dark:border-red-500/20'}\n                                    `}>\n                                        <span className=\"flex items-center gap-2\">\n                                            {result.status === 'PENDING' ? 'IN QUEUE' :\n                                             result.status === 'PROCESSING' ? 'EXECUTING...' :\n                                             result.status.replace(/_/g, \" \")}\n                                        </span>\n                                        <div className=\"flex items-center gap-4 text-xs opacity-80\">\n                                            {result.time !== null && (\n                                                <span className=\"flex items-center gap-1\">\n                                                    <Clock className=\"w-3 h-3\" />\n                                                    {result.time}s\n                                                </span>\n                                            )}\n                                        </div>\n                                    </div>\n                                )}\n\n                                {(isHidden || hideContents) ? (\n                                    <div className=\"flex flex-col items-center justify-center p-8 text-gray-400 dark:text-gray-500 border-2 border-dashed border-gray-100 dark:border-[#262626] rounded-xl bg-gray-50/50 dark:bg-[#141414]\">\n                                        <Lock className=\"w-8 h-8 mb-2 opacity-50\" />\n                                        <span className=\"text-sm font-medium\">\n                                            {hideContents ? \"Test case contents are hidden\" : \"This test case is hidden\"}\n                                        </span>\n                                    </div>\n                                ) : (\n                                    <>\n                                        <div>\n                                            <div className=\"text-xs font-semibold text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide\">Input</div>\n                                            <div className=\"bg-gray-50 dark:bg-[#141414] border border-gray-100 dark:border-[#262626] rounded-lg p-3 font-mono text-sm text-gray-800 dark:text-gray-300 whitespace-pre-wrap\">\n                                                {testCase.input}\n                                            </div>\n                                        </div>\n\n                                        {/* Output Display Grid */}\n                                        <div className=\"grid grid-cols-2 gap-4\">\n                                            <div>\n                                                <div className=\"text-xs font-semibold text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide\">Expected Output</div>\n                                                <div className=\"bg-gray-50 dark:bg-[#141414] border border-gray-100 dark:border-[#262626] rounded-lg p-3 font-mono text-sm text-gray-800 dark:text-gray-300 whitespace-pre-wrap h-full\">\n                                                    {testCase.output}\n                                                </div>\n                                            </div>\n                                            <div>\n                                                <div className=\"text-xs font-semibold text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide\">Your Output</div>\n                                                <div className={`\n                                                    border rounded-lg p-3 font-mono text-sm whitespace-pre-wrap h-full\n                                                    ${result?.status === 'ACCEPTED'\n                                                        ? 'bg-green-50/50 dark:bg-green-500/10 border-green-100 dark:border-green-500/30 text-green-900 dark:text-green-300'\n                                                        : result?.status === 'WRONG_ANSWER'\n                                                            ? 'bg-red-50/50 dark:bg-red-500/10 border-red-100 dark:border-red-500/30 text-red-900 dark:text-red-300'\n                                                            : 'bg-gray-50 dark:bg-[#141414] border-gray-100 dark:border-[#262626] text-gray-800 dark:text-gray-300'\n                                                    }\n                                                `}>\n                                                    {/* Prioritize showing stdout if available, otherwise show \"No output\" or similar placeholder */}\n                                                    {/* Note: result might be typed as TestCase but need to ensure it includes stdout */}\n                                                    {(result as any)?.stdout || (result?.status === 'PENDING' ? '...' : 'No output')}\n                                                </div>\n                                            </div>\n                                        </div>\n                                    </>\n                                )}\n                            </div>\n                        );\n                    })()}\n                </div>\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4436, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/problems.ts"],"sourcesContent":["\"use server\";\n\nimport { ProblemService } from \"@/core/services/problem.service\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING PUBLIC PROBLEMS\n\nexport async function getProblems(\n    page: number = 1,\n    pageSize: number = 10,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\",\n    difficulty?: Difficulty,\n    tags?: string[],\n    cursor?: string\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `problems-${domain}-${type}${difficulty ? `-${difficulty}` : ''}${tags && tags.length > 0 ? `-${tags.join('-')}` : ''}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-list', `problems-${domain}-${type}`);\n\n    return ProblemService.getProblems(page, pageSize, type, domain, userId, difficulty, tags || [], cursor);\n}\n\n// GETTING ADMIN PROBLEMS\n\nexport async function getAdminProblems(\n    page: number = 1,\n    pageSize: number = 50,\n    domain?: ProblemDomain,\n    excludeDifficulty?: Difficulty,\n    type?: ProblemType\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const tagKey = `admin-problems-${domain || 'all'}${excludeDifficulty ? `-exclude-${excludeDifficulty}` : ''}${type ? `-type-${type}` : ''}-page-${page}`;\n    cacheTag(tagKey, 'admin-problems-list');\n\n    return ProblemService.getAdminProblems(page, pageSize, domain, excludeDifficulty, type);\n}\n\n// SEARCHING FOR PROBLEMS\n\nexport async function searchProblems(\n    term: string,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\"\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes for search results\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `search-${domain}-${type}-${term.toLowerCase().slice(0, 20)}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-search');\n\n    return ProblemService.searchProblems(term, type, domain, userId);\n}\n\n// GETTING A PROBLEM BY SLUG CACHED\n\nexport async function getProblem(slug: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-${slug}`, 'problems-list');\n\n    return ProblemService.getProblem(slug);\n}\n\n\n// CREATING A PROBLEM --> ADMIN ONLY\n\nexport async function createProblem(data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    domain?: ProblemDomain;\n    testCases: { input: string; output: string; hidden?: boolean }[];\n    tags?: string[];\n    useFunctionTemplate?: boolean;\n    functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n    solution?: string | null;\n}) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.createProblem(data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(\"/admin/problems\");\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag('problems-SQL-PRACTICE');\n        updateTag('problems-DSA-PRACTICE');\n    }\n\n    return result;\n}\n\n\n// GETTING A PROBLEM BY ID\nexport async function getProblemById(id: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-id-${id}`, 'problems-list');\n\n    return ProblemService.getProblemById(id);\n}\n\n// NAVIGATION ACTIONS\n\nexport async function getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getNextProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getPreviousProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n    // No cache for random\n    return ProblemService.getRandomProblem(domain, type);\n}\n\n\n// UPDATING A PROBLEM --> ADMIN ONLY\nexport async function updateProblem(id: string, data: any) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.updateProblem(id, data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag(`problems-${result.data?.domain || 'DSA'}-${result.data?.type || 'PRACTICE'}`);\n        updateTag(`problem-${result.data?.slug}`);\n    }\n\n    return result;\n}\n\n\n// DELETING A PROBLEM --> ADMIN ONLY\nexport async function deleteProblem(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.deleteProblem(id);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n    }\n\n    return result;\n}\n"],"names":[],"mappings":";;;;;;;IAkKsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 4451, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/user.action.ts"],"sourcesContent":["\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        await prisma.user.update({\n            where: { id: userId },\n            data: {\n                name: data.name,\n                bio: data.bio,\n                leetCodeHandle: data.leetCodeHandle,\n                codeChefHandle: data.codeChefHandle,\n                codeforcesHandle: data.codeforcesHandle,\n                githubHandle: data.githubHandle,\n            }\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAasB,eAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 4466, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/UserPoints.tsx"],"sourcesContent":["\n// TODO : MAKE IT SERVER COMPONENT AND OPTIMIZE\n\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { getUserScore } from \"@/actions/user.action\";\nimport { Coins } from \"lucide-react\";\n\ninterface UserPointsProps {\n    className?: string;\n}\n\nexport default function UserPoints({ className = \"\" }: UserPointsProps) {\n    const [points, setPoints] = useState<number | null>(null);\n    const [isLoading, setIsLoading] = useState(true);\n\n    useEffect(() => {\n        async function fetchPoints() {\n            try {\n                const score = await getUserScore();\n                setPoints(score);\n            } catch (error) {\n                console.error(\"Failed to fetch user points:\", error);\n                setPoints(0);\n            } finally {\n                setIsLoading(false);\n            }\n        }\n\n        fetchPoints();\n    }, []);\n\n    // Refresh points when window gains focus or when points are updated\n    useEffect(() => {\n        const handleFocus = async () => {\n            try {\n                const score = await getUserScore();\n                setPoints(score);\n            } catch (error) {\n                console.error(\"Failed to refresh user points:\", error);\n            }\n        };\n\n        const handlePointsUpdated = async () => {\n            try {\n                const score = await getUserScore();\n                setPoints(score);\n            } catch (error) {\n                console.error(\"Failed to refresh user points:\", error);\n            }\n        };\n\n        window.addEventListener(\"focus\", handleFocus);\n        window.addEventListener(\"pointsUpdated\", handlePointsUpdated);\n\n        return () => {\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"pointsUpdated\", handlePointsUpdated);\n        };\n    }, []);\n\n    if (isLoading) {\n        return (\n            <div className={`flex items-center gap-2 ${className}`}>\n                <Coins className=\"w-4 h-4 text-amber-500\" />\n                <span className=\"text-sm font-semibold text-gray-600 dark:text-gray-400\">...</span>\n            </div>\n        );\n    }\n\n    return (\n        <div className={`flex items-center gap-2 ${className}`}>\n            <Coins className=\"w-4 h-4 text-amber-500\" />\n            <span className=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">{points?.toLocaleString() || 0}</span>\n            <span className=\"text-xs text-gray-500 dark:text-gray-400\">pts</span>\n        </div>\n    );\n}\n"],"names":[],"mappings":"AACA,+CAA+C;;;;;;AAI/C;AACA;AACA;;;AAJA;;;;AAUe,SAAS,WAAW,EAAE,YAAY,EAAE,EAAmB;;IAClE,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAgB;IACpD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAE3C,IAAA,0KAAS;gCAAC;YACN,eAAe;gBACX,IAAI;oBACA,MAAM,QAAQ,MAAM,IAAA,kKAAY;oBAChC,UAAU;gBACd,EAAE,OAAO,OAAO;oBACZ,QAAQ,KAAK,CAAC,gCAAgC;oBAC9C,UAAU;gBACd,SAAU;oBACN,aAAa;gBACjB;YACJ;YAEA;QACJ;+BAAG,EAAE;IAEL,oEAAoE;IACpE,IAAA,0KAAS;gCAAC;YACN,MAAM;oDAAc;oBAChB,IAAI;wBACA,MAAM,QAAQ,MAAM,IAAA,kKAAY;wBAChC,UAAU;oBACd,EAAE,OAAO,OAAO;wBACZ,QAAQ,KAAK,CAAC,kCAAkC;oBACpD;gBACJ;;YAEA,MAAM;4DAAsB;oBACxB,IAAI;wBACA,MAAM,QAAQ,MAAM,IAAA,kKAAY;wBAChC,UAAU;oBACd,EAAE,OAAO,OAAO;wBACZ,QAAQ,KAAK,CAAC,kCAAkC;oBACpD;gBACJ;;YAEA,OAAO,gBAAgB,CAAC,SAAS;YACjC,OAAO,gBAAgB,CAAC,iBAAiB;YAEzC;wCAAO;oBACH,OAAO,mBAAmB,CAAC,SAAS;oBACpC,OAAO,mBAAmB,CAAC,iBAAiB;gBAChD;;QACJ;+BAAG,EAAE;IAEL,IAAI,WAAW;QACX,qBACI,6LAAC;YAAI,WAAW,CAAC,wBAAwB,EAAE,WAAW;;8BAClD,6LAAC,gNAAK;oBAAC,WAAU;;;;;;8BACjB,6LAAC;oBAAK,WAAU;8BAAyD;;;;;;;;;;;;IAGrF;IAEA,qBACI,6LAAC;QAAI,WAAW,CAAC,wBAAwB,EAAE,WAAW;;0BAClD,6LAAC,gNAAK;gBAAC,WAAU;;;;;;0BACjB,6LAAC;gBAAK,WAAU;0BAA0D,QAAQ,oBAAoB;;;;;;0BACtG,6LAAC;gBAAK,WAAU;0BAA2C;;;;;;;;;;;;AAGvE;GAjEwB;KAAA"}},
    {"offset": {"line": 4604, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/WorkspaceHeader.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useEffect, useTransition } from \"react\";\nimport { getRandomProblem } from \"@/actions/problems\";\nimport { ProblemType, ProblemDomain } from \"@prisma/client\";\nimport {\n  ChevronLeft,\n  ChevronRight,\n  Search,\n  CheckCircle,\n  Clock,\n  Send,\n  Moon,\n  Sun,\n  ShieldAlert,\n  Shuffle,\n  Play,\n  Menu\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport UserPoints from \"@/components/UserPoints\";\nimport { useTheme } from \"next-themes\";\n\n// Theme toggle button component\nfunction ThemeToggleButton() {\n  const { theme, setTheme, resolvedTheme } = useTheme();\n  const [mounted, setMounted] = useState(false);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Prevent hydration mismatch\n  if (!mounted) {\n    return (\n      <button className=\"p-2 text-gray-500 opacity-50 cursor-default\">\n         <Moon className=\"w-5 h-5\" />\n      </button>\n    );\n  }\n\n  const isDark = resolvedTheme === 'dark';\n\n  return (\n    <button\n      onClick={() => setTheme(isDark ? 'light' : 'dark')}\n      className=\"p-2 text-gray-500 hover:text-gray-900 dark:hover:text-gray-100 transition-colors\"\n      title={isDark ? \"Switch to light mode\" : \"Switch to dark mode\"}\n    >\n      {isDark ? <Sun className=\"w-5 h-5\" /> : <Moon className=\"w-5 h-5\" />}\n    </button>\n  );\n}\n\ninterface WorkspaceHeaderProps {\n  onSubmit: () => void;\n  onRun: () => void;\n  isSubmitting: boolean;\n  isRunning: boolean;\n  contestId?: string;\n  endTime?: string | Date;\n  nextProblemSlug?: string | null;\n  prevProblemSlug?: string | null;\n  domain?: ProblemDomain;\n  type?: ProblemType;\n  onToggleSidebar?: () => void;\n}\n\nexport default function WorkspaceHeader({\n  onSubmit,\n  onRun,\n  isSubmitting,\n  isRunning,\n  contestId,\n  endTime,\n  nextProblemSlug,\n  prevProblemSlug,\n  domain,\n  type,\n  onToggleSidebar\n}: WorkspaceHeaderProps) {\n  const { data: session, isPending } = authClient.useSession();\n  const router = useRouter();\n  const [isProfileOpen, setProfileOpen] = useState(false);\n  const [isRandomizing, startRandomizing] = useTransition();\n  const profileRef = useRef<HTMLDivElement>(null);\n  const [timeLeft, setTimeLeft] = useState<string>(\"\");\n  const notifiedMins = useRef<Set<number>>(new Set());\n\n  // CLOSE DROPDOWN WHEN CLICKING OUTSIDE\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        profileRef.current &&\n        !profileRef.current.contains(event.target as Node)\n      ) {\n        setProfileOpen(false);\n      }\n    }\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, []);\n\n  // CONTEST TIMER & NOTIFICATIONS\n  useEffect(() => {\n    if (!contestId || !endTime) return;\n\n    const targetDate = new Date(endTime);\n\n    const updateTimer = () => {\n      const now = new Date();\n      const diff = targetDate.getTime() - now.getTime();\n\n      if (diff <= 0) {\n        setTimeLeft(\"00:00:00\");\n        return;\n      }\n\n      const hours = Math.floor(diff / (1000 * 60 * 60));\n      const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n      const secs = Math.floor((diff % (1000 * 60)) / 1000);\n\n      setTimeLeft(\n        `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`\n      );\n\n      // Sonner notifications for 30m, 10m, 5m, 1m\n      const totalMinutes = Math.floor(diff / (1000 * 60));\n      if ([30, 10, 5, 1].includes(totalMinutes) && !notifiedMins.current.has(totalMinutes)) {\n        toast.warning(`${totalMinutes} minute${totalMinutes > 1 ? 's' : ''} remaining!`, {\n          description: \"Make sure to submit your work before the time expires.\",\n          duration: 10000,\n        });\n        notifiedMins.current.add(totalMinutes);\n      }\n    };\n\n    updateTimer();\n    const interval = setInterval(updateTimer, 1000);\n    return () => clearInterval(interval);\n  }, [contestId, endTime]);\n\n  const handleSignOut = async () => {\n    await authClient.signOut({\n      fetchOptions: {\n        onSuccess: () => {\n          toast.success(\"Logged out successfully\");\n          router.push(\"/\");\n        },\n      },\n    });\n  };\n\n  return (\n    <div className=\"h-16 bg-white dark:bg-[#0a0a0a] border-b border-dashed border-gray-200 dark:border-[#262626] flex items-center justify-between px-4 z-10 relative\">\n      {/* LEFT: NAVIGATION */}\n      <div className={`flex items-center gap-4 ${contestId ? 'w-1/3' : ''}`}>\n        <Link href={contestId ? `/contest/${contestId}` : \"/\"} className=\"flex items-center gap-2 group mr-4\">\n          <span className=\"w-8 h-8 bg-linear-to-br from-orange-500 to-red-500 rounded-lg flex items-center justify-center text-white shadow-md shadow-orange-500/20 text-sm font-bold\">\n            A\n          </span>\n          {contestId && (\n            <div className=\"flex flex-col\">\n              <span className=\"text-[10px] font-black uppercase tracking-widest text-orange-600 leading-none\">Contest</span>\n              <span className=\"text-xs font-bold text-gray-900 dark:text-gray-100 leading-tight\">Arena Active</span>\n            </div>\n          )}\n        </Link>\n\n        {!contestId && (\n          <div className=\"hidden md:flex items-center gap-2\">\n            {onToggleSidebar && (\n              <button\n                id=\"problem-list-toggle\"\n                onClick={onToggleSidebar}\n                className=\"p-1.5 hover:bg-gray-100 dark:hover:bg-[#1a1a1a] rounded-lg text-gray-500 transition-colors mr-1\"\n                title=\"Toggle Problem List\"\n              >\n                <Menu className=\"w-5 h-5\" />\n              </button>\n            )}\n            <Link\n              href={domain === \"SQL\" ? \"/problems/sql\" : \"/problems/dsa\"}\n              className=\"text-sm font-medium text-gray-600 dark:text-gray-400 hover:text-black dark:hover:text-white transition-colors flex items-center gap-1\"\n            >\n              <span className=\"sr-only\">List</span>\n              Problem List\n            </Link>\n            <span className=\"text-gray-300 dark:text-gray-600\">|</span>\n            {/* PREVIOUS - NEWER PROBLEM */}\n            <button\n              className={`p-1 rounded-lg transition-colors ${prevProblemSlug ? 'hover:bg-gray-100 dark:hover:bg-[#1a1a1a] text-gray-500' : 'text-gray-300 dark:text-gray-600 cursor-not-allowed'}`}\n              disabled={!prevProblemSlug}\n              onClick={() => prevProblemSlug && router.push(`/problems/${prevProblemSlug}`)}\n              title=\"Previous Problem\"\n            >\n              <ChevronLeft className=\"w-4 h-4\" />\n            </button>\n            {/* NEXT - OLDER PROBLEM */}\n            <button\n              className={`p-1 rounded-lg transition-colors ${nextProblemSlug ? 'hover:bg-gray-100 dark:hover:bg-[#1a1a1a] text-gray-500' : 'text-gray-300 dark:text-gray-600 cursor-not-allowed'}`}\n              disabled={!nextProblemSlug}\n              onClick={() => nextProblemSlug && router.push(`/problems/${nextProblemSlug}`)}\n              title=\"Next Problem\"\n            >\n              <ChevronRight className=\"w-4 h-4\" />\n            </button>\n            <span className=\"text-gray-300 dark:text-gray-600\">|</span>\n            <button\n              onClick={() => {\n                if (domain && type) {\n                  startRandomizing(async () => {\n                    const slug = await getRandomProblem(domain, type);\n                    if (slug) router.push(`/problems/${slug}`);\n                    else toast.error(\"No other problems found\");\n                  });\n                }\n              }}\n              disabled={isRandomizing}\n              className={`p-1 hover:bg-gray-100 dark:hover:bg-[#1a1a1a] rounded-lg text-gray-500 transition-colors ${isRandomizing ? 'opacity-50' : ''}`}\n              title=\"Random Problem\"\n            >\n              <Shuffle className={`w-4 h-4 ${isRandomizing ? 'animate-spin' : ''}`} />\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* CENTER / RIGHT: ACTIONS */}\n      <div className={`flex items-center gap-2 ${contestId ? 'flex-1 justify-center' : ''}`}>\n        <button\n          id=\"run-button\"\n          className={`flex items-center gap-2 px-6 py-2 bg-gray-100 dark:bg-[#1a1a1a] hover:bg-gray-200 dark:hover:bg-[#262626] text-gray-700 dark:text-gray-300 text-sm font-bold rounded-lg transition-all disabled:opacity-50 ${contestId ? 'border border-gray-200 dark:border-[#262626] shadow-sm' : ''}`}\n          onClick={onRun}\n          disabled={isRunning || isSubmitting}\n        >\n          {isRunning ? (\n            <div className=\"w-3 h-3 border-2 border-gray-500/30 border-t-gray-600 rounded-full animate-spin\" />\n          ) : (\n            <Play className=\"w-4 h-4 fill-current\" />\n          )}\n          {isRunning ? 'Running...' : 'Run'}\n        </button>\n\n        <button\n          id=\"submit-button\"\n          onClick={onSubmit}\n          disabled={isSubmitting}\n          className={`flex items-center gap-2 px-8 py-2 bg-orange-600 hover:bg-orange-700 text-white text-sm font-black uppercase tracking-wider rounded-lg shadow-lg shadow-orange-500/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed transform active:scale-95`}\n        >\n          {isSubmitting ? (\n            <div className=\"w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin\" />\n          ) : (\n            <Send className=\"w-4 h-4\" />\n          )}\n          {isSubmitting ? 'Submitting...' : 'Submit Now'}\n        </button>\n\n        {contestId && timeLeft && (\n          <div className=\"flex flex-col items-center justify-center px-4 py-1.5 bg-orange-50 dark:bg-orange-500/10 rounded-lg border border-orange-200 dark:border-orange-500/30 ml-6\">\n            <span className=\"text-[10px] font-black text-orange-600 uppercase tracking-widest leading-none mb-0.5\">Time Left</span>\n            <span className=\"text-sm font-mono font-bold text-gray-900 dark:text-gray-100 leading-none\">{timeLeft}</span>\n          </div>\n        )}\n      </div>\n\n      {/* RIGHT: USER / SETTINGS */}\n      <div className={`flex items-center gap-4 ${contestId ? 'w-1/3 justify-end' : ''}`}>\n        {!contestId && (\n          <>\n            <ThemeToggleButton />\n\n            {session ? (\n              <div className=\"flex items-center gap-4\">\n                <div className=\"relative\" ref={profileRef}>\n                  <button\n                    onClick={() => setProfileOpen(!isProfileOpen)}\n                    className=\"flex items-center gap-2 pl-2 pr-1 py-1 rounded-full hover:bg-gray-100 dark:hover:bg-[#1a1a1a] transition-all border border-transparent hover:border-gray-200 dark:hover:border-[#262626]\"\n                  >\n                    <span className=\"text-sm font-semibold text-gray-700 dark:text-gray-300 hidden md:block\">\n                      {session.user.name}\n                    </span>\n                    <div className=\"w-8 h-8 rounded-full overflow-hidden ring-2 ring-white dark:ring-[#0a0a0a] bg-orange-50 dark:bg-orange-500/20 text-orange-600 flex items-center justify-center font-bold text-xs ring-offset-1\">\n                      {session.user.image ? (\n                        <img\n                          src={session.user.image}\n                          alt={session.user.name || \"User\"}\n                          className=\"w-full h-full object-cover\"\n                          referrerPolicy=\"no-referrer\"\n                        />\n                      ) : (\n                        session.user.name?.charAt(0).toUpperCase()\n                      )}\n                    </div>\n                  </button>\n\n                  <AnimatePresence>\n                    {isProfileOpen && (\n                      <motion.div\n                        initial={{ opacity: 0, y: 10, scale: 0.95 }}\n                        animate={{ opacity: 1, y: 0, scale: 1 }}\n                        exit={{ opacity: 0, y: 10, scale: 0.95 }}\n                        transition={{ duration: 0.2 }}\n                        className=\"absolute right-0 top-full mt-2 w-48 bg-white dark:bg-[#141414] border border-gray-100 dark:border-[#262626] rounded-xl shadow-lg p-1 z-50 origin-top-right\"\n                      >\n                        {(session.user as any).role === \"ADMIN\" && (\n                          <Link\n                            href=\"/admin\"\n                            className=\"block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] rounded-lg\"\n                            onClick={() => setProfileOpen(false)}\n                          >\n                            Admin Panel\n                          </Link>\n                        )}\n                        <Link\n                          href=\"/dashboard\"\n                          className=\"block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] rounded-lg\"\n                          onClick={() => setProfileOpen(false)}\n                        >\n                          Dashboard\n                        </Link>\n                        <button\n                          onClick={handleSignOut}\n                          className=\"w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-500/10 rounded-lg\"\n                        >\n                          Sign Out\n                        </button>\n                      </motion.div>\n                    )}\n                  </AnimatePresence>\n                </div>\n                <UserPoints className=\"hidden md:flex\" />\n              </div>\n            ) : (\n              <Link\n                href=\"/signin\"\n                className=\"text-sm font-semibold text-gray-700 dark:text-gray-300 hover:text-orange-600\"\n              >\n                Sign In\n              </Link>\n            )}\n          </>\n        )}\n        {contestId && (\n          <div className=\"flex items-center gap-2 bg-orange-50 dark:bg-orange-500/10 px-3 py-1.5 rounded-full border border-orange-100 dark:border-orange-500/30\">\n            <ShieldAlert className=\"w-4 h-4 text-orange-600\" />\n            <span className=\"text-[10px] font-black text-orange-700 dark:text-orange-400 uppercase tracking-tighter\">Proctored Mode</span>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5235, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAwtBsB,sBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 5250, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA28BsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 5265, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestProtection.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState, useRef, useCallback } from \"react\";\n\nimport {\n  AlertTriangle,\n  ShieldX,\n  Monitor,\n  Eye,\n  Lock,\n  Ban,\n  Clock,\n} from \"lucide-react\";\nimport { logContestViolation, getParticipationStatus } from \"@/actions/contest\";\n\ninterface ContestProtectionProps {\n  contestId: string;\n  sessionId: string;\n  onAutoSubmit?: () => void;\n  onBlocked?: () => void;\n  paused?: boolean;\n}\n\ninterface ViolationState {\n  total: number;\n  isFlagged: boolean;\n  isBlocked: boolean;\n  tempBlockedUntil: string | null;\n  permanentlyBlocked: boolean;\n}\n\nconst MAX_WARNINGS = 6;\nconst FLAG_THRESHOLD = 3;\n\n// Blocked keyboard shortcuts\nconst BLOCKED_SHORTCUTS = [\n  { key: \"c\", ctrl: true, shift: false }, // Ctrl+C\n  { key: \"v\", ctrl: true, shift: false }, // Ctrl+V\n  { key: \"x\", ctrl: true, shift: false }, // Ctrl+X\n  { key: \"u\", ctrl: true, shift: false }, // Ctrl+U (view source)\n  { key: \"s\", ctrl: true, shift: false }, // Ctrl+S\n  { key: \"p\", ctrl: true, shift: false }, // Ctrl+P (print)\n  { key: \"i\", ctrl: true, shift: true }, // Ctrl+Shift+I (devtools)\n  { key: \"j\", ctrl: true, shift: true }, // Ctrl+Shift+J (console)\n  { key: \"c\", ctrl: true, shift: true }, // Ctrl+Shift+C (inspect)\n  { key: \"F12\", ctrl: false, shift: false }, // F12\n];\n\nexport default function ContestProtection({\n  contestId,\n  sessionId,\n  onAutoSubmit,\n  onBlocked,\n  paused = false,\n}: ContestProtectionProps) {\n  const [violations, setViolations] = useState<ViolationState>({\n    total: 0,\n    isFlagged: false,\n    isBlocked: false,\n    tempBlockedUntil: null,\n    permanentlyBlocked: false,\n  });\n  const [showWarningPopup, setShowWarningPopup] = useState(false);\n  const [needsFullscreen, setNeedsFullscreen] = useState(false);\n  const [currentViolationType, setCurrentViolationType] = useState<string>(\"\");\n  const [isEditorLocked, setIsEditorLocked] = useState(false);\n  const [tempBlockTimeLeft, setTempBlockTimeLeft] = useState<number>(0);\n  const isMounted = useRef(false);\n  const broadcastChannel = useRef<BroadcastChannel | null>(null);\n  const lastViolationTime = useRef<number>(0);\n  const isProcessingViolation = useRef(false);\n  const isRefreshing = useRef(false);\n  const isNavigating = useRef(false); // Track internal navigation to problem pages\n\n  // Ref to track fullscreen needs for event listeners (avoids stale closures)\n  const needsFullscreenRef = useRef(false);\n\n  useEffect(() => {\n    needsFullscreenRef.current = needsFullscreen;\n  }, [needsFullscreen]);\n\n  // Global debounce - only ONE violation allowed every 2 seconds\n  const canLogViolation = useCallback(() => {\n    const now = Date.now();\n    if (paused) return false;\n\n    // If already processing or locked - DO NOT log more violations\n    if (isProcessingViolation.current) return false;\n    if (isEditorLocked) return false;\n    // NOTE: We allow logging even if showWarningPopup is true (e.g. for tab switching while popup is open)\n    // Violations are logged even during temp block to allow escalation to permanent block\n\n    // 2 second global cooldown to prevent double-logging same event\n    if (now - lastViolationTime.current < 2000) return false;\n\n    return true;\n  }, [isEditorLocked, paused]);\n\n  // Log violation to server and update state\n  const handleViolation = useCallback(\n    async (\n      type:\n        | \"TAB_SWITCH\"\n        | \"FULLSCREEN_EXIT\"\n        | \"COPY_PASTE\"\n        | \"DEVTOOLS_OPEN\"\n        | \"KEYBOARD_SHORTCUT\"\n        | \"NAVIGATION_ATTEMPT\"\n        | \"MULTI_TAB\",\n      message: string\n    ) => {\n      // Skip if navigating internally (prevents false positives when clicking problems)\n      if (!isMounted.current || isRefreshing.current || isNavigating.current)\n        return;\n\n      // Always show popup for user awareness\n      setCurrentViolationType(message);\n      setShowWarningPopup(true);\n\n      // Keyboard shortcuts and copy/paste ONLY show warning, don't count as violations\n      const warningOnlyTypes = [\"KEYBOARD_SHORTCUT\", \"COPY_PASTE\"];\n      if (warningOnlyTypes.includes(type)) {\n        // Just show warning, don't log to server or increment counter\n        return;\n      }\n\n      // But only log to server if cooldown passed\n      if (!canLogViolation()) {\n        return;\n      }\n\n      // Lock and update timestamp immediately\n      isProcessingViolation.current = true;\n      lastViolationTime.current = Date.now();\n\n      try {\n        const result = await logContestViolation(contestId, type, message);\n\n        if (result.success) {\n          const newState = {\n            total: result.totalViolations || 0,\n            isFlagged: result.isFlagged || false,\n            isBlocked: result.isBlocked || false,\n            tempBlockedUntil: result.tempBlockedUntil || null,\n            permanentlyBlocked: result.permanentlyBlocked || false,\n          };\n          setViolations(newState);\n\n          // Handle tiered escalation\n          if (result.permanentlyBlocked) {\n            setIsEditorLocked(true);\n            onBlocked?.();\n          } else if (result.tempBlockedUntil) {\n            setIsEditorLocked(true);\n            // Calculate time left\n            const timeLeft =\n              new Date(result.tempBlockedUntil).getTime() - Date.now();\n            setTempBlockTimeLeft(Math.max(0, Math.floor(timeLeft / 1000)));\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n      } finally {\n        isProcessingViolation.current = false;\n      }\n    },\n    [contestId, canLogViolation, onAutoSubmit, onBlocked]\n  );\n\n  // Check for existing block status on mount (persists across refresh)\n  useEffect(() => {\n    if (!contestId) return;\n\n    const checkBlockStatus = async () => {\n      const result = await getParticipationStatus(contestId);\n      if (result.success && result.participation) {\n        const p = result.participation as any;\n\n        // ALWAYS sync the violation counts and flags\n        const newViolationState = {\n          total: p.totalViolations || 0,\n          isFlagged: p.isFlagged || false,\n          isBlocked: false,\n          tempBlockedUntil: null,\n          permanentlyBlocked: false,\n        };\n\n        if (p.permanentlyBlocked) {\n          newViolationState.isBlocked = true;\n          newViolationState.permanentlyBlocked = true;\n          setIsEditorLocked(true);\n          onBlocked?.();\n        } else if (p.tempBlockedUntil) {\n          const blockEnd = new Date(p.tempBlockedUntil);\n          if (blockEnd > new Date()) {\n            newViolationState.isBlocked = true;\n            newViolationState.tempBlockedUntil = p.tempBlockedUntil;\n            setIsEditorLocked(true);\n            const timeLeft = blockEnd.getTime() - Date.now();\n            setTempBlockTimeLeft(Math.max(0, Math.floor(timeLeft / 1000)));\n          }\n        } else if (p.isBlocked) {\n          newViolationState.isBlocked = true;\n          setIsEditorLocked(true);\n        }\n\n        setViolations(newViolationState);\n      }\n    };\n\n    checkBlockStatus();\n  }, [contestId, onBlocked]);\n\n  // Countdown timer for temp block\n  useEffect(() => {\n    if (tempBlockTimeLeft <= 0) return;\n\n    const interval = setInterval(() => {\n      setTempBlockTimeLeft((prev) => {\n        if (prev <= 1) {\n          // Timer expired - unblock\n          setIsEditorLocked(false);\n          setViolations((v) => ({\n            ...v,\n            isBlocked: false,\n            tempBlockedUntil: null,\n          }));\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [tempBlockTimeLeft > 0]); // Keep boolean dependency but ensure it works on reset\n\n  useEffect(() => {\n    if (!contestId || !sessionId) return;\n\n    // Setup delay to prevent false positives\n    const mountTimeout = setTimeout(() => {\n      isMounted.current = true;\n\n      // After refresh, check if we need to re-enter fullscreen\n      if (!document.fullscreenElement && !isRefreshing.current) {\n        setNeedsFullscreen(true);\n        needsFullscreenRef.current = true; // Immediate sync for event listeners\n      }\n    }, 3000);\n\n    // =============================================\n    // 1. MULTI-TAB DETECTION via BroadcastChannel\n    // =============================================\n    try {\n      broadcastChannel.current = new BroadcastChannel(`contest-${contestId}`);\n\n      // Announce presence\n      broadcastChannel.current.postMessage({ type: \"ping\", sessionId });\n\n      // Listen for other tabs\n      broadcastChannel.current.onmessage = (event) => {\n        if (event.data.type === \"ping\" && event.data.sessionId !== sessionId) {\n          handleViolation(\"MULTI_TAB\", \"Contest opened in multiple tabs\");\n          // Respond so the other tab knows\n          broadcastChannel.current?.postMessage({\n            type: \"conflict\",\n            sessionId,\n          });\n        }\n        if (\n          event.data.type === \"conflict\" &&\n          event.data.sessionId !== sessionId\n        ) {\n          handleViolation(\"MULTI_TAB\", \"Contest opened in multiple tabs\");\n        }\n      };\n    } catch (e) {\n      console.warn(\"BroadcastChannel not supported\");\n    }\n\n    // =============================================\n    // 2. FULLSCREEN ENFORCEMENT\n    // =============================================\n    const enterFullscreen = () => {\n      if (!document.fullscreenElement) {\n        document.documentElement.requestFullscreen().catch(() => {});\n      }\n    };\n\n    const handleFullscreenChange = () => {\n      if (!isMounted.current) return;\n      if (!document.fullscreenElement) {\n        handleViolation(\"FULLSCREEN_EXIT\", \"You exited fullscreen mode\");\n      }\n    };\n    document.addEventListener(\"fullscreenchange\", handleFullscreenChange);\n\n    // =============================================\n    // 3. COPY/PASTE/CUT PREVENTION\n    // =============================================\n    const preventClipboard = (e: ClipboardEvent) => {\n      if (!isMounted.current) return;\n      e.preventDefault();\n      handleViolation(\n        \"COPY_PASTE\",\n        `${e.type.charAt(0).toUpperCase() + e.type.slice(1)} is not allowed`\n      );\n      return false;\n    };\n\n    document.addEventListener(\"copy\", preventClipboard);\n    document.addEventListener(\"cut\", preventClipboard);\n    document.addEventListener(\"paste\", preventClipboard);\n\n    // =============================================\n    // 4. KEYBOARD SHORTCUT BLOCKING\n    // =============================================\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (!isMounted.current) return;\n\n      // Check against blocked shortcuts\n      const isBlocked = BLOCKED_SHORTCUTS.some((shortcut) => {\n        const keyMatch = e.key.toLowerCase() === shortcut.key.toLowerCase();\n        const ctrlMatch =\n          e.ctrlKey === shortcut.ctrl || e.metaKey === shortcut.ctrl;\n        const shiftMatch = e.shiftKey === shortcut.shift;\n        return keyMatch && ctrlMatch && shiftMatch;\n      });\n\n      if (isBlocked) {\n        e.preventDefault();\n        e.stopPropagation();\n        handleViolation(\n          \"KEYBOARD_SHORTCUT\",\n          `Blocked shortcut: ${e.ctrlKey ? \"Ctrl+\" : \"\"}${\n            e.shiftKey ? \"Shift+\" : \"\"\n          }${e.key}`\n        );\n        return false;\n      }\n\n      // Detect Refresh to suppress false positives\n      const isRefresh =\n        e.key === \"F5\" ||\n        (e.key.toLowerCase() === \"r\" && (e.ctrlKey || e.metaKey));\n\n      if (isRefresh) {\n        isRefreshing.current = true;\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown, true);\n\n    // =============================================\n    // 5. TAB SWITCH / FOCUS DETECTION\n    // =============================================\n    const handleVisibilityChange = () => {\n      if (!isMounted.current) return;\n      if (document.hidden) {\n        handleViolation(\"TAB_SWITCH\", \"You switched away from the contest tab\");\n      }\n    };\n\n    const handleWindowBlur = () => {\n      if (!isMounted.current) return;\n      handleViolation(\"TAB_SWITCH\", \"Window lost focus\");\n    };\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    window.addEventListener(\"blur\", handleWindowBlur);\n\n    // =============================================\n    // 5b. INTERACTION-BASED COMPLIANCE (Optimized)\n    // =============================================\n    // =============================================\n    // 5b. INTERACTION-BASED COMPLIANCE (Optimization: Throttled)\n    // =============================================\n    let lastCheck = 0;\n    const checkCompliance = () => {\n      const now = Date.now();\n      // Throttle: Max once per 2 seconds during active interaction\n      if (now - lastCheck < 2000) return;\n      lastCheck = now;\n\n      if (!isMounted.current) return;\n      // Skip if already processing/blocked OR if waiting for fullscreen (using Ref for live value) OR PAUSED\n      if (\n        paused ||\n        isProcessingViolation.current ||\n        isEditorLocked ||\n        showWarningPopup ||\n        needsFullscreenRef.current\n      )\n        return;\n\n      // 1. Check Fullscreen\n      if (!document.fullscreenElement && !isRefreshing.current) {\n        handleViolation(\"FULLSCREEN_EXIT\", \"You must stay in fullscreen mode\");\n        return;\n      }\n    };\n\n    // Event-driven checks are sufficient without polling overhead\n    document.addEventListener(\"mousedown\", checkCompliance);\n    document.addEventListener(\"keydown\", checkCompliance);\n    document.addEventListener(\"touchstart\", checkCompliance);\n\n    // No polling heartbeat needed - visibilitychange and fullscreenchange handle the critical events instantly\n\n    // =============================================\n    // 6. DEVTOOLS DETECTION (Event-Driven)\n    // =============================================\n    let resizeTimeout: NodeJS.Timeout;\n    const checkDevTools = () => {\n      if (!isMounted.current) return;\n      const threshold = 160;\n      const widthDiff = window.outerWidth - window.innerWidth;\n      const heightDiff = window.outerHeight - window.innerHeight;\n\n      if (widthDiff > threshold || heightDiff > threshold) {\n        handleViolation(\"DEVTOOLS_OPEN\", \"Developer tools detected\");\n      }\n    };\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(checkDevTools, 500); // Debounce resize check\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // =============================================\n    // 7. CONTEXT MENU DISABLE\n    // =============================================\n    const preventContextMenu = (e: MouseEvent) => {\n      e.preventDefault();\n      return false;\n    };\n    document.addEventListener(\"contextmenu\", preventContextMenu);\n\n    // =============================================\n    // 8. INTERNAL NAVIGATION TRACKING\n    // =============================================\n    // Track clicks on links to prevent false positives when navigating to problems\n    const handleLinkClick = (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      const link = target.closest(\"a\");\n      if (link) {\n        const href = link.getAttribute(\"href\");\n        // If it's an internal link (same origin or relative path)\n        if (\n          href &&\n          (href.startsWith(\"/\") || href.startsWith(window.location.origin))\n        ) {\n          isNavigating.current = true;\n          // Reset after a short delay in case navigation is cancelled\n          setTimeout(() => {\n            isNavigating.current = false;\n          }, 2000);\n        }\n      }\n    };\n    document.addEventListener(\"click\", handleLinkClick, true);\n\n    // =============================================\n    // 8. BEFOREUNLOAD WARNING\n    // =============================================\n    const handleBeforeUnload = (e: BeforeUnloadEvent) => {\n      isRefreshing.current = true; // Mark as refreshing/navigating\n      // DISABLE LEAVE CONFIRMATION\n      // e.preventDefault();\n      // e.returnValue = \"You are in contest mode. Are you sure you want to leave?\";\n      // return e.returnValue;\n    };\n    window.addEventListener(\"beforeunload\", handleBeforeUnload);\n\n    // =============================================\n    // 9. DRAG/DROP PREVENTION\n    // =============================================\n    const preventDragDrop = (e: DragEvent) => {\n      e.preventDefault();\n      return false;\n    };\n    document.addEventListener(\"dragover\", preventDragDrop);\n    document.addEventListener(\"drop\", preventDragDrop);\n\n    // Cleanup\n    return () => {\n      clearTimeout(mountTimeout);\n      clearTimeout(resizeTimeout);\n      broadcastChannel.current?.close();\n      document.removeEventListener(\"fullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"copy\", preventClipboard);\n      document.removeEventListener(\"cut\", preventClipboard);\n      document.removeEventListener(\"paste\", preventClipboard);\n      document.removeEventListener(\"keydown\", handleKeyDown, true);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"blur\", handleWindowBlur);\n      window.removeEventListener(\"resize\", handleResize);\n\n      document.removeEventListener(\"mousedown\", checkCompliance);\n      document.removeEventListener(\"keydown\", checkCompliance);\n      document.removeEventListener(\"touchstart\", checkCompliance);\n\n      document.removeEventListener(\"contextmenu\", preventContextMenu);\n      document.removeEventListener(\"click\", handleLinkClick, true);\n      window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n      document.removeEventListener(\"dragover\", preventDragDrop);\n      document.removeEventListener(\"drop\", preventDragDrop);\n    };\n  }, [contestId, sessionId, handleViolation]);\n\n  const handleDismissWarning = () => {\n    // Only allow dismissing if we successfully enter fullscreen\n    const enterFullscreen = async () => {\n      try {\n        if (!document.fullscreenElement) {\n          await document.documentElement.requestFullscreen();\n        }\n        // Only if successful, close popup\n        setShowWarningPopup(false);\n      } catch (err) {\n        // If user denies fullscreen or it fails, keep popup open\n        // Maybe show a toast or shake animation in future\n      }\n    };\n    enterFullscreen();\n  };\n\n  const handleReEnterFullscreen = () => {\n    document.documentElement\n      .requestFullscreen()\n      .then(() => setNeedsFullscreen(false))\n      .catch(() => {\n        // If fails, keeps the popup open\n      });\n  };\n\n  const remainingWarnings = MAX_WARNINGS - violations.total;\n\n  return (\n    <>\n      {/* Unified Warning/Block Card - Redesigned */}\n      {(isEditorLocked || showWarningPopup) && (\n        <div className=\"fixed inset-0 z-9999 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-in fade-in duration-200\">\n          <div className=\"bg-white dark:bg-[#141414] rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden border border-orange-100 dark:border-orange-500/20 transform transition-all scale-100\">\n            {/* Status Bar Top */}\n            <div\n              className={`h-2 w-full ${\n                violations.permanentlyBlocked ? \"bg-red-500\" : \"bg-orange-500\"\n              }`}\n            />\n\n            <div className=\"p-6 md:p-8\">\n              <div className=\"flex flex-col md:flex-row gap-6 items-start md:items-center\">\n                {/* Large Icon Box */}\n                <div\n                  className={`w-16 h-16 rounded-2xl flex items-center justify-center shrink-0 shadow-sm ${\n                    violations.permanentlyBlocked\n                      ? \"bg-red-50 dark:bg-red-500/10 text-red-500\"\n                      : \"bg-orange-50 dark:bg-orange-500/10 text-orange-500\"\n                  }`}\n                >\n                  {violations.permanentlyBlocked ? (\n                    <Ban className=\"w-8 h-8\" />\n                  ) : tempBlockTimeLeft > 0 ? (\n                    <Clock className=\"w-8 h-8 animate-pulse\" />\n                  ) : isEditorLocked ? (\n                    <Lock className=\"w-8 h-8\" />\n                  ) : (\n                    <AlertTriangle className=\"w-8 h-8\" />\n                  )}\n                </div>\n\n                <div className=\"flex-1 space-y-1\">\n                  <h2 className=\"text-xl font-bold text-gray-900 dark:text-white leading-tight\">\n                    {violations.permanentlyBlocked\n                      ? \"Contest Session Terminated\"\n                      : tempBlockTimeLeft > 0\n                      ? \"Temporary Suspension\"\n                      : \"Violation Detected\"}\n                  </h2>\n                  <p className=\"text-gray-500 dark:text-gray-400 font-medium text-sm\">\n                    {violations.permanentlyBlocked\n                      ? \"Multiple violations detected. Your session has been permanently blocked.\"\n                      : tempBlockTimeLeft > 0\n                      ? \"Please wait for the timer to expire before continuing.\"\n                      : currentViolationType ||\n                        \"This action is prohibited during the contest.\"}\n                  </p>\n                </div>\n              </div>\n\n              {/* Timer Section */}\n              {tempBlockTimeLeft > 0 && (\n                <div className=\"mt-8 p-6 bg-orange-50 dark:bg-orange-500/10 rounded-xl border border-orange-100 dark:border-orange-500/20 flex flex-col items-center justify-center\">\n                  <span className=\"text-xs font-bold text-orange-400 uppercase tracking-widest mb-2\">\n                    Access Resumes In\n                  </span>\n                  <div className=\"text-5xl font-black text-orange-500 font-mono tracking-tighter tabular-nums\">\n                    {Math.floor(tempBlockTimeLeft / 60)}:\n                    {String(tempBlockTimeLeft % 60).padStart(2, \"0\")}\n                  </div>\n                </div>\n              )}\n\n              {/* Progress Bar (Only if not perma-blocked and no timer active) */}\n              {!violations.permanentlyBlocked && tempBlockTimeLeft <= 0 && (\n                <div className=\"mt-8 space-y-3\">\n                  <div className=\"flex justify-between items-end\">\n                    <span className=\"text-xs font-semibold text-gray-400 uppercase tracking-wider\">\n                      Warning Level\n                    </span>\n                    <span className=\"text-sm font-bold text-gray-900 dark:text-white\">\n                      {violations.total}{\" \"}\n                      <span className=\"text-gray-400 font-normal\">\n                        / {MAX_WARNINGS}\n                      </span>\n                    </span>\n                  </div>\n                  <div className=\"h-3 bg-gray-100 dark:bg-[#1a1a1a] rounded-full overflow-hidden\">\n                    <div\n                      className={`h-full transition-all duration-500 ease-out ${\n                        violations.total >= 4 ? \"bg-red-500\" : \"bg-orange-500\"\n                      }`}\n                      style={{\n                        width: `${Math.min(\n                          (violations.total / MAX_WARNINGS) * 100,\n                          100\n                        )}%`,\n                      }}\n                    />\n                  </div>\n                  <div className=\"flex items-center justify-between text-xs\">\n                    <span className=\"text-gray-400\">Low Risk</span>\n                    {violations.total >= 4 ? (\n                      <span className=\"text-red-500 font-medium\">\n                        Critical Risk\n                      </span>\n                    ) : (\n                      <span className=\"text-orange-500 font-medium\">\n                        Caution\n                      </span>\n                    )}\n                  </div>\n                </div>\n              )}\n\n              {/* Actions */}\n              <div className=\"mt-8\">\n                {!violations.permanentlyBlocked && tempBlockTimeLeft <= 0 ? (\n                  <button\n                    onClick={handleDismissWarning}\n                    className=\"w-full py-4 bg-gray-900 dark:bg-white text-white dark:text-black rounded-xl font-bold hover:bg-gray-800 dark:hover:bg-gray-200 transition-all transform active:scale-[0.98] shadow-lg shadow-gray-200 dark:shadow-none\"\n                  >\n                    Acknowledge & Continue\n                  </button>\n                ) : tempBlockTimeLeft > 0 ? (\n                  <button\n                    disabled\n                    className=\"w-full py-4 bg-gray-100 dark:bg-[#1a1a1a] text-gray-400 dark:text-gray-600 rounded-xl font-bold cursor-not-allowed\"\n                  >\n                    Suspended\n                  </button>\n                ) : (\n                  <button className=\"w-full py-4 bg-red-50 dark:bg-red-500/10 text-red-600 dark:text-red-500 rounded-xl font-bold border border-red-100 dark:border-red-500/20 cursor-not-allowed\">\n                    Contact Administrator\n                  </button>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Fullscreen Required Prompt (Post-Refresh) */}\n      {needsFullscreen && !isEditorLocked && !showWarningPopup && (\n        <div className=\"fixed inset-0 z-10000 flex items-center justify-center bg-black/60 backdrop-blur-md\">\n          <div className=\"bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden border-2 border-orange-500 animate-in fade-in zoom-in duration-300\">\n            <div className=\"bg-orange-600 px-6 py-4 flex items-center gap-3\">\n              <Monitor className=\"w-6 h-6 text-white\" />\n              <h2 className=\"text-lg font-bold text-white uppercase tracking-wider\">\n                Fullscreen Required\n              </h2>\n            </div>\n\n            <div className=\"p-6 text-center\">\n              <div className=\"w-20 h-20 bg-orange-50 dark:bg-orange-500/10 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <ShieldX className=\"w-10 h-10 text-orange-500\" />\n              </div>\n              <h3 className=\"text-xl font-bold text-gray-900 mb-2\">\n                Re-activate Proctoring\n              </h3>\n              <p className=\"text-gray-600 mb-8 text-sm\">\n                To continue your contest session, you must re-enter fullscreen\n                mode. This is required for proctoring accuracy.\n              </p>\n\n              <button\n                onClick={handleReEnterFullscreen}\n                className=\"w-full py-4 bg-orange-600 text-white rounded-xl font-black uppercase tracking-widest hover:bg-orange-700 transition-all shadow-lg shadow-orange-200 flex items-center justify-center gap-3 group\"\n              >\n                <Monitor className=\"w-5 h-5 group-hover:scale-110 transition-transform\" />\n                Go Full Screen\n              </button>\n\n              <p className=\"text-[10px] text-gray-400 mt-4 font-medium uppercase tracking-tighter\">\n                Do not attempt to stay in windowed mode\n              </p>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Proctoring Indicator - Clean white style */}\n      <div className=\"fixed top-4 right-4 z-100 flex items-center gap-2 px-3 py-2 bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-lg shadow-sm\">\n        <div className=\"w-2 h-2 bg-green-500 rounded-full animate-pulse\" />\n        <span className=\"text-sm text-gray-700 dark:text-gray-300 font-medium\">\n          Proctored\n        </span>\n        {violations.total > 0 && (\n          <span className=\"px-2 py-0.5 bg-orange-100 dark:bg-orange-500/10 text-orange-700 dark:text-orange-400 rounded text-xs font-semibold\">\n            {violations.total}\n          </span>\n        )}\n      </div>\n    </>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6216, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestNavigationGuard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport { useRouter, usePathname } from \"next/navigation\";\nimport { logContestViolation } from \"@/actions/contest\";\n\ninterface ContestNavigationGuardProps {\n    contestId: string;\n    allowedPaths: string[];  // Paths that are allowed during contest\n}\n\n/**\n * Navigation Guard for Contest Mode\n * - Blocks browser back/forward\n * - Intercepts route changes\n * - Logs navigation attempts\n */\nexport default function ContestNavigationGuard({\n    contestId,\n    allowedPaths\n}: ContestNavigationGuardProps) {\n    const router = useRouter();\n    const pathname = usePathname();\n    const initialPath = useRef(pathname);\n\n    useEffect(() => {\n        if (!contestId) return;\n\n        // =============================================\n        // 1. BLOCK BROWSER BACK/FORWARD\n        // =============================================\n        // Push current state to prevent back navigation\n        const pushState = () => {\n            window.history.pushState(null, \"\", window.location.href);\n        };\n\n        pushState();\n\n        const handlePopState = (e: PopStateEvent) => {\n            e.preventDefault();\n            pushState();\n\n            // Log navigation attempt\n            logContestViolation(\n                contestId,\n                \"NAVIGATION_ATTEMPT\",\n                \"Attempted to use browser back/forward\"\n            );\n        };\n\n        window.addEventListener(\"popstate\", handlePopState);\n\n        // =============================================\n        // 2. INTERCEPT LINK CLICKS\n        // =============================================\n        const handleLinkClick = (e: MouseEvent) => {\n            const target = e.target as HTMLElement;\n            const anchor = target.closest(\"a\");\n\n            if (anchor) {\n                const href = anchor.getAttribute(\"href\");\n\n                // Check if navigation is to an allowed path\n                // Ignore hash links, empty links, or javascript:void, or disabled links\n                if (href &&\n                    href !== \"#\" &&\n                    href.trim() !== \"\" &&\n                    !href.startsWith(\"javascript:\") &&\n                    !allowedPaths.some(path => href.startsWith(path))) {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    logContestViolation(\n                        contestId,\n                        \"NAVIGATION_ATTEMPT\",\n                        `Attempted to navigate to: ${href}`\n                    );\n\n                    return false;\n                }\n            }\n        };\n\n        document.addEventListener(\"click\", handleLinkClick, true);\n\n        // =============================================\n        // 3. MONITOR PATH CHANGES\n        // =============================================\n        // If path changes unexpectedly, redirect back\n        if (pathname !== initialPath.current) {\n            const isAllowed = allowedPaths.some(path => pathname?.startsWith(path));\n\n            if (!isAllowed) {\n                logContestViolation(\n                    contestId,\n                    \"NAVIGATION_ATTEMPT\",\n                    `Unexpected navigation to: ${pathname}`\n                );\n\n                // Redirect back to contest\n                router.replace(initialPath.current || \"/\");\n            }\n        }\n\n        return () => {\n            window.removeEventListener(\"popstate\", handlePopState);\n            document.removeEventListener(\"click\", handleLinkClick, true);\n        };\n    }, [contestId, pathname, allowedPaths, router]);\n\n    // This component doesn't render anything\n    return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;;AAJA;;;;AAiBe,SAAS,uBAAuB,EAC3C,SAAS,EACT,YAAY,EACc;;IAC1B,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,WAAW,IAAA,oJAAW;IAC5B,MAAM,cAAc,IAAA,uKAAM,EAAC;IAE3B,IAAA,0KAAS;4CAAC;YACN,IAAI,CAAC,WAAW;YAEhB,gDAAgD;YAChD,gCAAgC;YAChC,gDAAgD;YAChD,gDAAgD;YAChD,MAAM;8DAAY;oBACd,OAAO,OAAO,CAAC,SAAS,CAAC,MAAM,IAAI,OAAO,QAAQ,CAAC,IAAI;gBAC3D;;YAEA;YAEA,MAAM;mEAAiB,CAAC;oBACpB,EAAE,cAAc;oBAChB;oBAEA,yBAAyB;oBACzB,IAAA,yKAAmB,EACf,WACA,sBACA;gBAER;;YAEA,OAAO,gBAAgB,CAAC,YAAY;YAEpC,gDAAgD;YAChD,2BAA2B;YAC3B,gDAAgD;YAChD,MAAM;oEAAkB,CAAC;oBACrB,MAAM,SAAS,EAAE,MAAM;oBACvB,MAAM,SAAS,OAAO,OAAO,CAAC;oBAE9B,IAAI,QAAQ;wBACR,MAAM,OAAO,OAAO,YAAY,CAAC;wBAEjC,4CAA4C;wBAC5C,wEAAwE;wBACxE,IAAI,QACA,SAAS,OACT,KAAK,IAAI,OAAO,MAChB,CAAC,KAAK,UAAU,CAAC,kBACjB,CAAC,aAAa,IAAI;gFAAC,CAAA,OAAQ,KAAK,UAAU,CAAC;gFAAQ;4BACnD,EAAE,cAAc;4BAChB,EAAE,eAAe;4BAEjB,IAAA,yKAAmB,EACf,WACA,sBACA,CAAC,0BAA0B,EAAE,MAAM;4BAGvC,OAAO;wBACX;oBACJ;gBACJ;;YAEA,SAAS,gBAAgB,CAAC,SAAS,iBAAiB;YAEpD,gDAAgD;YAChD,0BAA0B;YAC1B,gDAAgD;YAChD,8CAA8C;YAC9C,IAAI,aAAa,YAAY,OAAO,EAAE;gBAClC,MAAM,YAAY,aAAa,IAAI;kEAAC,CAAA,OAAQ,UAAU,WAAW;;gBAEjE,IAAI,CAAC,WAAW;oBACZ,IAAA,yKAAmB,EACf,WACA,sBACA,CAAC,0BAA0B,EAAE,UAAU;oBAG3C,2BAA2B;oBAC3B,OAAO,OAAO,CAAC,YAAY,OAAO,IAAI;gBAC1C;YACJ;YAEA;oDAAO;oBACH,OAAO,mBAAmB,CAAC,YAAY;oBACvC,SAAS,mBAAmB,CAAC,SAAS,iBAAiB;gBAC3D;;QACJ;2CAAG;QAAC;QAAW;QAAU;QAAc;KAAO;IAE9C,yCAAyC;IACzC,OAAO;AACX;GA/FwB;;QAIL,kJAAS;QACP,oJAAW;;;KALR"}},
    {"offset": {"line": 6324, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA6dsB,sBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 6339, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/ContestSidebar.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport Link from \"next/link\";\nimport { useRouter } from \"next/navigation\";\nimport { CheckCircle2, ChevronLeft, ChevronRight, Circle, LayoutGrid, List, LogOut, ShieldAlert } from \"lucide-react\";\nimport { motion } from \"framer-motion\";\nimport { finishContestAction } from \"@/actions/contest\";\nimport { toast } from \"sonner\";\n\ninterface ContestSidebarProps {\n    contest: any;\n    currentProblemId: string;\n    solvedProblemIds: string[];\n}\n\nexport default function ContestSidebar({ contest, currentProblemId, solvedProblemIds }: ContestSidebarProps) {\n    const router = useRouter();\n    const [isOpen, setIsOpen] = useState(true);\n    const [visitedProblemIds, setVisitedProblemIds] = useState<string[]>([]);\n    const [isMounted, setIsMounted] = useState(false);\n    const [showEndModal, setShowEndModal] = useState(false);\n    const [endConfirmText, setEndConfirmText] = useState(\"\");\n    const [isEnding, setIsEnding] = useState(false);\n\n    useEffect(() => {\n        // Persist sidebar state\n        const stored = localStorage.getItem(\"contest-sidebar-open\");\n        if (stored !== null) {\n            setIsOpen(stored === \"true\");\n        }\n        setIsMounted(true);\n    }, []);\n\n    const toggleSidebar = (val: boolean) => {\n        setIsOpen(val);\n        localStorage.setItem(\"contest-sidebar-open\", val.toString());\n    };\n\n    useEffect(() => {\n        // Track visited problems in localStorage\n        const visitedKey = `contest-visited-${contest.id}`;\n        const stored = localStorage.getItem(visitedKey);\n        const visited = stored ? JSON.parse(stored) : [];\n\n        if (!visited.includes(currentProblemId)) {\n            visited.push(currentProblemId);\n            localStorage.setItem(visitedKey, JSON.stringify(visited));\n        }\n        setVisitedProblemIds(visited);\n    }, [currentProblemId, contest.id]);\n\n    const getStatusColor = (problemId: string) => {\n        if (solvedProblemIds.includes(problemId)) return \"bg-emerald-500 text-white border-emerald-600 dark:border-emerald-500\";\n        if (visitedProblemIds.includes(problemId)) return \"bg-amber-400 text-white border-amber-500 dark:border-amber-400\";\n        return \"bg-gray-100 dark:bg-[#1a1a1a] text-gray-500 dark:text-gray-400 border-gray-200 dark:border-[#333] hover:border-orange-300 dark:hover:border-orange-500/50 hover:bg-white dark:hover:bg-[#262626]\";\n    };\n\n    const handleEndContest = () => {\n        setShowEndModal(true);\n    };\n\n    const confirmEndContest = async () => {\n        if (endConfirmText.toLowerCase() !== \"end\") {\n            toast.error(\"Please type 'end' to confirm\");\n            return;\n        }\n\n        setIsEnding(true);\n        try {\n            const res = await finishContestAction(contest.id);\n            if (res.success) {\n                // Exit fullscreen if active\n                if (document.fullscreenElement) {\n                    document.exitFullscreen().catch(() => {});\n                }\n                router.push(`/contest/${contest.id}`);\n                toast.success(\"Contest ended successfully\");\n            } else {\n                toast.error(res.error || \"Failed to end contest\");\n                setIsEnding(false);\n            }\n        } catch (err) {\n            toast.error(\"An error occurred while ending the contest\");\n            setIsEnding(false);\n        }\n        setShowEndModal(false);\n    };\n\n    return (\n        <div className=\"relative flex h-full\">\n            {isOpen ? (\n                <motion.div\n                    initial={false}\n                    animate={{ width: 280, opacity: 1 }}\n                    transition={isMounted ? { duration: 0.3 } : { duration: 0 }}\n                    className=\"h-full bg-white dark:bg-[#0a0a0a] border-r border-dashed border-gray-200 dark:border-[#262626] flex flex-col overflow-hidden\"\n                >\n                    <div className=\"p-4 border-b border-dashed border-gray-100 dark:border-[#262626] bg-orange-50/50 dark:bg-orange-500/5 flex items-center justify-between\">\n                        <div className=\"flex items-center gap-2\">\n                            <LayoutGrid className=\"w-4 h-4 text-orange-600 dark:text-orange-500\" />\n                            <span className=\"text-sm font-black uppercase tracking-tighter text-gray-900 dark:text-gray-100\">Navigator</span>\n                        </div>\n                        <button\n                            onClick={() => toggleSidebar(false)}\n                            className=\"p-1 hover:bg-orange-100 dark:hover:bg-orange-500/10 rounded-md text-orange-600 dark:text-orange-500 transition-colors\"\n                        >\n                            <ChevronLeft className=\"w-4 h-4\" />\n                        </button>\n                    </div>\n\n                    <div className=\"flex-1 overflow-y-auto p-4 custom-scrollbar\">\n                        <div className=\"grid grid-cols-4 gap-3\">\n                            {contest.problems.map((cp: any, index: number) => {\n                                const isCurrent = cp.problem.id === currentProblemId;\n                                const isSolved = solvedProblemIds.includes(cp.problem.id);\n\n                                return (\n                                    <Link\n                                        key={cp.problem.id}\n                                        href={isSolved ? \"#\" : `/problems/${cp.problem.slug}?contestId=${contest.id}`}\n                                        onClick={(e) => {\n                                            if (isSolved) {\n                                                e.preventDefault();\n                                                toast.success(\"Problem Solved!\", { description: \"You have already completed this challenge.\" });\n                                            }\n                                        }}\n                                        className={`\n                                            aspect-square flex flex-col items-center justify-center rounded-xl border-2 text-sm font-black transition-all transform active:scale-90 relative\n                                            ${isCurrent ? 'ring-2 ring-orange-500 ring-offset-2 scale-105 z-10' : ''}\n                                            ${getStatusColor(cp.problem.id)}\n                                            ${isSolved ? 'cursor-not-allowed opacity-90' : 'cursor-pointer'}\n                                        `}\n                                    >\n                                        {index + 1}\n                                        {isSolved && <CheckCircle2 className=\"w-2.5 h-2.5 absolute bottom-1 right-1\" />}\n                                    </Link>\n                                );\n                            })}\n                        </div>\n                    </div>\n\n                    <div className=\"p-4 space-y-4 bg-gray-50 dark:bg-[#111] border-t border-dashed border-gray-200 dark:border-[#262626]\">\n                        <div>\n                            <div className=\"text-[10px] font-black text-orange-600 dark:text-orange-500 uppercase mb-1 tracking-widest\">Contest Progress</div>\n                            <div className=\"flex items-center justify-between text-xs font-bold text-gray-900 dark:text-gray-100 mb-2\">\n                                <span>{solvedProblemIds.length} / {contest.problems.length} Solved</span>\n                                <span>{Math.round((solvedProblemIds.length / contest.problems.length) * 100)}%</span>\n                            </div>\n                            <div className=\"w-full h-1.5 bg-gray-200 dark:bg-[#333] rounded-full overflow-hidden\">\n                                <div\n                                    className=\"h-full bg-orange-500 transition-all duration-500\"\n                                    style={{ width: `${(solvedProblemIds.length / contest.problems.length) * 100}%` }}\n                                />\n                            </div>\n                        </div>\n\n                        <button\n                            onClick={handleEndContest}\n                            className=\"w-full py-2.5 px-4 bg-red-50 dark:bg-red-500/10 hover:bg-red-100 dark:hover:bg-red-500/20 text-red-600 dark:text-red-400 rounded-xl border border-red-200 dark:border-red-500/30 flex items-center justify-center gap-2 transition-all group\"\n                        >\n                            <LogOut className=\"w-4 h-4 group-hover:-translate-x-1 transition-transform\" />\n                            <span className=\"text-xs font-black uppercase tracking-tight\">End Contest</span>\n                        </button>\n                    </div>\n                </motion.div>\n            ) : (\n                <motion.div\n                    initial={false}\n                    animate={{ width: 48 }}\n                    transition={isMounted ? { duration: 0.3 } : { duration: 0 }}\n                    className=\"h-full bg-white dark:bg-[#0a0a0a] border-r border-dashed border-gray-200 dark:border-[#262626] flex flex-col items-center py-4 gap-4 overflow-hidden\"\n                >\n                    <button\n                        onClick={() => toggleSidebar(true)}\n                        className=\"p-2 hover:bg-orange-50 dark:hover:bg-orange-500/10 rounded-lg text-orange-600 dark:text-orange-500 transition-colors\"\n                    >\n                        <List className=\"w-5 h-5\" />\n                    </button>\n                    <div className=\"flex-1\" />\n                    <button\n                        onClick={handleEndContest}\n                        className=\"p-2 hover:bg-red-50 dark:hover:bg-red-500/10 rounded-lg text-red-600 dark:text-red-400 transition-colors mb-2\"\n                        title=\"End Contest\"\n                    >\n                        <LogOut className=\"w-5 h-5\" />\n                    </button>\n                </motion.div>\n            )}\n\n            {/* End Contest Confirmation Modal */}\n            {showEndModal && (\n                <div className=\"fixed inset-0 z-[100] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4\">\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl shadow-2xl w-full max-w-md p-6 border border-gray-100 dark:border-[#262626] transform scale-100 transition-all\">\n                        <div className=\"flex items-center gap-3 mb-4 text-red-600 dark:text-red-500\">\n                            <ShieldAlert className=\"w-8 h-8\" />\n                            <h3 className=\"text-xl font-bold text-gray-900 dark:text-gray-100\">End Contest Session?</h3>\n                        </div>\n\n                        <p className=\"text-gray-600 dark:text-gray-300 mb-6\">\n                            Are you sure you want to end your session? You will <strong>NOT</strong> be able to submit more solutions.\n                            <br /><br />\n                            Type <span className=\"font-mono font-bold text-red-600 dark:text-red-400\">end</span> below to confirm.\n                        </p>\n\n                        <input\n                            type=\"text\"\n                            placeholder=\"Type 'end' to confirm\"\n                            value={endConfirmText}\n                            onChange={(e) => setEndConfirmText(e.target.value)}\n                            className=\"w-full px-4 py-3 border rounded-lg mb-6 bg-gray-50 dark:bg-[#0a0a0a] border-gray-200 dark:border-[#333] text-gray-900 dark:text-white focus:bg-white dark:focus:bg-[#0a0a0a] focus:ring-2 focus:ring-red-500/20 focus:border-red-500 outline-none transition-all font-mono text-center uppercase tracking-widest placeholder:normal-case placeholder:tracking-normal\"\n                            autoFocus\n                        />\n\n                        <div className=\"flex gap-3\">\n                            <button\n                                onClick={() => { setShowEndModal(false); setEndConfirmText(\"\"); }}\n                                className=\"flex-1 px-4 py-3 border rounded-lg font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] border-gray-200 dark:border-[#333] transition-colors\"\n                            >\n                                Cancel\n                            </button>\n                            <button\n                                onClick={confirmEndContest}\n                                disabled={endConfirmText.toLowerCase() !== \"end\" || isEnding}\n                                className=\"flex-1 px-4 py-3 bg-red-600 text-white rounded-lg font-bold hover:bg-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-red-500/20\"\n                            >\n                                {isEnding ? \"Ending...\" : \"End Contest\"}\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            )}\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6853, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/tour/ProblemTour.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport ReactJoyride, { CallBackProps, STATUS, Step } from \"react-joyride\";\nimport { useTheme } from \"next-themes\";\n\nexport default function ProblemTour() {\n  const { theme } = useTheme();\n  const [run, setRun] = useState(false);\n\n  useEffect(() => {\n    // Check if tour has been seen\n    const seenTour = localStorage.getItem(\"algofox_problem_tour_seen\");\n    if (!seenTour) {\n      // Small delay to ensure everything is mounted\n      const timer = setTimeout(() => {\n        setRun(true);\n      }, 1500);\n      return () => clearTimeout(timer);\n    }\n  }, []);\n\n  const handleJoyrideCallback = (data: CallBackProps) => {\n    const { status } = data;\n    if (([STATUS.FINISHED, STATUS.SKIPPED] as string[]).includes(status)) {\n      setRun(false);\n      localStorage.setItem(\"algofox_problem_tour_seen\", \"true\");\n    }\n  };\n\n  const steps: Step[] = [\n    {\n      target: \"#problem-list-toggle\",\n      content: \"Click here to toggle the problem list and navigate between problems easily.\",\n      disableBeacon: true,\n    },\n    {\n       target: \"#problem-description\",\n       content: \"Read the problem statement, examples, and constraints here.\",\n    },\n    {\n      target: \"#solutions-tab\",\n      content: \"Stuck? Check out official and community solutions here (unlocks after solving!).\",\n    },\n    {\n      target: \"#language-dropdown\",\n      content: \"Choose your preferred programming language from the dropdown.\",\n    },\n    {\n      target: \"#code-editor\",\n      content: \"Write your solution code here. It supports syntax highlighting and auto-completion.\",\n    },\n    {\n      target: \"#run-button\",\n      content: \"Test your code against sample test cases before submitting.\",\n    },\n    {\n      target: \"#test-cases\",\n      content: \"View the results of your test cases here.\",\n    },\n    {\n      target: \"#submit-button\",\n      content: \"Ready? Submit your solution to see if it passes all hidden test cases!\",\n    },\n  ];\n\n  const styles = {\n    options: {\n        zIndex: 10000,\n        primaryColor: '#ea580c', // orange-600\n        textColor: theme === 'dark' ? '#f3f4f6' : '#1f2937',\n        backgroundColor: theme === 'dark' ? '#1f1f1f' : '#ffffff',\n        arrowColor: theme === 'dark' ? '#1f1f1f' : '#ffffff',\n    },\n    tooltip: {\n        borderRadius: '0.75rem',\n        padding: '1rem',\n    },\n    buttonNext: {\n        backgroundColor: '#ea580c',\n        borderRadius: '0.5rem',\n        color: '#fff',\n        fontWeight: 600,\n        padding: '0.5rem 1rem',\n    },\n    buttonBack: {\n        color: theme === 'dark' ? '#9ca3af' : '#6b7280',\n        marginRight: '0.5rem',\n    },\n    buttonSkip: {\n        color: theme === 'dark' ? '#ef4444' : '#dc2626',\n    }\n  };\n\n  return (\n    <ReactJoyride\n      steps={steps}\n      run={run}\n      continuous\n      showProgress\n      showSkipButton\n      callback={handleJoyrideCallback}\n      styles={styles}\n      floaterProps={{\n        disableAnimation: true,\n      }}\n    />\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAMe,SAAS;;IACtB,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,+JAAQ;IAC1B,MAAM,CAAC,KAAK,OAAO,GAAG,IAAA,yKAAQ,EAAC;IAE/B,IAAA,0KAAS;iCAAC;YACR,8BAA8B;YAC9B,MAAM,WAAW,aAAa,OAAO,CAAC;YACtC,IAAI,CAAC,UAAU;gBACb,8CAA8C;gBAC9C,MAAM,QAAQ;mDAAW;wBACvB,OAAO;oBACT;kDAAG;gBACH;6CAAO,IAAM,aAAa;;YAC5B;QACF;gCAAG,EAAE;IAEL,MAAM,wBAAwB,CAAC;QAC7B,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,IAAI,AAAC;YAAC,+JAAM,CAAC,QAAQ;YAAE,+JAAM,CAAC,OAAO;SAAC,CAAc,QAAQ,CAAC,SAAS;YACpE,OAAO;YACP,aAAa,OAAO,CAAC,6BAA6B;QACpD;IACF;IAEA,MAAM,QAAgB;QACpB;YACE,QAAQ;YACR,SAAS;YACT,eAAe;QACjB;QACA;YACG,QAAQ;YACR,SAAS;QACZ;QACA;YACE,QAAQ;YACR,SAAS;QACX;QACA;YACE,QAAQ;YACR,SAAS;QACX;QACA;YACE,QAAQ;YACR,SAAS;QACX;QACA;YACE,QAAQ;YACR,SAAS;QACX;QACA;YACE,QAAQ;YACR,SAAS;QACX;QACA;YACE,QAAQ;YACR,SAAS;QACX;KACD;IAED,MAAM,SAAS;QACb,SAAS;YACL,QAAQ;YACR,cAAc;YACd,WAAW,UAAU,SAAS,YAAY;YAC1C,iBAAiB,UAAU,SAAS,YAAY;YAChD,YAAY,UAAU,SAAS,YAAY;QAC/C;QACA,SAAS;YACL,cAAc;YACd,SAAS;QACb;QACA,YAAY;YACR,iBAAiB;YACjB,cAAc;YACd,OAAO;YACP,YAAY;YACZ,SAAS;QACb;QACA,YAAY;YACR,OAAO,UAAU,SAAS,YAAY;YACtC,aAAa;QACjB;QACA,YAAY;YACR,OAAO,UAAU,SAAS,YAAY;QAC1C;IACF;IAEA,qBACE,6LAAC,gKAAY;QACX,OAAO;QACP,KAAK;QACL,UAAU;QACV,YAAY;QACZ,cAAc;QACd,UAAU;QACV,QAAQ;QACR,cAAc;YACZ,kBAAkB;QACpB;;;;;;AAGN;GAtGwB;;QACJ,+JAAQ;;;KADJ"}},
    {"offset": {"line": 6992, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/EditorSettingsModal.tsx"],"sourcesContent":["\"use client\";\n\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { X, Type, LayoutTemplate, Keyboard, Sun, Moon } from \"lucide-react\";\nimport { useEffect, useRef } from \"react\";\n\ninterface EditorSettings {\n    fontSize: number;\n    tabSize: number;\n    theme?: \"vs-light\" | \"vs-dark\";\n    keybinding: \"standard\" | \"vim\";\n}\n\ninterface EditorSettingsModalProps {\n    isOpen: boolean;\n    onClose: () => void;\n    settings: EditorSettings;\n    onSettingsChange: (newSettings: EditorSettings) => void;\n}\n\nexport default function EditorSettingsModal({\n    isOpen,\n    onClose,\n    settings,\n    onSettingsChange\n}: EditorSettingsModalProps) {\n    const modalRef = useRef<HTMLDivElement>(null);\n\n    // Close on click outside\n    useEffect(() => {\n        const handleClickOutside = (event: MouseEvent) => {\n            if (modalRef.current && !modalRef.current.contains(event.target as Node)) {\n                onClose();\n            }\n        };\n\n        if (isOpen) {\n            document.addEventListener(\"mousedown\", handleClickOutside);\n        }\n        return () => {\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [isOpen, onClose]);\n\n    // Prevent body scroll when open\n    useEffect(() => {\n        if (isOpen) {\n            document.body.style.overflow = \"hidden\";\n        } else {\n            document.body.style.overflow = \"unset\";\n        }\n    }, [isOpen]);\n\n    return (\n        <AnimatePresence>\n            {isOpen && (\n                <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4\">\n                    <motion.div\n                        ref={modalRef}\n                        initial={{ opacity: 0, scale: 0.95, y: 10 }}\n                        animate={{ opacity: 1, scale: 1, y: 0 }}\n                        exit={{ opacity: 0, scale: 0.95, y: 10 }}\n                        transition={{ duration: 0.2 }}\n                        className=\"w-full max-w-md bg-white dark:bg-[#141414] rounded-xl shadow-2xl border border-gray-200 dark:border-[#262626] overflow-hidden\"\n                    >\n                        {/* Header */}\n                        <div className=\"px-6 py-4 border-b border-gray-100 dark:border-[#262626] flex items-center justify-between bg-gray-50/50 dark:bg-[#1a1a1a]\">\n                            <h2 className=\"text-lg font-bold text-gray-900 dark:text-gray-100\">Editor Settings</h2>\n                            <button\n                                onClick={onClose}\n                                className=\"p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-[#262626] rounded-lg transition-colors\"\n                            >\n                                <X className=\"w-5 h-5\" />\n                            </button>\n                        </div>\n\n                        {/* Content */}\n                        <div className=\"p-6 space-y-6\">\n\n                            {/* Theme */}\n                            <div className=\"space-y-3\">\n                                <div className=\"flex items-center gap-2 text-sm font-semibold text-gray-700\">\n                                    {settings.theme === \"vs-dark\" ? <Moon className=\"w-4 h-4 text-orange-500\" /> : <Sun className=\"w-4 h-4 text-orange-500\" />}\n                                    <span>Theme</span>\n                                </div>\n                                <div className=\"grid grid-cols-2 gap-3\">\n                                    <button\n                                        onClick={() => onSettingsChange({ ...settings, theme: \"vs-light\" })}\n                                        className={`px-4 py-2 text-sm font-medium rounded-lg border transition-all flex items-center justify-center gap-2 ${\n                                            settings.theme === \"vs-light\" || !settings.theme\n                                                ? \"bg-orange-50 dark:bg-orange-500/10 border-orange-200 dark:border-orange-500/30 text-orange-700 dark:text-orange-400 shadow-sm\"\n                                                : \"bg-white dark:bg-[#1e1e1e] border-gray-200 dark:border-[#333] text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-[#262626] hover:border-gray-300 dark:hover:border-[#444]\"\n                                        }`}\n                                    >\n                                        <Sun className=\"w-4 h-4\" /> Light\n                                    </button>\n                                    <button\n                                        onClick={() => onSettingsChange({ ...settings, theme: \"vs-dark\" })}\n                                        className={`px-4 py-2 text-sm font-medium rounded-lg border transition-all flex items-center justify-center gap-2 ${\n                                            settings.theme === \"vs-dark\"\n                                                ? \"bg-gray-800 dark:bg-[#262626] border-gray-700 dark:border-[#333] text-white shadow-sm\"\n                                                : \"bg-white dark:bg-[#1e1e1e] border-gray-200 dark:border-[#333] text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-[#262626] hover:border-gray-300 dark:hover:border-[#444]\"\n                                        }`}\n                                    >\n                                        <Moon className=\"w-4 h-4\" /> Dark\n                                    </button>\n                                </div>\n                            </div>\n\n                            <hr className=\"border-gray-100 dark:border-[#262626]\" />\n\n                            {/* Font Size */}\n                            <div className=\"space-y-3\">\n                                <div className=\"flex items-center gap-2 text-sm font-semibold text-gray-700 dark:text-gray-300\">\n                                    <Type className=\"w-4 h-4 text-orange-500\" />\n                                    <span>Font Size</span>\n                                    <span className=\"ml-auto text-xs font-mono text-gray-500 bg-gray-100 px-2 py-0.5 rounded\">\n                                        {settings.fontSize}px\n                                    </span>\n                                </div>\n                                <div className=\"flex items-center gap-4\">\n                                    <span className=\"text-xs text-gray-400\">12px</span>\n                                    <input\n                                        type=\"range\"\n                                        min=\"12\"\n                                        max=\"24\"\n                                        step=\"1\"\n                                        value={settings.fontSize}\n                                        onChange={(e) => onSettingsChange({ ...settings, fontSize: parseInt(e.target.value) })}\n                                        className=\"flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-orange-600\"\n                                    />\n                                    <span className=\"text-xs text-gray-400\">24px</span>\n                                </div>\n                            </div>\n\n                            <hr className=\"border-gray-100\" />\n\n                            {/* Tab Size */}\n                            <div className=\"space-y-3\">\n                                <div className=\"flex items-center gap-2 text-sm font-semibold text-gray-700\">\n                                    <LayoutTemplate className=\"w-4 h-4 text-orange-500\" />\n                                    <span>Tab Size</span>\n                                </div>\n                                <div className=\"grid grid-cols-2 gap-3\">\n                                    {[2, 4].map((size) => (\n                                        <button\n                                            key={size}\n                                            onClick={() => onSettingsChange({ ...settings, tabSize: size })}\n                                            className={`px-4 py-2 text-sm font-medium rounded-lg border transition-all ${\n                                                settings.tabSize === size\n                                                    ? \"bg-orange-50 dark:bg-orange-500/10 border-orange-200 dark:border-orange-500/30 text-orange-700 dark:text-orange-400 shadow-sm\"\n                                                    : \"bg-white dark:bg-[#1e1e1e] border-gray-200 dark:border-[#333] text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-[#262626] hover:border-gray-300 dark:hover:border-[#444]\"\n                                            }`}\n                                        >\n                                            {size} Spaces\n                                        </button>\n                                    ))}\n                                </div>\n                            </div>\n\n                             {/* Key Binding (Visual only for now if complex) */}\n                             {/* <hr className=\"border-gray-100\" />\n                             <div className=\"space-y-3 opacity-50 pointer-events-none\" title=\"Coming soon\">\n                                 <div className=\"flex items-center gap-2 text-sm font-semibold text-gray-700\">\n                                     <Keyboard className=\"w-4 h-4 text-orange-500\" />\n                                     <span>Key Binding</span>\n                                     <span className=\"ml-auto text-[10px] font-bold text-orange-500 bg-orange-50 px-2 py-0.5 rounded uppercase\">Coming Soon</span>\n                                 </div>\n                                 <div className=\"grid grid-cols-2 gap-3\">\n                                     <button className=\"px-4 py-2 text-sm font-medium rounded-lg bg-orange-50 border border-orange-200 text-orange-700 shadow-sm\">\n                                         Standard\n                                     </button>\n                                     <button className=\"px-4 py-2 text-sm font-medium rounded-lg bg-white border border-gray-200 text-gray-600\">\n                                         Vim\n                                     </button>\n                                 </div>\n                             </div> */}\n\n                        </div>\n\n                        {/* Footer */}\n                        <div className=\"px-6 py-4 bg-gray-50 dark:bg-[#1a1a1a] border-t border-gray-100 dark:border-[#262626] flex justify-end\">\n                            <button\n                                onClick={onClose}\n                                className=\"px-4 py-2 text-sm font-bold text-white bg-gray-900 dark:bg-white dark:text-black rounded-lg hover:bg-black dark:hover:bg-gray-200 transition-colors\"\n                            >\n                                Done\n                            </button>\n                        </div>\n                    </motion.div>\n                </div>\n            )}\n        </AnimatePresence>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAJA;;;;AAoBe,SAAS,oBAAoB,EACxC,MAAM,EACN,OAAO,EACP,QAAQ,EACR,gBAAgB,EACO;;IACvB,MAAM,WAAW,IAAA,uKAAM,EAAiB;IAExC,yBAAyB;IACzB,IAAA,0KAAS;yCAAC;YACN,MAAM;oEAAqB,CAAC;oBACxB,IAAI,SAAS,OAAO,IAAI,CAAC,SAAS,OAAO,CAAC,QAAQ,CAAC,MAAM,MAAM,GAAW;wBACtE;oBACJ;gBACJ;;YAEA,IAAI,QAAQ;gBACR,SAAS,gBAAgB,CAAC,aAAa;YAC3C;YACA;iDAAO;oBACH,SAAS,mBAAmB,CAAC,aAAa;gBAC9C;;QACJ;wCAAG;QAAC;QAAQ;KAAQ;IAEpB,gCAAgC;IAChC,IAAA,0KAAS;yCAAC;YACN,IAAI,QAAQ;gBACR,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;YACnC,OAAO;gBACH,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;YACnC;QACJ;wCAAG;QAAC;KAAO;IAEX,qBACI,6LAAC,+MAAe;kBACX,wBACG,6LAAC;YAAI,WAAU;sBACX,cAAA,6LAAC,uMAAM,CAAC,GAAG;gBACP,KAAK;gBACL,SAAS;oBAAE,SAAS;oBAAG,OAAO;oBAAM,GAAG;gBAAG;gBAC1C,SAAS;oBAAE,SAAS;oBAAG,OAAO;oBAAG,GAAG;gBAAE;gBACtC,MAAM;oBAAE,SAAS;oBAAG,OAAO;oBAAM,GAAG;gBAAG;gBACvC,YAAY;oBAAE,UAAU;gBAAI;gBAC5B,WAAU;;kCAGV,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAG,WAAU;0CAAqD;;;;;;0CACnE,6LAAC;gCACG,SAAS;gCACT,WAAU;0CAEV,cAAA,6LAAC,oMAAC;oCAAC,WAAU;;;;;;;;;;;;;;;;;kCAKrB,6LAAC;wBAAI,WAAU;;0CAGX,6LAAC;gCAAI,WAAU;;kDACX,6LAAC;wCAAI,WAAU;;4CACV,SAAS,KAAK,KAAK,0BAAY,6LAAC,6MAAI;gDAAC,WAAU;;;;;qEAA+B,6LAAC,0MAAG;gDAAC,WAAU;;;;;;0DAC9F,6LAAC;0DAAK;;;;;;;;;;;;kDAEV,6LAAC;wCAAI,WAAU;;0DACX,6LAAC;gDACG,SAAS,IAAM,iBAAiB;wDAAE,GAAG,QAAQ;wDAAE,OAAO;oDAAW;gDACjE,WAAW,CAAC,sGAAsG,EAC9G,SAAS,KAAK,KAAK,cAAc,CAAC,SAAS,KAAK,GAC1C,kIACA,0LACR;;kEAEF,6LAAC,0MAAG;wDAAC,WAAU;;;;;;oDAAY;;;;;;;0DAE/B,6LAAC;gDACG,SAAS,IAAM,iBAAiB;wDAAE,GAAG,QAAQ;wDAAE,OAAO;oDAAU;gDAChE,WAAW,CAAC,sGAAsG,EAC9G,SAAS,KAAK,KAAK,YACb,0FACA,0LACR;;kEAEF,6LAAC,6MAAI;wDAAC,WAAU;;;;;;oDAAY;;;;;;;;;;;;;;;;;;;0CAKxC,6LAAC;gCAAG,WAAU;;;;;;0CAGd,6LAAC;gCAAI,WAAU;;kDACX,6LAAC;wCAAI,WAAU;;0DACX,6LAAC,6MAAI;gDAAC,WAAU;;;;;;0DAChB,6LAAC;0DAAK;;;;;;0DACN,6LAAC;gDAAK,WAAU;;oDACX,SAAS,QAAQ;oDAAC;;;;;;;;;;;;;kDAG3B,6LAAC;wCAAI,WAAU;;0DACX,6LAAC;gDAAK,WAAU;0DAAwB;;;;;;0DACxC,6LAAC;gDACG,MAAK;gDACL,KAAI;gDACJ,KAAI;gDACJ,MAAK;gDACL,OAAO,SAAS,QAAQ;gDACxB,UAAU,CAAC,IAAM,iBAAiB;wDAAE,GAAG,QAAQ;wDAAE,UAAU,SAAS,EAAE,MAAM,CAAC,KAAK;oDAAE;gDACpF,WAAU;;;;;;0DAEd,6LAAC;gDAAK,WAAU;0DAAwB;;;;;;;;;;;;;;;;;;0CAIhD,6LAAC;gCAAG,WAAU;;;;;;0CAGd,6LAAC;gCAAI,WAAU;;kDACX,6LAAC;wCAAI,WAAU;;0DACX,6LAAC,+OAAc;gDAAC,WAAU;;;;;;0DAC1B,6LAAC;0DAAK;;;;;;;;;;;;kDAEV,6LAAC;wCAAI,WAAU;kDACV;4CAAC;4CAAG;yCAAE,CAAC,GAAG,CAAC,CAAC,qBACT,6LAAC;gDAEG,SAAS,IAAM,iBAAiB;wDAAE,GAAG,QAAQ;wDAAE,SAAS;oDAAK;gDAC7D,WAAW,CAAC,+DAA+D,EACvE,SAAS,OAAO,KAAK,OACf,kIACA,0LACR;;oDAED;oDAAK;;+CARD;;;;;;;;;;;;;;;;;;;;;;kCAmCzB,6LAAC;wBAAI,WAAU;kCACX,cAAA,6LAAC;4BACG,SAAS;4BACT,WAAU;sCACb;;;;;;;;;;;;;;;;;;;;;;;;;;;AAS7B;GA9KwB;KAAA"}},
    {"offset": {"line": 7403, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/hooks/use-layout.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * Hook to manage persistent split pane sizes using localStorage\n * @param storageKey Key to save/load sizes from localStorage\n * @param defaultSizes Default sizes if nothing is saved\n */\nexport function usePersistentSplit(storageKey: string, defaultSizes: number[]) {\n    // Start with default sizes to avoid hydration mismatch\n    const [sizes, setSizes] = useState<number[]>(defaultSizes);\n    const [isHydrated, setIsHydrated] = useState(false);\n\n    // key to force re-render of Split component when we programmatically change sizes\n    // react-split sometimes doesn't update visual drag bars when sizes prop changes drastically\n    const [layoutKey, setLayoutKey] = useState(0);\n\n    // Load from local storage on mount\n    useEffect(() => {\n        setIsHydrated(true);\n        try {\n            const item = localStorage.getItem(storageKey);\n            if (item) {\n                const parsed = JSON.parse(item);\n                if (Array.isArray(parsed) && parsed.length === defaultSizes.length) {\n                    setSizes(parsed);\n                    return;\n                }\n            }\n        } catch (error) {\n            console.error(`Failed to load layout for ${storageKey}:`, error);\n        }\n    }, [storageKey, defaultSizes.length]);\n\n    // Save to local storage\n    const saveSizes = useCallback((newSizes: number[]) => {\n        setSizes(newSizes);\n        try {\n            localStorage.setItem(storageKey, JSON.stringify(newSizes));\n        } catch (error) {\n            console.error(`Failed to save layout for ${storageKey}:`, error);\n        }\n    }, [storageKey]);\n\n    // Programmatic reset/update\n    const setSizesProgrammatically = useCallback((newSizes: number[]) => {\n        saveSizes(newSizes);\n        // Bump key to force component remount/refresh if needed\n        setLayoutKey(prev => prev + 1);\n    }, [saveSizes]);\n\n    return {\n        sizes,\n        setSizes: saveSizes,\n        setSizesProgrammatically,\n        isHydrated,\n        layoutKey\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAOO,SAAS,mBAAmB,UAAkB,EAAE,YAAsB;;IACzE,uDAAuD;IACvD,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAW;IAC7C,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,yKAAQ,EAAC;IAE7C,kFAAkF;IAClF,4FAA4F;IAC5F,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAE3C,mCAAmC;IACnC,IAAA,0KAAS;wCAAC;YACN,cAAc;YACd,IAAI;gBACA,MAAM,OAAO,aAAa,OAAO,CAAC;gBAClC,IAAI,MAAM;oBACN,MAAM,SAAS,KAAK,KAAK,CAAC;oBAC1B,IAAI,MAAM,OAAO,CAAC,WAAW,OAAO,MAAM,KAAK,aAAa,MAAM,EAAE;wBAChE,SAAS;wBACT;oBACJ;gBACJ;YACJ,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,WAAW,CAAC,CAAC,EAAE;YAC9D;QACJ;uCAAG;QAAC;QAAY,aAAa,MAAM;KAAC;IAEpC,wBAAwB;IACxB,MAAM,YAAY,IAAA,4KAAW;qDAAC,CAAC;YAC3B,SAAS;YACT,IAAI;gBACA,aAAa,OAAO,CAAC,YAAY,KAAK,SAAS,CAAC;YACpD,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,WAAW,CAAC,CAAC,EAAE;YAC9D;QACJ;oDAAG;QAAC;KAAW;IAEf,4BAA4B;IAC5B,MAAM,2BAA2B,IAAA,4KAAW;oEAAC,CAAC;YAC1C,UAAU;YACV,wDAAwD;YACxD;4EAAa,CAAA,OAAQ,OAAO;;QAChC;mEAAG;QAAC;KAAU;IAEd,OAAO;QACH;QACA,UAAU;QACV;QACA;QACA;IACJ;AACJ;GAlDgB"}},
    {"offset": {"line": 7480, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/workspace/Workspace.tsx"],"sourcesContent":["\"use client\";\nimport Split from 'react-split';\nimport ProblemDescription from './ProblemDescription';\nimport CodeEditor from './CodeEditor';\nimport TestCases from './TestCases';\nimport { Problem, ProblemTestCase } from '@prisma/client';\n\nimport WorkspaceHeader from './WorkspaceHeader';\nimport ContestProtection from '../contest/ContestProtection';\nimport ContestEntryModal from '../contest/ContestEntryModal';\nimport ContestNavigationGuard from '../contest/ContestNavigationGuard';\nimport ContestSidebar from './ContestSidebar';\n\nimport dynamic from 'next/dynamic';\nimport ProblemTour from '../tour/ProblemTour';\n\nconst ProblemSidebar = dynamic(() => import('./ProblemSidebar'), {\n    loading: () => null, // Optional: rendering nothing while loading\n    ssr: false // Client-side specific interaction\n});\n\nimport { useState, useEffect } from 'react';\nimport { toast } from 'sonner';\nimport { getParticipationStatus } from '@/actions/contest';\nimport EditorSettingsModal from './EditorSettingsModal';\nimport { useRouter } from 'next/navigation';\n\ninterface FunctionTemplate {\n    languageId: number;\n    functionTemplate: string;\n    driverCode: string;\n}\n\ninterface WorkspaceProps {\n    problem: Problem & {\n        testCases: ProblemTestCase[];\n        functionTemplates?: FunctionTemplate[];\n        useFunctionTemplate?: boolean;\n        solution?: string | null;\n        tags?: { name: string; slug: string }[];\n    };\n    isSolved: boolean;\n    contestId?: string;\n    contest?: any;\n    solvedProblemIds?: string[];\n    nextProblemSlug?: string | null;\n    prevProblemSlug?: string | null;\n}\n\nimport { authClient } from '@/lib/auth-client';\nimport { DEFAULT_LANGUAGE_ID } from '@/lib/languages';\nimport { usePersistentSplit } from '@/hooks/use-layout';\n\nconst LANGUAGE_STORAGE_KEY = 'algofox_selected_language';\nconst SQL_LANGUAGE_ID = 82; // SQL language ID\n\n// Get language from localStorage or use default\nfunction getStoredLanguageId(domain?: string): number {\n    if (typeof window === 'undefined') {\n        // For SQL problems, default to SQL language\n        return domain === \"SQL\" ? SQL_LANGUAGE_ID : DEFAULT_LANGUAGE_ID;\n    }\n    try {\n        const stored = localStorage.getItem(LANGUAGE_STORAGE_KEY);\n        if (stored) {\n            const id = parseInt(stored, 10);\n            if (!isNaN(id)) {\n                // For SQL problems, always use SQL language\n                if (domain === \"SQL\") {\n                    return SQL_LANGUAGE_ID;\n                }\n                return id;\n            }\n        }\n    } catch (e) {\n        console.error('Failed to read language from localStorage', e);\n    }\n    // For SQL problems, default to SQL language\n    return domain === \"SQL\" ? SQL_LANGUAGE_ID : DEFAULT_LANGUAGE_ID;\n}\n\n\nexport default function Workspace({ problem, isSolved, contestId, contest, solvedProblemIds = [], nextProblemSlug, prevProblemSlug }: WorkspaceProps) {\n    const { data: session } = authClient.useSession();\n    const router = useRouter();\n    const [code, setCode] = useState<string>(\"// Write your code here\");\n    const [isSubmitting, setIsSubmitting] = useState(false);\n    const [isSolvedState, setIsSolvedState] = useState(isSolved);\n\n    // Contest session state\n    const [showEntryModal, setShowEntryModal] = useState(false);\n    const [contestSessionId, setContestSessionId] = useState<string | null>(null);\n    const [contestModeActive, setContestModeActive] = useState(false);\n\n    // Sidebar state\n    const [isSidebarOpen, setIsSidebarOpen] = useState(false);\n\n    // Start with default language to avoid hydration mismatch, then update from localStorage\n    const [languageId, setLanguageId] = useState(\n        problem.domain === \"SQL\" ? SQL_LANGUAGE_ID : DEFAULT_LANGUAGE_ID\n    );\n\n    // Load language from localStorage after hydration (client-side only)\n    useEffect(() => {\n        const storedLanguageId = getStoredLanguageId(problem.domain);\n        // For SQL problems, always use SQL language\n        const finalLanguageId = problem.domain === \"SQL\" ? SQL_LANGUAGE_ID : storedLanguageId;\n        if (finalLanguageId !== languageId) {\n            setLanguageId(finalLanguageId);\n            // Clear default boilerplate if we are switching languages on load\n            setCode(\"\");\n        }\n    }, [problem.domain]);\n\n    // Check existing contest participation on mount\n    useEffect(() => {\n        if (!contestId) return;\n\n        const checkParticipation = async () => {\n            const result = await getParticipationStatus(contestId);\n            if (result.success && result.participation) {\n                if (result.participation.sessionId && result.participation.acceptedRules) {\n                    // User has already started - activate contest mode\n                    setContestSessionId(result.participation.sessionId);\n                    setContestModeActive(true);\n                } else if (!result.participation.isFinished && !result.participation.isBlocked) {\n                    // Show entry modal for new participants\n                    setShowEntryModal(true);\n                }\n            } else {\n                // No participation yet - show entry modal\n                setShowEntryModal(true);\n            }\n        };\n\n        checkParticipation();\n    }, [contestId]);\n\n    const handleContestStart = (sessionId: string) => {\n        setContestSessionId(sessionId);\n        setContestModeActive(true);\n        setShowEntryModal(false);\n        toast.success(\"Contest mode activated! Good luck!\");\n    };\n\n    const handleContestBlocked = () => {\n        // Just a callback, UI is handled by ContestProtection\n    };\n\n    // Handle language change and persist to localStorage\n    const handleLanguageChange = (newLanguageId: number) => {\n        // For SQL problems, always use SQL language - don't allow changes\n        if (problem.domain === \"SQL\") {\n            return; // Prevent language changes for SQL problems\n        }\n\n        setLanguageId(newLanguageId);\n        setCode(\"\"); // Clear code to prevent stale submissions while new draft loads\n        try {\n            localStorage.setItem(LANGUAGE_STORAGE_KEY, newLanguageId.toString());\n        } catch (e) {\n            console.error('Failed to save language to localStorage', e);\n        }\n    };\n\n    // Editor Settings State\n    const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n    const [editorSettings, setEditorSettings] = useState({\n        fontSize: 14,\n        tabSize: 4,\n        theme: \"vs-light\" as \"vs-light\" | \"vs-dark\",\n        keybinding: \"standard\" as \"standard\" | \"vim\"\n    });\n\n    // Load settings from localStorage\n    useEffect(() => {\n        try {\n            const stored = localStorage.getItem('algofox_editor_settings');\n            if (stored) {\n                setEditorSettings(JSON.parse(stored));\n            }\n        } catch (e) {\n            console.error('Failed to load editor settings', e);\n        }\n    }, []);\n\n    // Save settings to localStorage\n    const handleSettingsChange = (newSettings: Omit<typeof editorSettings, \"theme\"> & { theme?: \"vs-light\" | \"vs-dark\" }) => {\n        setEditorSettings({\n            ...newSettings,\n            theme: newSettings.theme || \"vs-light\"\n        });\n        try {\n            localStorage.setItem('algofox_editor_settings', JSON.stringify(newSettings));\n        } catch (e) {\n            console.error('Failed to save editor settings', e);\n        }\n    };\n\n    const [activeTab, setActiveTab] = useState<\"description\" | \"solutions\" | \"submissions\">(\"description\");\n    const [isRunning, setIsRunning] = useState(false);\n    const [submissionResults, setSubmissionResults] = useState<any[] | undefined>(undefined);\n    const [submissionStatus, setSubmissionStatus] = useState<string | null>(null);\n    const [submissionMode, setSubmissionMode] = useState<\"RUN\" | \"SUBMIT\" | null>(null);\n\n    const {\n        sizes: mainSizes,\n        setSizes: setMainSizes,\n        isHydrated: mainHydrated\n    } = usePersistentSplit('algofox_workspace_main_split', [40, 60]);\n\n    const {\n        sizes: verticalSizes,\n        setSizes: setVerticalSizes,\n        setSizesProgrammatically: setVerticalSizesProgrammatically,\n        layoutKey: verticalLayoutKey,\n        isHydrated: verticalHydrated\n    } = usePersistentSplit('algofox_workspace_vertical_split', [60, 40]);\n\n    // Solved Problem IDs State (for Sidebar & Optimistic Updates)\n    const [solvedIds, setSolvedIds] = useState<string[]>(solvedProblemIds);\n\n    // Sync if props change (e.g. navigation)\n    useEffect(() => {\n        setSolvedIds(solvedProblemIds);\n    }, [solvedProblemIds]);\n\n    const handleSubmission = async (mode: \"RUN\" | \"SUBMIT\") => {\n        if (!code) {\n            toast.error(\"Code cannot be empty\");\n            return;\n        }\n\n        if (!session?.user?.id) {\n            toast.error(\"Please sign in to submit\");\n            return;\n        }\n\n        // AUTO-EXPAND: Check if TestCases pane is collapsed (e.g., < 5%)\n        // Vertical split sizes are [Editor%, TestCases%]\n        // If TestCases is too small, reset to default [60, 40]\n        if (verticalSizes[1] < 5) {\n            setVerticalSizesProgrammatically([60, 40]);\n        }\n\n        try {\n            if (mode === \"RUN\") setIsRunning(true);\n            else setIsSubmitting(true);\n\n            toast.info(mode === \"RUN\" ? \"Running code...\" : \"Submitting code...\");\n\n            // 1. Create Submission / Run Code\n            const res = await fetch(\"/api/submissions\", {\n                method: \"POST\",\n                headers: { \"Content-Type\": \"application/json\" },\n                body: JSON.stringify({\n                    userId: session.user.id,\n                    problemId: problem.id,\n                    languageId: languageId,\n                    code: code,\n                    mode: mode,\n                    contestId: contestId\n                })\n            });\n\n            if (!res.ok) throw new Error(\"Submission failed\");\n            const data = await res.json();\n\n\n\n            // HANDLE BOTH RUN & SUBMIT MODES (SSE)\n            const { submissionId } = data;\n\n            setSubmissionMode(mode);\n            setSubmissionResults(problem.testCases.map((tc, idx) => ({\n                index: idx,\n                status: \"PENDING\"\n            })));\n            setSubmissionStatus(null);\n\n            // Connect to SSE\n            const eventSource = new EventSource(`/api/sse/submission/${submissionId}`);\n\n            eventSource.onmessage = (event) => {\n                const payload = JSON.parse(event.data);\n\n                if (payload.type === \"CASE_UPDATE\") {\n                    // payload.data is array of updated cases\n                    setSubmissionResults(prev => {\n                        const current = prev ? [...prev] : [];\n                        const updates = payload.data as any[];\n\n                        updates.forEach(update => {\n                             // Find if exists\n                             const idx = current.findIndex(c => c.index === update.index);\n                             if (idx >= 0) {\n                                 current[idx] = update;\n                             } else {\n                                 current.push(update);\n                             }\n                        });\n                        // Sort by index just in case\n                        return current.sort((a, b) => a.index - b.index);\n                    });\n                } else if (payload.type === \"COMPLETE\") {\n                     eventSource.close();\n                     setSubmissionStatus(payload.data.status);\n\n                     if (mode === \"RUN\") setIsRunning(false);\n                     else setIsSubmitting(false);\n\n                     if (payload.data.status === \"ACCEPTED\") {\n                         const desc = `Time: ${payload.data.time?.toFixed(3) || 0}s | Memory: ${payload.data.memory || 0}KB`;\n                         if (mode === \"SUBMIT\") {\n                             toast.success(\"Submitted Successfully!\", { description: desc });\n                             setIsSolvedState(true);\n                             setActiveTab(\"submissions\");\n\n                             // Optimistically update solved status in sidebar\n                             if (!solvedIds.includes(problem.id)) {\n                                 setSolvedIds(prev => [...prev, problem.id]);\n                             }\n\n                             // Refresh server components to update lists/cache\n                             router.refresh();\n\n                             window.dispatchEvent(new CustomEvent(\"pointsUpdated\"));\n\n                             // If in contest and submitted successfully, redirect back to contest dashboard\n                             if (contestId) {\n                                toast.success(\"Problem Solved! Returning to contest...\", { duration: 2000 });\n                                setTimeout(() => {\n                                    router.push(`/contest/${contestId}`);\n                                }, 1500);\n                             }\n                         } else {\n                             toast.success(\"Run Accepted!\", { description: desc });\n                         }\n                     } else {\n                          toast.error(`Result: ${payload.data.status}`);\n                     }\n                }\n            };\n\n            eventSource.onerror = (err) => {\n                console.error(\"SSE Error:\", err);\n                eventSource.close();\n                // Fallback polling or simple completion check could go here if needed\n                // For now, just stop the spinner\n                if (mode === \"RUN\") setIsRunning(false);\n                else setIsSubmitting(false);\n            };\n\n        } catch (error) {\n            console.error(error);\n            toast.error(\"Something went wrong\");\n            if (mode === \"RUN\") setIsRunning(false);\n            else setIsSubmitting(false);\n        }\n    };\n\n    if (!mainHydrated || !verticalHydrated) {\n        return null; // or a loading skeleton\n    }\n\n    return (\n        <div className=\"h-screen w-full bg-white dark:bg-[#0a0a0a] flex flex-col overflow-hidden\">\n             {/* TOUR COMPONENT - Only render if not in contest mode (optional) or just always render and let it handle its own state */}\n             {!contestId && <ProblemTour />}\n\n            <EditorSettingsModal\n                isOpen={isSettingsOpen}\n                onClose={() => setIsSettingsOpen(false)}\n                settings={editorSettings}\n                onSettingsChange={handleSettingsChange}\n            />\n\n            {/* Contest Protection (only active after entry) */}\n            {contestId && contestModeActive && contestSessionId && (\n                <>\n                    <ContestProtection\n                        contestId={contestId}\n                        sessionId={contestSessionId}\n                        onBlocked={handleContestBlocked}\n                    />\n                    <ContestNavigationGuard\n                        contestId={contestId}\n                        allowedPaths={[\n                            `/problems/`,  // Allow all problem pages\n                            `/contest/${contestId}`,\n                        ]}\n                    />\n                </>\n            )}\n            {/* Problem Navigation Sidebar - Only show when not in contest mode */}\n            {!contestId && (\n                <ProblemSidebar\n                    isOpen={isSidebarOpen}\n                    onClose={() => setIsSidebarOpen(false)}\n                    currentProblemId={problem.id}\n                    domain={problem.domain}\n                    problemType={problem.type}\n                    solvedProblemIds={solvedIds}\n                />\n            )}\n\n            <WorkspaceHeader\n                onSubmit={() => handleSubmission(\"SUBMIT\")}\n                onRun={() => handleSubmission(\"RUN\")}\n                isSubmitting={isSubmitting}\n                isRunning={isRunning}\n                contestId={contestId}\n                endTime={contest?.endTime}\n                nextProblemSlug={nextProblemSlug}\n                prevProblemSlug={prevProblemSlug}\n                domain={problem.domain}\n                type={problem.type}\n                onToggleSidebar={() => setIsSidebarOpen(true)}\n            />\n            <div className=\"flex-1 overflow-hidden flex flex-row min-h-0\">\n                {contest && (\n                    <ContestSidebar\n                        contest={contest}\n                        currentProblemId={problem.id}\n                        solvedProblemIds={solvedProblemIds}\n                    />\n                )}\n                <div className=\"flex-1 overflow-hidden min-w-0\">\n                    <Split\n                        className=\"split flex h-full\"\n                        sizes={mainSizes}\n                        minSize={300}\n                        gutterSize={4}\n                        snapOffset={30}\n                        onDragEnd={setMainSizes}\n                    >\n                        {/* LEFT SIDE: DESCRIPTION */}\n                        <div id=\"problem-description\" className=\"h-full overflow-hidden\">\n                            <ProblemDescription\n                                problem={problem}\n                                activeTab={activeTab}\n                                onTabChange={setActiveTab}\n                                isSolved={isSolvedState}\n                                contestId={contestId}\n                            />\n                        </div>\n\n                        {/* RIGHT SIDE: EDITOR + TESTCASES */}\n                        <div className=\"h-full overflow-hidden flex flex-col\">\n                            <Split\n                                key={verticalLayoutKey} // Force remount if we programmatically resize\n                                className=\"split-vertical flex flex-col h-full\"\n                                direction=\"vertical\"\n                                sizes={verticalSizes}\n                                minSize={0} // Allow collapsing fully if needed\n                                gutterSize={4}\n                                onDragEnd={setVerticalSizes}\n                            >\n                                <div id=\"code-editor\" className=\"h-full overflow-hidden\">\n                                    <CodeEditor\n                                        key={`${problem.id}-${languageId}`} // Stable key: remount only when problem or language changes\n                                        value={code}\n                                        onChange={(value) => setCode(value || \"\")}\n                                        languageId={languageId}\n                                        onLanguageChange={handleLanguageChange}\n                                        problemId={problem.id}\n                                        domain={problem.domain}\n                                        functionTemplates={\n                                            problem.useFunctionTemplate && problem.functionTemplates\n                                                ? problem.functionTemplates\n                                                : undefined\n                                        }\n                                        settings={editorSettings}\n                                        onOpenSettings={() => setIsSettingsOpen(true)}\n                                        readOnly={isSubmitting}\n                                        userId={session?.user?.id || \"\"}\n                                    />\n                                </div>\n                                <div id=\"test-cases\" className=\"h-full overflow-hidden flex flex-col bg-white dark:bg-[#0a0a0a]\">\n                                    <TestCases\n                                        cases={problem.testCases}\n                                        results={submissionResults}\n                                        status={submissionStatus}\n                                        mode={submissionMode}\n                                        problemId={problem.id}\n                                    />\n                                </div>\n                            </Split>\n                        </div>\n                    </Split>\n\n                    <style jsx global>{`\n                    .split {\n                        display: flex;\n                    }\n                    .split-vertical {\n                        display: flex;\n                        flex-direction: column;\n                    }\n                    .gutter {\n                        background-color: #f3f4f6;\n                        background-repeat: no-repeat;\n                        background-position: 50%;\n                        transition: background-color 0.2s;\n                    }\n                    .dark .gutter {\n                        background-color: #1a1a1a;\n                    }\n                    .gutter:hover {\n                        background-color: #e5e7eb;\n                    }\n                    .dark .gutter:hover {\n                        background-color: #262626;\n                    }\n                    .gutter.gutter-horizontal {\n                        cursor: col-resize;\n                        border-left: 1px solid #e5e7eb;\n                        border-right: 1px solid #e5e7eb;\n                        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZgmwIA6Jhouse1DAAAAABJRU5ErkJggg==');\n                    }\n                    .dark .gutter.gutter-horizontal {\n                        border-left: 1px solid #262626;\n                        border-right: 1px solid #262626;\n                    }\n                    .gutter.gutter-vertical {\n                        cursor: row-resize;\n                        border-top: 1px solid #e5e7eb;\n                        border-bottom: 1px solid #e5e7eb;\n                        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABoV83XAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjAAIALAAJy8wOmAAAAABJRU5ErkJggg==');\n                    }\n                    .dark .gutter.gutter-vertical {\n                        border-top: 1px solid #262626;\n                        border-bottom: 1px solid #262626;\n                    }\n                `}</style>\n                </div>\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}}]
}