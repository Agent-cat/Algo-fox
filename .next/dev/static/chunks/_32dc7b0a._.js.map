{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAgoBsB,sBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAkmBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestEntryModal.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport {\n  Shield,\n  Monitor,\n  Eye,\n  Keyboard,\n  ArrowRight,\n  Check,\n  Lock,\n  X,\n  ChevronLeft,\n} from \"lucide-react\";\nimport { startContestSession, verifyContestPassword } from \"@/actions/contest\";\nimport { toast } from \"sonner\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ContestEntryModalProps {\n  contestId: string;\n  contestTitle: string;\n  requiresPassword?: boolean;\n  isOpen: boolean;\n  onClose: () => void;\n  onStart: (sessionId: string) => void;\n}\n\nconst RULES = [\n  {\n    icon: Monitor,\n    title: \"Fullscreen Enforced\",\n    description: \"The contest runs in fullscreen. Exiting may be flagged.\",\n  },\n  {\n    icon: Eye,\n    title: \"Focus Tracking\",\n    description: \"Tab switching and window blurring are monitored.\",\n  },\n  {\n    icon: Keyboard,\n    title: \"Input Restricted\",\n    description: \"Copy-paste and developer tools are disabled.\",\n  },\n  {\n    icon: Shield,\n    title: \"Proctored Environment\",\n    description: \"suspicious activity is logged for review.\",\n  },\n];\n\ntype Step = \"PASSWORD\" | \"RULES\" | \"CONFIRM\";\n\nexport default function ContestEntryModal({\n  contestId,\n  contestTitle,\n  requiresPassword,\n  isOpen,\n  onClose,\n  onStart,\n}: ContestEntryModalProps) {\n  const [isLoading, setIsLoading] = useState(false);\n  const [step, setStep] = useState<Step>(\"RULES\");\n  const [password, setPassword] = useState(\"\");\n  const [agreed, setAgreed] = useState(false);\n\n  useEffect(() => {\n    if (isOpen) {\n      if (requiresPassword) {\n        setStep(\"PASSWORD\");\n      } else {\n        setStep(\"RULES\");\n      }\n      setAgreed(false);\n      setPassword(\"\");\n      setIsLoading(false);\n    }\n  }, [isOpen, requiresPassword]);\n\n  const handleVerifyPassword = async () => {\n    if (!password) {\n      toast.error(\"Enter the contest password\");\n      return;\n    }\n    setIsLoading(true);\n    try {\n      const result = await verifyContestPassword(contestId, password);\n      if (result.success) {\n        setStep(\"RULES\");\n        toast.success(\"Access granted\");\n      } else {\n        toast.error(result.error || \"Incorrect password\");\n      }\n    } catch {\n      toast.error(\"Verification failed\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleStartContest = async () => {\n    if (!agreed) return;\n    setIsLoading(true);\n    try {\n      const result = await startContestSession(contestId, password);\n      if (!result.success) {\n        toast.error(result.error || \"Could not start session\");\n        setIsLoading(false);\n        return;\n      }\n\n      try {\n        await document.documentElement.requestFullscreen();\n      } catch (e) {\n        console.warn(\"Fullscreen failed\", e);\n      }\n\n      toast.success(\"Good luck!\");\n      onStart(result.sessionId!);\n    } catch {\n      toast.error(\"Failed to initialize contest\");\n      setIsLoading(false);\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"fixed inset-0 z-[9999] flex items-center justify-center p-4\">\n      {/* Backdrop */}\n      <div\n        className=\"absolute inset-0 bg-white/80 dark:bg-black/80 backdrop-blur-md transition-opacity\"\n        onClick={onClose}\n      />\n\n      {/* Modal Content */}\n      <div className=\"relative bg-white dark:bg-[#0a0a0a] w-full max-w-md rounded-3xl shadow-2xl border border-gray-100 dark:border-[#262626] overflow-hidden animate-in fade-in zoom-in-95 duration-200\">\n\n        {/* Progress / Navigation Header */}\n        <div className=\"px-8 pt-8 flex items-center justify-between\">\n          <div className=\"flex gap-2\">\n            {[1, 2, 3].map((i) => {\n               // Calculate current step index\n               let currentStepIdx = 0;\n               if (requiresPassword) {\n                 if (step === \"PASSWORD\") currentStepIdx = 1;\n                 if (step === \"RULES\") currentStepIdx = 2;\n                 if (step === \"CONFIRM\") currentStepIdx = 3;\n               } else {\n                 if (step === \"RULES\") currentStepIdx = 1; // Actually step 1 visually\n                 if (step === \"CONFIRM\") currentStepIdx = 2;\n               }\n               // Normalizing because map index is simple\n               // If requiresPassword: Steps are Pass(1), Rules(2), Confirm(3)\n               // If not: Rules(1), Confirm(2) -> effectively 2 steps visually\n\n               const totalSteps = requiresPassword ? 3 : 2;\n               if (i > totalSteps) return null;\n\n               let isActive = false;\n               if (requiresPassword) {\n                   if (i === 1 && step === \"PASSWORD\") isActive = true;\n                   if (i === 2 && step === \"RULES\") isActive = true;\n                   if (i === 3 && step === \"CONFIRM\") isActive = true;\n               } else {\n                   if (i === 1 && step === \"RULES\") isActive = true;\n                   if (i === 2 && step === \"CONFIRM\") isActive = true;\n               }\n\n               const isCompleted = requiresPassword\n                ? (i === 1 && step !== \"PASSWORD\") || (i === 2 && step === \"CONFIRM\")\n                : (i === 1 && step === \"CONFIRM\");\n\n               return (\n                <div\n                    key={i}\n                    className={cn(\n                        \"h-1 rounded-full transition-all duration-300\",\n                        isActive ? \"w-8 bg-orange-600\" : isCompleted ? \"w-2 bg-orange-200 dark:bg-orange-900\" : \"w-2 bg-gray-100 dark:bg-[#262626]\"\n                    )}\n                />\n               );\n            })}\n          </div>\n          <button onClick={onClose} className=\"p-2 -mr-2 text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors\">\n            <X className=\"w-5 h-5\" />\n          </button>\n        </div>\n\n        <div className=\"p-8 min-h-[400px] flex flex-col\">\n          {/* PASSWORD STEP */}\n          {step === \"PASSWORD\" && (\n            <div className=\"flex-1 flex flex-col animate-in slide-in-from-right-8 duration-300\">\n              <div className=\"mb-8\">\n                <div className=\"w-12 h-12 bg-gray-50 dark:bg-[#1a1a1a] rounded-2xl flex items-center justify-center mb-6\">\n                    <Lock className=\"w-6 h-6 text-gray-900 dark:text-white\" />\n                </div>\n                <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-2\">Private Contest</h2>\n                <p className=\"text-gray-500 dark:text-gray-400\">Enter the access code to join.</p>\n              </div>\n\n              <div className=\"space-y-4\">\n                <input\n                    type=\"password\"\n                    value={password}\n                    onChange={(e) => setPassword(e.target.value)}\n                    onKeyDown={(e) => e.key === \"Enter\" && handleVerifyPassword()}\n                    placeholder=\"Password\"\n                    autoFocus\n                    className=\"w-full bg-gray-50 dark:bg-[#141414] border-gray-200 dark:border-[#262626] rounded-xl px-4 py-4 text-center text-2xl font-bold tracking-widest focus:ring-2 focus:ring-orange-500/20 focus:border-orange-500 outline-none transition-all placeholder:text-gray-300 dark:text-white dark:placeholder:text-gray-700\"\n                />\n              </div>\n\n              <div className=\"mt-auto pt-8\">\n                <button\n                    onClick={handleVerifyPassword}\n                    disabled={!password || isLoading}\n                    className=\"w-full bg-gray-900 dark:bg-white text-white dark:text-black py-4 rounded-xl font-bold text-sm tracking-wide hover:opacity-90 transition-opacity disabled:opacity-50 flex items-center justify-center gap-2\"\n                >\n                    {isLoading ? \"Verifying...\" : \"Continue\"}\n                    {!isLoading && <ArrowRight className=\"w-4 h-4\" />}\n                </button>\n              </div>\n            </div>\n          )}\n\n          {/* RULES STEP */}\n          {step === \"RULES\" && (\n            <div className=\"flex-1 flex flex-col animate-in slide-in-from-right-8 duration-300\">\n               <div className=\"mb-8\">\n                 <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-2\">Contest Rules</h2>\n                 <p className=\"text-gray-500 dark:text-gray-400\">Strict proctoring is active.</p>\n               </div>\n\n               <div className=\"space-y-6\">\n                 {RULES.map((rule, idx) => {\n                     const Icon = rule.icon;\n                     return (\n                         <div key={idx} className=\"flex gap-4\">\n                             <div className=\"w-10 h-10 shrink-0 rounded-full bg-gray-50 dark:bg-[#1a1a1a] flex items-center justify-center\">\n                                 <Icon className=\"w-5 h-5 text-gray-900 dark:text-white\" />\n                             </div>\n                             <div>\n                                 <h3 className=\"font-semibold text-gray-900 dark:text-white text-sm\">{rule.title}</h3>\n                                 <p className=\"text-xs text-gray-500 dark:text-gray-400 leading-relaxed mt-0.5\">{rule.description}</p>\n                             </div>\n                         </div>\n                     )\n                 })}\n               </div>\n\n               <div className=\"mt-auto pt-8\">\n                <button\n                    onClick={() => setStep(\"CONFIRM\")}\n                    className=\"w-full bg-gray-900 dark:bg-white text-white dark:text-black py-4 rounded-xl font-bold text-sm tracking-wide hover:opacity-90 transition-opacity flex items-center justify-center gap-2\"\n                >\n                    I Understand\n                    <ArrowRight className=\"w-4 h-4\" />\n                </button>\n              </div>\n            </div>\n          )}\n\n          {/* CONFIRM STEP */}\n          {step === \"CONFIRM\" && (\n            <div className=\"flex-1 flex flex-col animate-in slide-in-from-right-8 duration-300\">\n                <button\n                  onClick={() => setStep(\"RULES\")}\n                  className=\"mb-6 flex items-center gap-2 text-sm text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors w-fit\"\n                >\n                    <ChevronLeft className=\"w-4 h-4\" />\n                    Back\n                </button>\n\n                <div className=\"text-center mb-8\">\n                   <div className=\"w-16 h-16 bg-orange-100 dark:bg-orange-500/20 mx-auto rounded-full flex items-center justify-center mb-6 animate-pulse\">\n                        <Shield className=\"w-8 h-8 text-orange-600 dark:text-orange-500\" />\n                   </div>\n                   <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-2\">Ready to Start?</h2>\n                   <p className=\"text-gray-500 dark:text-gray-400 text-sm max-w-[260px] mx-auto\">\n                        Once you begin, your screen will be monitored. Violations may lead to disqualification.\n                   </p>\n                </div>\n\n                <div className=\"bg-gray-50 dark:bg-[#141414] border border-gray-100 dark:border-[#262626] rounded-xl p-4 mb-6\">\n                    <label className=\"flex items-start gap-3 cursor-pointer\">\n                        <div className=\"relative flex items-center mt-0.5\">\n                            <input\n                                type=\"checkbox\"\n                                checked={agreed}\n                                onChange={(e) => setAgreed(e.target.checked)}\n                                className=\"peer h-5 w-5 appearance-none rounded-md border-2 border-gray-300 dark:border-gray-600 checked:border-orange-500 checked:bg-orange-500 transition-all\"\n                            />\n                            <Check className=\"pointer-events-none absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-3.5 h-3.5 text-white opacity-0 peer-checked:opacity-100\" />\n                        </div>\n                        <span className=\"text-xs text-gray-600 dark:text-gray-400 select-none leading-relaxed\">\n                            I verify that I am the registered participant and I agree to follow all contest rules honestly.\n                        </span>\n                    </label>\n                </div>\n\n                <div className=\"mt-auto\">\n                    <button\n                        onClick={handleStartContest}\n                        disabled={!agreed || isLoading}\n                        className=\"w-full bg-linear-to-r from-orange-600 to-orange-500 text-white py-4 rounded-xl font-bold text-sm tracking-wide hover:shadow-lg hover:shadow-orange-500/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2\"\n                    >\n                        {isLoading ? (\n                             <div className=\"w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin\" />\n                        ) : (\n                            <>\n                                Enter Contest\n                                <ArrowRight className=\"w-4 h-4\" />\n                            </>\n                        )}\n                    </button>\n                </div>\n            </div>\n          )}\n\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 625, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAwtBsB,sBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA28BsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 655, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestProtection.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState, useRef, useCallback } from \"react\";\n\nimport {\n  AlertTriangle,\n  ShieldX,\n  Monitor,\n  Eye,\n  Lock,\n  Ban,\n  Clock,\n} from \"lucide-react\";\nimport { logContestViolation, getParticipationStatus } from \"@/actions/contest\";\n\ninterface ContestProtectionProps {\n  contestId: string;\n  sessionId: string;\n  onAutoSubmit?: () => void;\n  onBlocked?: () => void;\n  paused?: boolean;\n}\n\ninterface ViolationState {\n  total: number;\n  isFlagged: boolean;\n  isBlocked: boolean;\n  tempBlockedUntil: string | null;\n  permanentlyBlocked: boolean;\n}\n\nconst MAX_WARNINGS = 6;\nconst FLAG_THRESHOLD = 3;\n\n// Blocked keyboard shortcuts\nconst BLOCKED_SHORTCUTS = [\n  { key: \"c\", ctrl: true, shift: false }, // Ctrl+C\n  { key: \"v\", ctrl: true, shift: false }, // Ctrl+V\n  { key: \"x\", ctrl: true, shift: false }, // Ctrl+X\n  { key: \"u\", ctrl: true, shift: false }, // Ctrl+U (view source)\n  { key: \"s\", ctrl: true, shift: false }, // Ctrl+S\n  { key: \"p\", ctrl: true, shift: false }, // Ctrl+P (print)\n  { key: \"i\", ctrl: true, shift: true }, // Ctrl+Shift+I (devtools)\n  { key: \"j\", ctrl: true, shift: true }, // Ctrl+Shift+J (console)\n  { key: \"c\", ctrl: true, shift: true }, // Ctrl+Shift+C (inspect)\n  { key: \"F12\", ctrl: false, shift: false }, // F12\n];\n\nexport default function ContestProtection({\n  contestId,\n  sessionId,\n  onAutoSubmit,\n  onBlocked,\n  paused = false,\n}: ContestProtectionProps) {\n  const [violations, setViolations] = useState<ViolationState>({\n    total: 0,\n    isFlagged: false,\n    isBlocked: false,\n    tempBlockedUntil: null,\n    permanentlyBlocked: false,\n  });\n  const [showWarningPopup, setShowWarningPopup] = useState(false);\n  const [needsFullscreen, setNeedsFullscreen] = useState(false);\n  const [currentViolationType, setCurrentViolationType] = useState<string>(\"\");\n  const [isEditorLocked, setIsEditorLocked] = useState(false);\n  const [tempBlockTimeLeft, setTempBlockTimeLeft] = useState<number>(0);\n  const isMounted = useRef(false);\n  const broadcastChannel = useRef<BroadcastChannel | null>(null);\n  const lastViolationTime = useRef<number>(0);\n  const isProcessingViolation = useRef(false);\n  const isRefreshing = useRef(false);\n  const isNavigating = useRef(false); // Track internal navigation to problem pages\n\n  // Ref to track fullscreen needs for event listeners (avoids stale closures)\n  const needsFullscreenRef = useRef(false);\n\n  useEffect(() => {\n    needsFullscreenRef.current = needsFullscreen;\n  }, [needsFullscreen]);\n\n  // Global debounce - only ONE violation allowed every 2 seconds\n  const canLogViolation = useCallback(() => {\n    const now = Date.now();\n    if (paused) return false;\n\n    // If already processing or locked - DO NOT log more violations\n    if (isProcessingViolation.current) return false;\n    if (isEditorLocked) return false;\n    // NOTE: We allow logging even if showWarningPopup is true (e.g. for tab switching while popup is open)\n    // Violations are logged even during temp block to allow escalation to permanent block\n\n    // 2 second global cooldown to prevent double-logging same event\n    if (now - lastViolationTime.current < 2000) return false;\n\n    return true;\n  }, [isEditorLocked, paused]);\n\n  // Log violation to server and update state\n  const handleViolation = useCallback(\n    async (\n      type:\n        | \"TAB_SWITCH\"\n        | \"FULLSCREEN_EXIT\"\n        | \"COPY_PASTE\"\n        | \"DEVTOOLS_OPEN\"\n        | \"KEYBOARD_SHORTCUT\"\n        | \"NAVIGATION_ATTEMPT\"\n        | \"MULTI_TAB\",\n      message: string\n    ) => {\n      // Skip if navigating internally (prevents false positives when clicking problems)\n      if (!isMounted.current || isRefreshing.current || isNavigating.current)\n        return;\n\n      // Always show popup for user awareness\n      setCurrentViolationType(message);\n      setShowWarningPopup(true);\n\n      // Keyboard shortcuts and copy/paste ONLY show warning, don't count as violations\n      const warningOnlyTypes = [\"KEYBOARD_SHORTCUT\", \"COPY_PASTE\"];\n      if (warningOnlyTypes.includes(type)) {\n        // Just show warning, don't log to server or increment counter\n        return;\n      }\n\n      // But only log to server if cooldown passed\n      if (!canLogViolation()) {\n        return;\n      }\n\n      // Lock and update timestamp immediately\n      isProcessingViolation.current = true;\n      lastViolationTime.current = Date.now();\n\n      try {\n        const result = await logContestViolation(contestId, type, message);\n\n        if (result.success) {\n          const newState = {\n            total: result.totalViolations || 0,\n            isFlagged: result.isFlagged || false,\n            isBlocked: result.isBlocked || false,\n            tempBlockedUntil: result.tempBlockedUntil || null,\n            permanentlyBlocked: result.permanentlyBlocked || false,\n          };\n          setViolations(newState);\n\n          // Handle tiered escalation\n          if (result.permanentlyBlocked) {\n            setIsEditorLocked(true);\n            onBlocked?.();\n          } else if (result.tempBlockedUntil) {\n            setIsEditorLocked(true);\n            // Calculate time left\n            const timeLeft =\n              new Date(result.tempBlockedUntil).getTime() - Date.now();\n            setTempBlockTimeLeft(Math.max(0, Math.floor(timeLeft / 1000)));\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n      } finally {\n        isProcessingViolation.current = false;\n      }\n    },\n    [contestId, canLogViolation, onAutoSubmit, onBlocked]\n  );\n\n  // Check for existing block status on mount (persists across refresh)\n  useEffect(() => {\n    if (!contestId) return;\n\n    const checkBlockStatus = async () => {\n      const result = await getParticipationStatus(contestId);\n      if (result.success && result.participation) {\n        const p = result.participation as any;\n\n        // ALWAYS sync the violation counts and flags\n        const newViolationState = {\n          total: p.totalViolations || 0,\n          isFlagged: p.isFlagged || false,\n          isBlocked: false,\n          tempBlockedUntil: null,\n          permanentlyBlocked: false,\n        };\n\n        if (p.permanentlyBlocked) {\n          newViolationState.isBlocked = true;\n          newViolationState.permanentlyBlocked = true;\n          setIsEditorLocked(true);\n          onBlocked?.();\n        } else if (p.tempBlockedUntil) {\n          const blockEnd = new Date(p.tempBlockedUntil);\n          if (blockEnd > new Date()) {\n            newViolationState.isBlocked = true;\n            newViolationState.tempBlockedUntil = p.tempBlockedUntil;\n            setIsEditorLocked(true);\n            const timeLeft = blockEnd.getTime() - Date.now();\n            setTempBlockTimeLeft(Math.max(0, Math.floor(timeLeft / 1000)));\n          }\n        } else if (p.isBlocked) {\n          newViolationState.isBlocked = true;\n          setIsEditorLocked(true);\n        }\n\n        setViolations(newViolationState);\n      }\n    };\n\n    checkBlockStatus();\n  }, [contestId, onBlocked]);\n\n  // Countdown timer for temp block\n  useEffect(() => {\n    if (tempBlockTimeLeft <= 0) return;\n\n    const interval = setInterval(() => {\n      setTempBlockTimeLeft((prev) => {\n        if (prev <= 1) {\n          // Timer expired - unblock\n          setIsEditorLocked(false);\n          setViolations((v) => ({\n            ...v,\n            isBlocked: false,\n            tempBlockedUntil: null,\n          }));\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [tempBlockTimeLeft > 0]); // Keep boolean dependency but ensure it works on reset\n\n  useEffect(() => {\n    if (!contestId || !sessionId) return;\n\n    // Setup delay to prevent false positives\n    const mountTimeout = setTimeout(() => {\n      isMounted.current = true;\n\n      // After refresh, check if we need to re-enter fullscreen\n      if (!document.fullscreenElement && !isRefreshing.current) {\n        setNeedsFullscreen(true);\n        needsFullscreenRef.current = true; // Immediate sync for event listeners\n      }\n    }, 3000);\n\n    // =============================================\n    // 1. MULTI-TAB DETECTION via BroadcastChannel\n    // =============================================\n    try {\n      broadcastChannel.current = new BroadcastChannel(`contest-${contestId}`);\n\n      // Announce presence\n      broadcastChannel.current.postMessage({ type: \"ping\", sessionId });\n\n      // Listen for other tabs\n      broadcastChannel.current.onmessage = (event) => {\n        if (event.data.type === \"ping\" && event.data.sessionId !== sessionId) {\n          handleViolation(\"MULTI_TAB\", \"Contest opened in multiple tabs\");\n          // Respond so the other tab knows\n          broadcastChannel.current?.postMessage({\n            type: \"conflict\",\n            sessionId,\n          });\n        }\n        if (\n          event.data.type === \"conflict\" &&\n          event.data.sessionId !== sessionId\n        ) {\n          handleViolation(\"MULTI_TAB\", \"Contest opened in multiple tabs\");\n        }\n      };\n    } catch (e) {\n      console.warn(\"BroadcastChannel not supported\");\n    }\n\n    // =============================================\n    // 2. FULLSCREEN ENFORCEMENT\n    // =============================================\n    const enterFullscreen = () => {\n      if (!document.fullscreenElement) {\n        document.documentElement.requestFullscreen().catch(() => {});\n      }\n    };\n\n    const handleFullscreenChange = () => {\n      if (!isMounted.current) return;\n      if (!document.fullscreenElement) {\n        handleViolation(\"FULLSCREEN_EXIT\", \"You exited fullscreen mode\");\n      }\n    };\n    document.addEventListener(\"fullscreenchange\", handleFullscreenChange);\n\n    // =============================================\n    // 3. COPY/PASTE/CUT PREVENTION\n    // =============================================\n    const preventClipboard = (e: ClipboardEvent) => {\n      if (!isMounted.current) return;\n      e.preventDefault();\n      handleViolation(\n        \"COPY_PASTE\",\n        `${e.type.charAt(0).toUpperCase() + e.type.slice(1)} is not allowed`\n      );\n      return false;\n    };\n\n    document.addEventListener(\"copy\", preventClipboard);\n    document.addEventListener(\"cut\", preventClipboard);\n    document.addEventListener(\"paste\", preventClipboard);\n\n    // =============================================\n    // 4. KEYBOARD SHORTCUT BLOCKING\n    // =============================================\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (!isMounted.current) return;\n\n      // Check against blocked shortcuts\n      const isBlocked = BLOCKED_SHORTCUTS.some((shortcut) => {\n        const keyMatch = e.key.toLowerCase() === shortcut.key.toLowerCase();\n        const ctrlMatch =\n          e.ctrlKey === shortcut.ctrl || e.metaKey === shortcut.ctrl;\n        const shiftMatch = e.shiftKey === shortcut.shift;\n        return keyMatch && ctrlMatch && shiftMatch;\n      });\n\n      if (isBlocked) {\n        e.preventDefault();\n        e.stopPropagation();\n        handleViolation(\n          \"KEYBOARD_SHORTCUT\",\n          `Blocked shortcut: ${e.ctrlKey ? \"Ctrl+\" : \"\"}${\n            e.shiftKey ? \"Shift+\" : \"\"\n          }${e.key}`\n        );\n        return false;\n      }\n\n      // Detect Refresh to suppress false positives\n      const isRefresh =\n        e.key === \"F5\" ||\n        (e.key.toLowerCase() === \"r\" && (e.ctrlKey || e.metaKey));\n\n      if (isRefresh) {\n        isRefreshing.current = true;\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown, true);\n\n    // =============================================\n    // 5. TAB SWITCH / FOCUS DETECTION\n    // =============================================\n    const handleVisibilityChange = () => {\n      if (!isMounted.current) return;\n      if (document.hidden) {\n        handleViolation(\"TAB_SWITCH\", \"You switched away from the contest tab\");\n      }\n    };\n\n    const handleWindowBlur = () => {\n      if (!isMounted.current) return;\n      handleViolation(\"TAB_SWITCH\", \"Window lost focus\");\n    };\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    window.addEventListener(\"blur\", handleWindowBlur);\n\n    // =============================================\n    // 5b. INTERACTION-BASED COMPLIANCE (Optimized)\n    // =============================================\n    // =============================================\n    // 5b. INTERACTION-BASED COMPLIANCE (Optimization: Throttled)\n    // =============================================\n    let lastCheck = 0;\n    const checkCompliance = () => {\n      const now = Date.now();\n      // Throttle: Max once per 2 seconds during active interaction\n      if (now - lastCheck < 2000) return;\n      lastCheck = now;\n\n      if (!isMounted.current) return;\n      // Skip if already processing/blocked OR if waiting for fullscreen (using Ref for live value) OR PAUSED\n      if (\n        paused ||\n        isProcessingViolation.current ||\n        isEditorLocked ||\n        showWarningPopup ||\n        needsFullscreenRef.current\n      )\n        return;\n\n      // 1. Check Fullscreen\n      if (!document.fullscreenElement && !isRefreshing.current) {\n        handleViolation(\"FULLSCREEN_EXIT\", \"You must stay in fullscreen mode\");\n        return;\n      }\n    };\n\n    // Event-driven checks are sufficient without polling overhead\n    document.addEventListener(\"mousedown\", checkCompliance);\n    document.addEventListener(\"keydown\", checkCompliance);\n    document.addEventListener(\"touchstart\", checkCompliance);\n\n    // No polling heartbeat needed - visibilitychange and fullscreenchange handle the critical events instantly\n\n    // =============================================\n    // 6. DEVTOOLS DETECTION (Event-Driven)\n    // =============================================\n    let resizeTimeout: NodeJS.Timeout;\n    const checkDevTools = () => {\n      if (!isMounted.current) return;\n      const threshold = 160;\n      const widthDiff = window.outerWidth - window.innerWidth;\n      const heightDiff = window.outerHeight - window.innerHeight;\n\n      if (widthDiff > threshold || heightDiff > threshold) {\n        handleViolation(\"DEVTOOLS_OPEN\", \"Developer tools detected\");\n      }\n    };\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(checkDevTools, 500); // Debounce resize check\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // =============================================\n    // 7. CONTEXT MENU DISABLE\n    // =============================================\n    const preventContextMenu = (e: MouseEvent) => {\n      e.preventDefault();\n      return false;\n    };\n    document.addEventListener(\"contextmenu\", preventContextMenu);\n\n    // =============================================\n    // 8. INTERNAL NAVIGATION TRACKING\n    // =============================================\n    // Track clicks on links to prevent false positives when navigating to problems\n    const handleLinkClick = (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      const link = target.closest(\"a\");\n      if (link) {\n        const href = link.getAttribute(\"href\");\n        // If it's an internal link (same origin or relative path)\n        if (\n          href &&\n          (href.startsWith(\"/\") || href.startsWith(window.location.origin))\n        ) {\n          isNavigating.current = true;\n          // Reset after a short delay in case navigation is cancelled\n          setTimeout(() => {\n            isNavigating.current = false;\n          }, 2000);\n        }\n      }\n    };\n    document.addEventListener(\"click\", handleLinkClick, true);\n\n    // =============================================\n    // 8. BEFOREUNLOAD WARNING\n    // =============================================\n    const handleBeforeUnload = (e: BeforeUnloadEvent) => {\n      isRefreshing.current = true; // Mark as refreshing/navigating\n      // DISABLE LEAVE CONFIRMATION\n      // e.preventDefault();\n      // e.returnValue = \"You are in contest mode. Are you sure you want to leave?\";\n      // return e.returnValue;\n    };\n    window.addEventListener(\"beforeunload\", handleBeforeUnload);\n\n    // =============================================\n    // 9. DRAG/DROP PREVENTION\n    // =============================================\n    const preventDragDrop = (e: DragEvent) => {\n      e.preventDefault();\n      return false;\n    };\n    document.addEventListener(\"dragover\", preventDragDrop);\n    document.addEventListener(\"drop\", preventDragDrop);\n\n    // Cleanup\n    return () => {\n      clearTimeout(mountTimeout);\n      clearTimeout(resizeTimeout);\n      broadcastChannel.current?.close();\n      document.removeEventListener(\"fullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"copy\", preventClipboard);\n      document.removeEventListener(\"cut\", preventClipboard);\n      document.removeEventListener(\"paste\", preventClipboard);\n      document.removeEventListener(\"keydown\", handleKeyDown, true);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"blur\", handleWindowBlur);\n      window.removeEventListener(\"resize\", handleResize);\n\n      document.removeEventListener(\"mousedown\", checkCompliance);\n      document.removeEventListener(\"keydown\", checkCompliance);\n      document.removeEventListener(\"touchstart\", checkCompliance);\n\n      document.removeEventListener(\"contextmenu\", preventContextMenu);\n      document.removeEventListener(\"click\", handleLinkClick, true);\n      window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n      document.removeEventListener(\"dragover\", preventDragDrop);\n      document.removeEventListener(\"drop\", preventDragDrop);\n    };\n  }, [contestId, sessionId, handleViolation]);\n\n  const handleDismissWarning = () => {\n    // Only allow dismissing if we successfully enter fullscreen\n    const enterFullscreen = async () => {\n      try {\n        if (!document.fullscreenElement) {\n          await document.documentElement.requestFullscreen();\n        }\n        // Only if successful, close popup\n        setShowWarningPopup(false);\n      } catch (err) {\n        // If user denies fullscreen or it fails, keep popup open\n        // Maybe show a toast or shake animation in future\n      }\n    };\n    enterFullscreen();\n  };\n\n  const handleReEnterFullscreen = () => {\n    document.documentElement\n      .requestFullscreen()\n      .then(() => setNeedsFullscreen(false))\n      .catch(() => {\n        // If fails, keeps the popup open\n      });\n  };\n\n  const remainingWarnings = MAX_WARNINGS - violations.total;\n\n  return (\n    <>\n      {/* Unified Warning/Block Card - Redesigned */}\n      {(isEditorLocked || showWarningPopup) && (\n        <div className=\"fixed inset-0 z-9999 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-in fade-in duration-200\">\n          <div className=\"bg-white dark:bg-[#141414] rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden border border-orange-100 dark:border-orange-500/20 transform transition-all scale-100\">\n            {/* Status Bar Top */}\n            <div\n              className={`h-2 w-full ${\n                violations.permanentlyBlocked ? \"bg-red-500\" : \"bg-orange-500\"\n              }`}\n            />\n\n            <div className=\"p-6 md:p-8\">\n              <div className=\"flex flex-col md:flex-row gap-6 items-start md:items-center\">\n                {/* Large Icon Box */}\n                <div\n                  className={`w-16 h-16 rounded-2xl flex items-center justify-center shrink-0 shadow-sm ${\n                    violations.permanentlyBlocked\n                      ? \"bg-red-50 dark:bg-red-500/10 text-red-500\"\n                      : \"bg-orange-50 dark:bg-orange-500/10 text-orange-500\"\n                  }`}\n                >\n                  {violations.permanentlyBlocked ? (\n                    <Ban className=\"w-8 h-8\" />\n                  ) : tempBlockTimeLeft > 0 ? (\n                    <Clock className=\"w-8 h-8 animate-pulse\" />\n                  ) : isEditorLocked ? (\n                    <Lock className=\"w-8 h-8\" />\n                  ) : (\n                    <AlertTriangle className=\"w-8 h-8\" />\n                  )}\n                </div>\n\n                <div className=\"flex-1 space-y-1\">\n                  <h2 className=\"text-xl font-bold text-gray-900 dark:text-white leading-tight\">\n                    {violations.permanentlyBlocked\n                      ? \"Contest Session Terminated\"\n                      : tempBlockTimeLeft > 0\n                      ? \"Temporary Suspension\"\n                      : \"Violation Detected\"}\n                  </h2>\n                  <p className=\"text-gray-500 dark:text-gray-400 font-medium text-sm\">\n                    {violations.permanentlyBlocked\n                      ? \"Multiple violations detected. Your session has been permanently blocked.\"\n                      : tempBlockTimeLeft > 0\n                      ? \"Please wait for the timer to expire before continuing.\"\n                      : currentViolationType ||\n                        \"This action is prohibited during the contest.\"}\n                  </p>\n                </div>\n              </div>\n\n              {/* Timer Section */}\n              {tempBlockTimeLeft > 0 && (\n                <div className=\"mt-8 p-6 bg-orange-50 dark:bg-orange-500/10 rounded-xl border border-orange-100 dark:border-orange-500/20 flex flex-col items-center justify-center\">\n                  <span className=\"text-xs font-bold text-orange-400 uppercase tracking-widest mb-2\">\n                    Access Resumes In\n                  </span>\n                  <div className=\"text-5xl font-black text-orange-500 font-mono tracking-tighter tabular-nums\">\n                    {Math.floor(tempBlockTimeLeft / 60)}:\n                    {String(tempBlockTimeLeft % 60).padStart(2, \"0\")}\n                  </div>\n                </div>\n              )}\n\n              {/* Progress Bar (Only if not perma-blocked and no timer active) */}\n              {!violations.permanentlyBlocked && tempBlockTimeLeft <= 0 && (\n                <div className=\"mt-8 space-y-3\">\n                  <div className=\"flex justify-between items-end\">\n                    <span className=\"text-xs font-semibold text-gray-400 uppercase tracking-wider\">\n                      Warning Level\n                    </span>\n                    <span className=\"text-sm font-bold text-gray-900 dark:text-white\">\n                      {violations.total}{\" \"}\n                      <span className=\"text-gray-400 font-normal\">\n                        / {MAX_WARNINGS}\n                      </span>\n                    </span>\n                  </div>\n                  <div className=\"h-3 bg-gray-100 dark:bg-[#1a1a1a] rounded-full overflow-hidden\">\n                    <div\n                      className={`h-full transition-all duration-500 ease-out ${\n                        violations.total >= 4 ? \"bg-red-500\" : \"bg-orange-500\"\n                      }`}\n                      style={{\n                        width: `${Math.min(\n                          (violations.total / MAX_WARNINGS) * 100,\n                          100\n                        )}%`,\n                      }}\n                    />\n                  </div>\n                  <div className=\"flex items-center justify-between text-xs\">\n                    <span className=\"text-gray-400\">Low Risk</span>\n                    {violations.total >= 4 ? (\n                      <span className=\"text-red-500 font-medium\">\n                        Critical Risk\n                      </span>\n                    ) : (\n                      <span className=\"text-orange-500 font-medium\">\n                        Caution\n                      </span>\n                    )}\n                  </div>\n                </div>\n              )}\n\n              {/* Actions */}\n              <div className=\"mt-8\">\n                {!violations.permanentlyBlocked && tempBlockTimeLeft <= 0 ? (\n                  <button\n                    onClick={handleDismissWarning}\n                    className=\"w-full py-4 bg-gray-900 dark:bg-white text-white dark:text-black rounded-xl font-bold hover:bg-gray-800 dark:hover:bg-gray-200 transition-all transform active:scale-[0.98] shadow-lg shadow-gray-200 dark:shadow-none\"\n                  >\n                    Acknowledge & Continue\n                  </button>\n                ) : tempBlockTimeLeft > 0 ? (\n                  <button\n                    disabled\n                    className=\"w-full py-4 bg-gray-100 dark:bg-[#1a1a1a] text-gray-400 dark:text-gray-600 rounded-xl font-bold cursor-not-allowed\"\n                  >\n                    Suspended\n                  </button>\n                ) : (\n                  <button className=\"w-full py-4 bg-red-50 dark:bg-red-500/10 text-red-600 dark:text-red-500 rounded-xl font-bold border border-red-100 dark:border-red-500/20 cursor-not-allowed\">\n                    Contact Administrator\n                  </button>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Fullscreen Required Prompt (Post-Refresh) */}\n      {needsFullscreen && !isEditorLocked && !showWarningPopup && (\n        <div className=\"fixed inset-0 z-10000 flex items-center justify-center bg-black/60 backdrop-blur-md\">\n          <div className=\"bg-white rounded-2xl shadow-2xl max-w-md w-full mx-4 overflow-hidden border-2 border-orange-500 animate-in fade-in zoom-in duration-300\">\n            <div className=\"bg-orange-600 px-6 py-4 flex items-center gap-3\">\n              <Monitor className=\"w-6 h-6 text-white\" />\n              <h2 className=\"text-lg font-bold text-white uppercase tracking-wider\">\n                Fullscreen Required\n              </h2>\n            </div>\n\n            <div className=\"p-6 text-center\">\n              <div className=\"w-20 h-20 bg-orange-50 dark:bg-orange-500/10 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <ShieldX className=\"w-10 h-10 text-orange-500\" />\n              </div>\n              <h3 className=\"text-xl font-bold text-gray-900 mb-2\">\n                Re-activate Proctoring\n              </h3>\n              <p className=\"text-gray-600 mb-8 text-sm\">\n                To continue your contest session, you must re-enter fullscreen\n                mode. This is required for proctoring accuracy.\n              </p>\n\n              <button\n                onClick={handleReEnterFullscreen}\n                className=\"w-full py-4 bg-orange-600 text-white rounded-xl font-black uppercase tracking-widest hover:bg-orange-700 transition-all shadow-lg shadow-orange-200 flex items-center justify-center gap-3 group\"\n              >\n                <Monitor className=\"w-5 h-5 group-hover:scale-110 transition-transform\" />\n                Go Full Screen\n              </button>\n\n              <p className=\"text-[10px] text-gray-400 mt-4 font-medium uppercase tracking-tighter\">\n                Do not attempt to stay in windowed mode\n              </p>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Proctoring Indicator - Clean white style */}\n      <div className=\"fixed top-4 right-4 z-100 flex items-center gap-2 px-3 py-2 bg-white dark:bg-[#141414] border border-gray-200 dark:border-[#262626] rounded-lg shadow-sm\">\n        <div className=\"w-2 h-2 bg-green-500 rounded-full animate-pulse\" />\n        <span className=\"text-sm text-gray-700 dark:text-gray-300 font-medium\">\n          Proctored\n        </span>\n        {violations.total > 0 && (\n          <span className=\"px-2 py-0.5 bg-orange-100 dark:bg-orange-500/10 text-orange-700 dark:text-orange-400 rounded text-xs font-semibold\">\n            {violations.total}\n          </span>\n        )}\n      </div>\n    </>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1606, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestNavigationGuard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport { useRouter, usePathname } from \"next/navigation\";\nimport { logContestViolation } from \"@/actions/contest\";\n\ninterface ContestNavigationGuardProps {\n    contestId: string;\n    allowedPaths: string[];  // Paths that are allowed during contest\n}\n\n/**\n * Navigation Guard for Contest Mode\n * - Blocks browser back/forward\n * - Intercepts route changes\n * - Logs navigation attempts\n */\nexport default function ContestNavigationGuard({\n    contestId,\n    allowedPaths\n}: ContestNavigationGuardProps) {\n    const router = useRouter();\n    const pathname = usePathname();\n    const initialPath = useRef(pathname);\n\n    useEffect(() => {\n        if (!contestId) return;\n\n        // =============================================\n        // 1. BLOCK BROWSER BACK/FORWARD\n        // =============================================\n        // Push current state to prevent back navigation\n        const pushState = () => {\n            window.history.pushState(null, \"\", window.location.href);\n        };\n\n        pushState();\n\n        const handlePopState = (e: PopStateEvent) => {\n            e.preventDefault();\n            pushState();\n\n            // Log navigation attempt\n            logContestViolation(\n                contestId,\n                \"NAVIGATION_ATTEMPT\",\n                \"Attempted to use browser back/forward\"\n            );\n        };\n\n        window.addEventListener(\"popstate\", handlePopState);\n\n        // =============================================\n        // 2. INTERCEPT LINK CLICKS\n        // =============================================\n        const handleLinkClick = (e: MouseEvent) => {\n            const target = e.target as HTMLElement;\n            const anchor = target.closest(\"a\");\n\n            if (anchor) {\n                const href = anchor.getAttribute(\"href\");\n\n                // Check if navigation is to an allowed path\n                // Ignore hash links, empty links, or javascript:void, or disabled links\n                if (href &&\n                    href !== \"#\" &&\n                    href.trim() !== \"\" &&\n                    !href.startsWith(\"javascript:\") &&\n                    !allowedPaths.some(path => href.startsWith(path))) {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    logContestViolation(\n                        contestId,\n                        \"NAVIGATION_ATTEMPT\",\n                        `Attempted to navigate to: ${href}`\n                    );\n\n                    return false;\n                }\n            }\n        };\n\n        document.addEventListener(\"click\", handleLinkClick, true);\n\n        // =============================================\n        // 3. MONITOR PATH CHANGES\n        // =============================================\n        // If path changes unexpectedly, redirect back\n        if (pathname !== initialPath.current) {\n            const isAllowed = allowedPaths.some(path => pathname?.startsWith(path));\n\n            if (!isAllowed) {\n                logContestViolation(\n                    contestId,\n                    \"NAVIGATION_ATTEMPT\",\n                    `Unexpected navigation to: ${pathname}`\n                );\n\n                // Redirect back to contest\n                router.replace(initialPath.current || \"/\");\n            }\n        }\n\n        return () => {\n            window.removeEventListener(\"popstate\", handlePopState);\n            document.removeEventListener(\"click\", handleLinkClick, true);\n        };\n    }, [contestId, pathname, allowedPaths, router]);\n\n    // This component doesn't render anything\n    return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;;AAJA;;;;AAiBe,SAAS,uBAAuB,EAC3C,SAAS,EACT,YAAY,EACc;;IAC1B,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,WAAW,IAAA,oJAAW;IAC5B,MAAM,cAAc,IAAA,uKAAM,EAAC;IAE3B,IAAA,0KAAS;4CAAC;YACN,IAAI,CAAC,WAAW;YAEhB,gDAAgD;YAChD,gCAAgC;YAChC,gDAAgD;YAChD,gDAAgD;YAChD,MAAM;8DAAY;oBACd,OAAO,OAAO,CAAC,SAAS,CAAC,MAAM,IAAI,OAAO,QAAQ,CAAC,IAAI;gBAC3D;;YAEA;YAEA,MAAM;mEAAiB,CAAC;oBACpB,EAAE,cAAc;oBAChB;oBAEA,yBAAyB;oBACzB,IAAA,yKAAmB,EACf,WACA,sBACA;gBAER;;YAEA,OAAO,gBAAgB,CAAC,YAAY;YAEpC,gDAAgD;YAChD,2BAA2B;YAC3B,gDAAgD;YAChD,MAAM;oEAAkB,CAAC;oBACrB,MAAM,SAAS,EAAE,MAAM;oBACvB,MAAM,SAAS,OAAO,OAAO,CAAC;oBAE9B,IAAI,QAAQ;wBACR,MAAM,OAAO,OAAO,YAAY,CAAC;wBAEjC,4CAA4C;wBAC5C,wEAAwE;wBACxE,IAAI,QACA,SAAS,OACT,KAAK,IAAI,OAAO,MAChB,CAAC,KAAK,UAAU,CAAC,kBACjB,CAAC,aAAa,IAAI;gFAAC,CAAA,OAAQ,KAAK,UAAU,CAAC;gFAAQ;4BACnD,EAAE,cAAc;4BAChB,EAAE,eAAe;4BAEjB,IAAA,yKAAmB,EACf,WACA,sBACA,CAAC,0BAA0B,EAAE,MAAM;4BAGvC,OAAO;wBACX;oBACJ;gBACJ;;YAEA,SAAS,gBAAgB,CAAC,SAAS,iBAAiB;YAEpD,gDAAgD;YAChD,0BAA0B;YAC1B,gDAAgD;YAChD,8CAA8C;YAC9C,IAAI,aAAa,YAAY,OAAO,EAAE;gBAClC,MAAM,YAAY,aAAa,IAAI;kEAAC,CAAA,OAAQ,UAAU,WAAW;;gBAEjE,IAAI,CAAC,WAAW;oBACZ,IAAA,yKAAmB,EACf,WACA,sBACA,CAAC,0BAA0B,EAAE,UAAU;oBAG3C,2BAA2B;oBAC3B,OAAO,OAAO,CAAC,YAAY,OAAO,IAAI;gBAC1C;YACJ;YAEA;oDAAO;oBACH,OAAO,mBAAmB,CAAC,YAAY;oBACvC,SAAS,mBAAmB,CAAC,SAAS,iBAAiB;gBAC3D;;QACJ;2CAAG;QAAC;QAAW;QAAU;QAAc;KAAO;IAE9C,yCAAyC;IACzC,OAAO;AACX;GA/FwB;;QAIL,kJAAS;QACP,oJAAW;;;KALR"}},
    {"offset": {"line": 1714, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await prisma.contest.findMany({\n                where: {\n                    visibility: \"PUBLIC\",\n                    hidden: false,\n                },\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                _count: {\n                    select: { problems: true },\n                },\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                            },\n                        },\n                    },\n                    orderBy: { order: \"asc\" },\n                },\n            },\n        });\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA6dsB,sBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 1729, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/contest/ContestDetails.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Clock, ChevronRight, Lock, AlertCircle, Medal, ChevronLeft, X, CheckCircle2, ShieldAlert } from \"lucide-react\";\nimport { toast } from \"sonner\";\nimport Link from \"next/link\";\nimport { useRouter } from \"next/navigation\";\nimport ContestEntryModal from \"./ContestEntryModal\";\nimport ContestProtection from './ContestProtection';\nimport ContestNavigationGuard from './ContestNavigationGuard';\n\nimport { finishContestAction } from \"@/actions/contest\";\n\ninterface ContestDetailsProps {\n    contest: any;\n    user: any;\n}\n\nconst PROBLEMS_PER_PAGE = 20;\n\nexport default function ContestDetails({ contest, user }: ContestDetailsProps) {\n    const router = useRouter();\n    const [timeLeft, setTimeLeft] = useState<string>(\"\");\n    const [currentPage, setCurrentPage] = useState(1);\n    const [showRulesPopup, setShowRulesPopup] = useState(false);\n    const [hasAcceptedRules, setHasAcceptedRules] = useState(contest.hasAcceptedRules || false);\n    const [isSubmittingContest, setIsSubmittingContest] = useState(false);\n    const isFinished = contest.isFinished || false;\n\n    // Protection State\n    const [sessionId, setSessionId] = useState<string | null>(contest.sessionId || null);\n\n    // DEBUG: Log protection conditions\n    useEffect(() => {\n        console.log('[ContestProtection Debug]', {\n            hasAcceptedRules,\n            sessionId,\n            isFinished,\n            willRenderProtection: hasAcceptedRules && sessionId && !isFinished\n        });\n    }, [hasAcceptedRules, sessionId, isFinished, contest.canManage]);\n\n    const now = new Date();\n    const startTime = new Date(contest.startTime);\n    const endTime = new Date(contest.endTime);\n    const hasStarted = now >= startTime;\n    const hasEnded = now > endTime;\n\n    const [showEndModal, setShowEndModal] = useState(false);\n    const [endConfirmText, setEndConfirmText] = useState(\"\");\n\n    const handleContestFinish = () => {\n        setShowEndModal(true);\n    };\n\n    const confirmEndContest = async () => {\n        if (endConfirmText.toLowerCase() !== \"end\") {\n            toast.error(\"Please type 'end' to confirm\");\n            return;\n        }\n\n        setIsSubmittingContest(true);\n        try {\n            const res = await finishContestAction(contest.id);\n            if (res.success) {\n                toast.success(\"Contest submitted successfully!\");\n                router.push(\"/\");\n            } else {\n                toast.error(\"Failed to submit contest\");\n                setIsSubmittingContest(false);\n            }\n        } catch (error) {\n            console.error(error);\n            toast.error(\"Something went wrong\");\n            setIsSubmittingContest(false);\n        }\n        setShowEndModal(false);\n    };\n\n    useEffect(() => {\n        if (isFinished) return;\n        const accepted = localStorage.getItem(`contest-rules-${contest.id}`);\n        // If we have local storage record AND the server says we accepted rules (or we rely on server only)\n        // But let's trust server state 'hasAcceptedRules' primarily if available\n        if (hasAcceptedRules) {\n             if (hasStarted && !hasEnded) {\n                // Already started logic\n             }\n        } else if (hasStarted && !hasEnded) {\n            setShowRulesPopup(true);\n        }\n    }, [contest.id, hasStarted, hasEnded, hasAcceptedRules, isFinished]);\n\n    useEffect(() => {\n        const timer = setInterval(() => {\n            const now = new Date();\n            const target = hasStarted ? endTime : startTime;\n            const diff = target.getTime() - now.getTime();\n\n            if (diff <= 0) {\n                setTimeLeft(hasStarted ? \"Contest Ended\" : \"Starting Now\");\n                clearInterval(timer);\n                return;\n            }\n\n            const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n            const seconds = Math.floor((diff % (1000 * 60)) / 1000);\n\n            setTimeLeft(`${days > 0 ? `${days}d ` : \"\"}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);\n        }, 1000);\n\n        return () => clearInterval(timer);\n    }, [hasStarted, startTime, endTime]);\n\n    const handleContestStart = (newSessionId: string) => {\n        localStorage.setItem(`contest-rules-${contest.id}`, \"true\");\n        setHasAcceptedRules(true);\n        setShowRulesPopup(false);\n        setSessionId(newSessionId);\n\n        // Reload page to refresh questions (if shuffled) or unlock content\n        window.location.reload();\n    };\n\n    const totalPages = Math.ceil(contest.problems.length / PROBLEMS_PER_PAGE);\n    const startIndex = (currentPage - 1) * PROBLEMS_PER_PAGE;\n    const endIndex = startIndex + PROBLEMS_PER_PAGE;\n    const currentProblems = contest.problems.slice(startIndex, endIndex);\n\n    const getStatusBadge = () => {\n        if (isFinished) {\n            return <span className=\"px-2.5 py-0.5 rounded-full text-xs font-medium bg-emerald-100 dark:bg-emerald-500/20 text-emerald-700 dark:text-emerald-400\">Completed</span>;\n        }\n        if (hasEnded) {\n            return <span className=\"px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 dark:bg-gray-500/20 text-gray-700 dark:text-gray-400\">Ended</span>;\n        }\n        if (hasStarted) {\n            return <span className=\"px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 dark:bg-orange-500/20 text-orange-700 dark:text-orange-400\">Live</span>;\n        }\n        return <span className=\"px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 dark:bg-blue-500/20 text-blue-700 dark:text-blue-400\">Upcoming</span>;\n    };\n\n    const getDifficultyColor = (difficulty: string) => {\n        switch (difficulty) {\n            case \"EASY\": return \"bg-emerald-100 dark:bg-emerald-500/20 text-emerald-700 dark:text-emerald-400\";\n            case \"MEDIUM\": return \"bg-orange-100 dark:bg-orange-500/20 text-orange-700 dark:text-orange-400\";\n            case \"HARD\": return \"bg-red-100 dark:bg-red-500/20 text-red-700 dark:text-red-400\";\n            default: return \"bg-gray-100 dark:bg-gray-500/20 text-gray-700 dark:text-gray-400\";\n        }\n    };\n\n    return (\n        <>\n            <ContestEntryModal\n                contestId={contest.id}\n                contestTitle={contest.title}\n                requiresPassword={contest.requiresPassword}\n                isOpen={showRulesPopup}\n                onClose={() => setShowRulesPopup(false)}\n                onStart={handleContestStart}\n            />\n\n            {/* Contest Protection on Dashboard - Active for all participants during live contest */}\n            {hasAcceptedRules && sessionId && !isFinished && (\n                <>\n                    <ContestProtection\n                        contestId={contest.id}\n                        sessionId={sessionId}\n                        paused={isSubmittingContest || showEndModal}\n                    />\n                    <ContestNavigationGuard\n                        contestId={contest.id}\n                        allowedPaths={[\n                            `/problems/`,\n                            `/contest/${contest.id}`,\n                        ]}\n                    />\n                </>\n            )}\n\n            <div className=\"min-h-screen bg-white dark:bg-[#0a0a0a] py-8\">\n                <div className=\"w-full max-w-7xl mx-auto px-4 md:px-6\">\n                    {/* Header */}\n                    <div className=\"mb-8\">\n                        <div className=\"flex items-center gap-2 mb-3\">\n                            <span className=\"px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 dark:bg-[#262626] text-gray-700 dark:text-gray-300\">\n                                {contest.visibility}\n                            </span>\n                            {getStatusBadge()}\n                        </div>\n\n                        <h1 className=\"text-3xl font-bold text-gray-900 dark:text-gray-100 mb-2\">\n                            {contest.title}\n                        </h1>\n\n                        <p className=\"text-gray-600 dark:text-gray-400\">\n                            {contest.description || \"Test your skills in this competitive programming arena.\"}\n                        </p>\n                    </div>\n\n                    {isFinished && (\n                        <div className=\"mb-8 p-6 bg-emerald-50 dark:bg-emerald-500/10 border border-emerald-100 dark:border-emerald-500/20 rounded-2xl flex items-center gap-4\">\n                            <div className=\"w-12 h-12 bg-emerald-100 dark:bg-emerald-500/20 rounded-xl flex items-center justify-center shrink-0\">\n                                <CheckCircle2 className=\"w-6 h-6 text-emerald-600 dark:text-emerald-400\" />\n                            </div>\n                            <div>\n                                <h3 className=\"text-lg font-bold text-emerald-900 dark:text-emerald-400\">Contest Session Completed</h3>\n                                <p className=\"text-emerald-700 dark:text-emerald-500 text-sm\">\n                                    You have successfully ended your session. Your submissions have been recorded and you can view the final standings once the contest ends.\n                                </p>\n                            </div>\n                        </div>\n                    )}\n\n                    {/* Stats Bar */}\n                    <div className=\"flex flex-wrap items-center gap-6 mb-6 pb-6 border-b border-gray-200 dark:border-[#262626] text-sm\">\n                        <div>\n                            <span className=\"text-gray-500 dark:text-gray-400\">Start:</span>\n                            <span className=\"ml-2 text-gray-900 dark:text-gray-100 font-medium\">{startTime.toLocaleString()}</span>\n                        </div>\n                        <div>\n                            <span className=\"text-gray-500 dark:text-gray-400\">End:</span>\n                            <span className=\"ml-2 text-gray-900 dark:text-gray-100 font-medium\">{endTime.toLocaleString()}</span>\n                        </div>\n                        <div>\n                            <span className=\"text-gray-500 dark:text-gray-400\">Problems:</span>\n                            <span className=\"ml-2 text-gray-900 dark:text-gray-100 font-medium\">{contest._count.problems}</span>\n                        </div>\n                        <div>\n                            <span className=\"text-gray-500 dark:text-gray-400\">Time:</span>\n                            <span className=\"ml-2 text-gray-900 dark:text-gray-100 font-medium font-mono\">{timeLeft}</span>\n                        </div>\n\n\n                        <div className=\"ml-auto flex gap-2\">\n                            {/* Submit Button for Active Participants */}\n                            {hasAcceptedRules && hasStarted && !hasEnded && !isFinished && (\n                                <button\n                                    onClick={handleContestFinish}\n                                    className=\"px-4 py-2 bg-red-600 text-white rounded text-sm font-medium hover:bg-red-700 transition-colors flex items-center gap-2 shadow-lg shadow-red-500/20\"\n                                >\n                                    <CheckCircle2 className=\"w-4 h-4\" />\n                                    End Contest\n                                </button>\n                            )}\n\n                            {hasEnded && (\n                                <Link\n                                    href={`/contest/${contest.id}/standings`}\n                                    className=\"px-4 py-2 bg-orange-600 text-white rounded text-sm font-medium hover:bg-orange-700 transition-colors shadow-lg shadow-orange-500/20\"\n                                >\n                                    Leaderboard\n                                </Link>\n                            )}\n                        </div>\n                    </div>\n\n                    {!hasStarted && !contest.canManage ? (\n                        <div className=\"text-center py-20 border border-gray-200 dark:border-[#262626] rounded-lg bg-white dark:bg-[#141414]\">\n                            <Lock className=\"w-12 h-12 text-gray-300 dark:text-gray-600 mx-auto mb-4\" />\n                            <h3 className=\"text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2\">Problems Locked</h3>\n                            <p className=\"text-gray-500 dark:text-gray-400\">\n                                Problems will be revealed when the contest starts.\n                            </p>\n                        </div>\n                    ) : (\n                        <>\n                            {/* Table Header */}\n                            <div className=\"grid grid-cols-12 gap-4 px-6 py-4 border-b border-gray-100 dark:border-[#262626] text-[11px] font-bold text-gray-400 uppercase tracking-widest\">\n                                <div className=\"col-span-1\">#</div>\n                                <div className=\"col-span-6 md:col-span-7\">Title</div>\n                                <div className=\"col-span-3 md:col-span-2\">Difficulty</div>\n                                <div className=\"col-span-2 md:col-span-2\">Status</div>\n                            </div>\n\n                            {/* Problem List */}\n                            <div className=\"mt-2\">\n                                {currentProblems.map((cp: any, index: number) => {\n                                    const globalIndex = startIndex + index;\n                                    const canAccess = (hasAcceptedRules || contest.canManage || !hasStarted || hasEnded) && (!isFinished || contest.canManage);\n                                    const isSolved = (cp as any).isSolved; // Access the property we added\n\n                                    // If problem is solved, block access (even for managers during testing/consistency)\n                                    const isBlockedByCompletion = isSolved;\n\n                                    return (\n                                        <Link\n                                            key={cp.problem.id}\n                                            href={(canAccess && (hasStarted || contest.canManage) && !isBlockedByCompletion) ? `/problems/${cp.problem.slug}?contestId=${contest.id}` : \"#\"}\n                                            onClick={(e) => {\n                                                if (isFinished && !contest.canManage) {\n                                                    e.preventDefault();\n                                                    toast.error(\"Contest session ended\", {\n                                                        description: \"You have already completed this contest.\"\n                                                    });\n                                                    return;\n                                                }\n                                                // Prevent re-attempting solved problems\n                                                if (isBlockedByCompletion) {\n                                                    e.preventDefault();\n                                                    toast.success(\"Problem Solved!\", {\n                                                        description: \"You have already completed this challenge. Great job!\"\n                                                    });\n                                                    return;\n                                                }\n                                                if (!canAccess && hasStarted && !hasEnded) {\n                                                    e.preventDefault();\n                                                    setShowRulesPopup(true);\n                                                }\n                                            }}\n                                            className={`grid grid-cols-12 gap-4 px-6 py-4 rounded-xl items-center transition-all duration-200 ${\n                                                canAccess && (hasStarted || contest.canManage) && !isBlockedByCompletion\n                                                ? \"hover:bg-gray-50/50 dark:hover:bg-[#1a1a1a] cursor-pointer\"\n                                                : isSolved ? \"opacity-75 bg-emerald-50/30 dark:bg-emerald-500/5 cursor-not-allowed\" : \"opacity-50 cursor-not-allowed\"\n                                            }`}\n                                        >\n                                            <div className=\"col-span-1 text-sm text-gray-500 dark:text-gray-400 font-medium\">\n                                                {globalIndex + 1}\n                                            </div>\n                                            <div className=\"col-span-6 md:col-span-7 font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2\">\n                                                <span className={`truncate ${canAccess && !isBlockedByCompletion ? \"hover:text-orange-600 transition-colors\" : \"\"}`}>\n                                                    {cp.problem.title}\n                                                </span>\n                                                {isSolved && (\n                                                     <span className=\"px-2 py-0.5 rounded-full bg-emerald-100 dark:bg-emerald-500/20 text-emerald-700 dark:text-emerald-400 text-[10px] font-bold uppercase tracking-wider flex items-center gap-1\">\n                                                        <CheckCircle2 className=\"w-3 h-3\" />\n                                                        Solved\n                                                     </span>\n                                                )}\n                                            </div>\n                                            <div className=\"col-span-3 md:col-span-2\">\n                                                <span className={`px-2.5 py-0.5 rounded-full text-xs font-medium ${getDifficultyColor(cp.problem.difficulty)}`}>\n                                                    {cp.problem.difficulty === \"MEDIUM\" ? \"Med.\" : cp.problem.difficulty.charAt(0) + cp.problem.difficulty.slice(1).toLowerCase()}\n                                                </span>\n                                            </div>\n                                            <div className=\"col-span-2 md:col-span-2 text-sm text-gray-500 dark:text-gray-400\">\n                                                {isSolved ? (\n                                                     <CheckCircle2 className=\"w-5 h-5 text-emerald-500\" />\n                                                ) : canAccess && (hasStarted || contest.canManage) ? (\n                                                    <ChevronRight className=\"w-5 h-5 text-gray-400\" />\n                                                ) : (\n                                                    <Lock className=\"w-4 h-4 text-gray-400\" />\n                                                )}\n                                            </div>\n                                        </Link>\n                                    );\n                                })}\n                            </div>\n\n                            {/* Pagination */}\n                            {totalPages > 1 && (\n                                <div className=\"flex items-center justify-center gap-2 mt-12 mb-8\">\n                                    <button\n                                        onClick={() => setCurrentPage(p => Math.max(1, p - 1))}\n                                        disabled={currentPage === 1}\n                                        className={`p-2 border border-gray-200 dark:border-[#262626] rounded transition-colors ${currentPage === 1\n                                            ? \"text-gray-300 dark:text-gray-600 cursor-not-allowed\"\n                                            : \"text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a]\"\n                                            }`}\n                                    >\n                                        <ChevronLeft className=\"w-4 h-4\" />\n                                    </button>\n\n                                    {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (\n                                        <button\n                                            key={page}\n                                            onClick={() => setCurrentPage(page)}\n                                            className={`w-9 h-9 rounded text-sm font-medium transition-colors ${currentPage === page\n                                                ? \"bg-orange-600 text-white\"\n                                                : \"border border-gray-200 dark:border-[#262626] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a]\"\n                                                }`}\n                                        >\n                                            {page}\n                                        </button>\n                                    ))}\n\n                                    <button\n                                        onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}\n                                        disabled={currentPage === totalPages}\n                                        className={`p-2 border border-gray-200 dark:border-[#262626] rounded transition-colors ${currentPage === totalPages\n                                            ? \"text-gray-300 dark:text-gray-600 cursor-not-allowed\"\n                                            : \"text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a]\"\n                                            }`}\n                                    >\n                                        <ChevronRight className=\"w-4 h-4\" />\n                                    </button>\n                                </div>\n                            )}\n                        </>\n                    )}\n                </div>\n            </div>\n\n            {/* End Contest Confirmation Modal */}\n            {showEndModal && (\n                <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\n                    <div className=\"bg-white dark:bg-[#141414] rounded-xl shadow-2xl w-full max-w-md p-6 border border-gray-100 dark:border-[#262626] transform scale-100 transition-all\">\n                        <div className=\"flex items-center gap-3 mb-4 text-red-600 dark:text-red-400\">\n                            <ShieldAlert className=\"w-8 h-8\" />\n                            <h3 className=\"text-xl font-bold text-gray-900 dark:text-gray-100\">End Contest Session?</h3>\n                        </div>\n\n                        <p className=\"text-gray-600 dark:text-gray-400 mb-6\">\n                            Are you sure you want to end your session? You will <strong>NOT</strong> be able to re-enter or solve more problems after this.\n                            <br /><br />\n                            Type <span className=\"font-mono font-bold text-red-600 dark:text-red-400\">end</span> below to confirm.\n                        </p>\n\n                        <input\n                            type=\"text\"\n                            placeholder=\"Type 'end' to confirm\"\n                            value={endConfirmText}\n                            onChange={(e) => setEndConfirmText(e.target.value)}\n                            className=\"w-full px-4 py-3 border border-gray-200 dark:border-[#262626] rounded-lg mb-6 bg-gray-50 dark:bg-[#1a1a1a] focus:bg-white dark:focus:bg-[#0a0a0a] focus:ring-2 focus:ring-red-500/20 focus:border-red-500 outline-none transition-all font-mono text-center uppercase tracking-widest placeholder:normal-case placeholder:tracking-normal text-gray-900 dark:text-gray-100\"\n                            autoFocus\n                        />\n\n                        <div className=\"flex gap-3\">\n                            <button\n                                onClick={() => { setShowEndModal(false); setEndConfirmText(\"\"); }}\n                                className=\"flex-1 px-4 py-3 border border-gray-200 dark:border-[#262626] rounded-lg font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#1a1a1a] transition-colors\"\n                            >\n                                Cancel\n                            </button>\n                            <button\n                                onClick={confirmEndContest}\n                                disabled={endConfirmText.toLowerCase() !== \"end\" || isSubmittingContest}\n                                className=\"flex-1 px-4 py-3 bg-red-600 text-white rounded-lg font-bold hover:bg-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-red-500/20\"\n                            >\n                                {isSubmittingContest ? \"Ending...\" : \"End Contest\"}\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            )}\n        </>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2612, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/components/BackButton.tsx"],"sourcesContent":["\"use client\";\n\nimport { useRouter } from \"next/navigation\";\nimport { ArrowLeft } from \"lucide-react\";\n\ninterface BackButtonProps {\n  href?: string;\n  label?: string;\n  children?: React.ReactNode;\n  className?: string;\n}\n\nexport default function BackButton({\n  href,\n  label = \"Back\",\n  children,\n  className = \"\"\n}: BackButtonProps) {\n  const router = useRouter();\n\n  const handleClick = () => {\n    if (href) {\n      router.push(href);\n    } else {\n      router.back();\n    }\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      className={`inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors rounded-lg hover:bg-gray-100 dark:hover:bg-[#1a1a1a] ${className}`}\n    >\n      <ArrowLeft className=\"w-4 h-4\" />\n      {children || label}\n    </button>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;AAHA;;;AAYe,SAAS,WAAW,EACjC,IAAI,EACJ,QAAQ,MAAM,EACd,QAAQ,EACR,YAAY,EAAE,EACE;;IAChB,MAAM,SAAS,IAAA,kJAAS;IAExB,MAAM,cAAc;QAClB,IAAI,MAAM;YACR,OAAO,IAAI,CAAC;QACd,OAAO;YACL,OAAO,IAAI;QACb;IACF;IAEA,qBACE,6LAAC;QACC,SAAS;QACT,WAAW,CAAC,kNAAkN,EAAE,WAAW;;0BAE3O,6LAAC,gOAAS;gBAAC,WAAU;;;;;;YACpB,YAAY;;;;;;;AAGnB;GAzBwB;;QAMP,kJAAS;;;KANF"}}]
}