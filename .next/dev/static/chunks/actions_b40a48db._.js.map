{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/submission.action.ts"],"sourcesContent":["\"use server\";\n\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\nexport async function getSubmission(id: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 86400, revalidate: 86400 }); // 24 hours (submissions are immutable generally)\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    cacheTag(`submission-${id}`, `user-submissions-${session.user.id}`);\n\n    const submission = await SubmissionService.getSubmissionById(id);\n\n    // Security check: Ensure the submission belongs to the user\n    // OR if we want to allow sharing, we might skip this.\n    // For now, assuming private submissions.\n    if (submission && submission.userId !== session.user.id) {\n        return null; // Or throw Unauthorized\n    }\n\n    return submission;\n}\n\nexport async function getProblemSubmissionsAction(problemId: string, take: number = 20, cursor?: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 60, revalidate: 60 }); // 1 minute default, but we rely on on-demand revalidation ideally\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return [];\n    }\n\n    const userId = session.user.id;\n\n    const tagKey = `problem-submissions-${userId}-${problemId}${cursor ? `-cursor-${cursor}` : \"\"}-take-${take}`;\n    cacheTag(tagKey, `user-submissions-${userId}`, `problem-${problemId}`);\n\n    return SubmissionService.getProblemSubmissions(problemId, userId, take, cursor);\n}\n\nexport async function markConceptAsCompleted(problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    // Use a default language (e.g., JavaScript ID 63) for concept submissions since language doesn't matter\n    const DEFAULT_CONCEPT_LANG_ID = 63;\n\n    try {\n        // Create a submission with ACCEPTED status\n        const submission = await SubmissionService.createSubmission(\n            userId,\n            problemId,\n            DEFAULT_CONCEPT_LANG_ID,\n            \"// CONCEPT COMPLETED\",\n            \"SUBMIT\"\n        );\n\n        // Update status to ACCEPTED\n        await SubmissionService.updateSubmissionStatus(submission.id, \"ACCEPTED\", 0, 0);\n\n        // Increment solved counts (logic in service handles exclusion of user stats for CONCEPT)\n        await SubmissionService.incrementProblemSolved(problemId, userId);\n\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        updateTag(`problem-${problemId}`);\n        updateTag(`user-submissions-${userId}`);\n        updateTag(`problem-submissions-${userId}-${problemId}`);\n        updateTag('categories-list');\n        updateTag(`categories-DSA-user-${userId}`);\n        updateTag(`categories-SQL-user-${userId}`);\n        updateTag('problems-list');\n        updateTag('problems-search');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to mark concept as completed:\", error);\n        return { success: false, error: \"Failed to mark as completed\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAOsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///home/vishnu/Documents/projects/Algo-fox/actions/submission.action.ts"],"sourcesContent":["\"use server\";\n\nimport { SubmissionService } from \"@/core/services/submission.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\nexport async function getSubmission(id: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 86400, revalidate: 86400 }); // 24 hours (submissions are immutable generally)\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return null;\n    }\n\n    cacheTag(`submission-${id}`, `user-submissions-${session.user.id}`);\n\n    const submission = await SubmissionService.getSubmissionById(id);\n\n    // Security check: Ensure the submission belongs to the user\n    // OR if we want to allow sharing, we might skip this.\n    // For now, assuming private submissions.\n    if (submission && submission.userId !== session.user.id) {\n        return null; // Or throw Unauthorized\n    }\n\n    return submission;\n}\n\nexport async function getProblemSubmissionsAction(problemId: string, take: number = 20, cursor?: string) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 60, revalidate: 60 }); // 1 minute default, but we rely on on-demand revalidation ideally\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        return [];\n    }\n\n    const userId = session.user.id;\n\n    const tagKey = `problem-submissions-${userId}-${problemId}${cursor ? `-cursor-${cursor}` : \"\"}-take-${take}`;\n    cacheTag(tagKey, `user-submissions-${userId}`, `problem-${problemId}`);\n\n    return SubmissionService.getProblemSubmissions(problemId, userId, take, cursor);\n}\n\nexport async function markConceptAsCompleted(problemId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || !session.user) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    // Use a default language (e.g., JavaScript ID 63) for concept submissions since language doesn't matter\n    const DEFAULT_CONCEPT_LANG_ID = 63;\n\n    try {\n        // Create a submission with ACCEPTED status\n        const submission = await SubmissionService.createSubmission(\n            userId,\n            problemId,\n            DEFAULT_CONCEPT_LANG_ID,\n            \"// CONCEPT COMPLETED\",\n            \"SUBMIT\"\n        );\n\n        // Update status to ACCEPTED\n        await SubmissionService.updateSubmissionStatus(submission.id, \"ACCEPTED\", 0, 0);\n\n        // Increment solved counts (logic in service handles exclusion of user stats for CONCEPT)\n        await SubmissionService.incrementProblemSolved(problemId, userId);\n\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        updateTag(`problem-${problemId}`);\n        updateTag(`user-submissions-${userId}`);\n        updateTag(`problem-submissions-${userId}-${problemId}`);\n        updateTag('categories-list');\n        updateTag(`categories-DSA-user-${userId}`);\n        updateTag(`categories-SQL-user-${userId}`);\n        updateTag('problems-list');\n        updateTag('problems-search');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to mark concept as completed:\", error);\n        return { success: false, error: \"Failed to mark as completed\" };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAiCsB,8BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}}]
}