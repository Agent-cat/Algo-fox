{"version":3,"sources":["../../../../actions/contest.ts"],"sourcesContent":["\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { unstable_cache as cache, unstable_noStore as noStore } from \"next/cache\";\nimport { cacheTag, cacheLife } from \"next/cache\";\nimport { after } from \"next/server\"; // For background tasks\n\nconst contestSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.coerce.date(),\n    endTime: z.coerce.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    problems: z.array(z.string()).min(1, \"Select at least one problem\"),\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\nconst contestWithProblemsSchema = z.object({\n    title: z.string().min(3, \"Title must be at least 3 characters\"),\n    slug: z.string().min(3, \"Slug must be at least 3 characters\"),\n    description: z.string().optional(),\n    startTime: z.date(),\n    endTime: z.date(),\n    visibility: z.enum([\"PUBLIC\", \"INSTITUTION\", \"CLASSROOM\"]),\n    hidden: z.boolean().default(false),\n    classroomId: z.string().optional(),\n    institutionId: z.string().optional().nullable(),\n    backgroundImage: z.string().optional(),\n    prizes: z.string().optional(),\n    rules: z.string().optional(),\n    problems: z.array(z.any()), // Full problem data objects\n    contestPassword: z.string().optional(),\n    randomizeQuestions: z.boolean().default(false),\n});\n\n/**\n * Fetches contests visible to the current user.\n */\n/**\n * Cached fetch for public contests\n */\nasync function getPublicContests() {\n    \"use cache\"\n    cacheTag(\"contests-public\");\n    // @ts-ignore\n    cacheLife(\"contests\");\n\n    return prisma.contest.findMany({\n        where: {\n            visibility: \"PUBLIC\",\n            hidden: false,\n        },\n        include: {\n            _count: { select: { problems: true } }\n        },\n        orderBy: { startTime: \"desc\" },\n    });\n}\n\n/**\n * Fetches contests visible to the current user.\n */\nexport async function getVisibleContests() {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        if (!session?.user) {\n            const contests = await getPublicContests();\n            return { success: true, contests };\n        }\n\n        const currentUser = session.user as any;\n\n        if (currentUser.role === \"ADMIN\") {\n            const contests = await prisma.contest.findMany({\n                include: {\n                    _count: { select: { problems: true } }\n                },\n                orderBy: { startTime: \"desc\" },\n            });\n            return { success: true, contests };\n        }\n\n        const contests = await prisma.contest.findMany({\n            where: {\n                OR: [\n                    { visibility: \"PUBLIC\" },\n                    {\n                        AND: [\n                            { visibility: \"INSTITUTION\" },\n                            { institutionId: currentUser.institutionId },\n                        ],\n                    },\n                    {\n                        AND: [\n                            { visibility: \"CLASSROOM\" },\n                            {\n                                OR: [\n                                    { classroom: { students: { some: { id: currentUser.id } } } },\n                                    { creatorId: currentUser.id },\n                                ],\n                            },\n                        ],\n                    },\n                    { creatorId: currentUser.id },\n                ],\n            },\n            include: {\n                _count: { select: { problems: true } }\n            },\n            orderBy: { startTime: \"desc\" },\n        });\n\n        return { success: true, contests };\n    } catch (error) {\n        console.error(\"Failed to fetch contests:\", error);\n        return { success: false, error: \"Failed to fetch contests\" };\n    }\n}\n\n\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Fetches a single contest's details with authorization.\n */\n/**\n * Cached contest detail fetcher\n * Returns contest data without user-specific context\n */\nasync function getCachedContest(contestId: string) {\n    \"use cache\"\n    cacheTag(`contest-${contestId}`);\n    // @ts-ignore\n    cacheLife(\"contest-detail\");\n\n    return prisma.contest.findUnique({\n        where: { id: contestId },\n        include: {\n            _count: {\n                select: { problems: true },\n            },\n            problems: {\n                include: {\n                    problem: {\n                        select: {\n                            id: true,\n                            title: true,\n                            difficulty: true,\n                            slug: true,\n                        },\n                    },\n                },\n                orderBy: { order: \"asc\" },\n            },\n        },\n    });\n}\n\n/**\n * Fetches a single contest's details with authorization.\n */\nexport async function getContestDetail(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    try {\n        const contest = await getCachedContest(contestId);\n\n        if (!contest) {\n            return { success: false, error: \"Contest not found\" };\n        }\n\n        const currentUser = session?.user as any;\n        const participation = currentUser ? await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: currentUser.id,\n                    contestId: contestId\n                }\n            }\n        }) : null;\n\n        const now = new Date();\n        const hasStarted = now >= contest.startTime;\n        const isCreator = currentUser?.id === contest.creatorId;\n        const isAdmin = currentUser?.role === \"ADMIN\";\n\n        // Visibility Check\n        let isAuthorized = false;\n        if (contest.visibility === \"PUBLIC\") {\n            isAuthorized = true;\n        } else if (isAdmin) {\n            isAuthorized = true;\n        } else if (currentUser) {\n            if (isCreator) {\n                isAuthorized = true;\n            } else if (contest.visibility === \"INSTITUTION\") {\n                // Use == for null/undefined loose equality check\n                isAuthorized = currentUser.institutionId == contest.institutionId;\n            } else if (contest.visibility === \"CLASSROOM\") {\n                const enrollment = await prisma.classroom.findFirst({\n                    where: {\n                        id: contest.classroomId as string,\n                        students: { some: { id: currentUser.id } },\n                    },\n                });\n                isAuthorized = !!enrollment;\n            }\n        }\n\n        if (!isAuthorized) {\n            return { success: false, error: \"Unauthorized access to this contest.\" };\n        }\n\n        const canSeeProblems = (hasStarted || isAdmin || isCreator) && (participation?.acceptedRules || isCreator || isAdmin);\n\n        // Fix: If the contest is over, allowed roles should check participation properly,\n        // but typically allows viewing if public/authorized.\n        // But for \"Live\" contests, the current logic is correct.\n\n        const requiresPassword = !!contest.contestPassword;\n\n        // Shuffle problems if randomizeQuestions is enabled\n        // Use a simple seeded shuffle based on userId + contestId for consistency\n        let visibleProblems = canSeeProblems ? contest.problems : [];\n\n        if (contest.randomizeQuestions && currentUser && visibleProblems.length > 0 && !isAdmin && !isCreator) {\n            // Simple string hash function for seeding\n            const seedStr = `${currentUser.id}-${contestId}`;\n            let seed = 0;\n            for (let i = 0; i < seedStr.length; i++) {\n                seed = ((seed << 5) - seed) + seedStr.charCodeAt(i);\n                seed |= 0;\n            }\n\n            // Deterministic shuffle\n            visibleProblems = [...visibleProblems].sort((a, b) => {\n                const x = Math.sin(seed++) * 10000;\n                return (x - Math.floor(x)) - 0.5;\n            });\n        }\n\n        // Fetch user's solved problems for this contest\n        const solvedProblemIds = new Set<string>();\n        if (currentUser) {\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId: currentUser.id,\n                    contestId: contestId,\n                    status: \"ACCEPTED\",\n                    problemId: {\n                        in: visibleProblems.map(p => p.problem.id)\n                    }\n                },\n                select: { problemId: true }\n            });\n            solvedSubmissions.forEach(s => solvedProblemIds.add(s.problemId));\n        }\n\n        return {\n            success: true,\n            contest: {\n                ...contest,\n                problems: visibleProblems.map(vp => ({\n                    ...vp,\n                    isSolved: solvedProblemIds.has(vp.problem.id)\n                })),\n                hasStarted,\n                hasEnded: now > contest.endTime,\n                canManage: isAdmin || isCreator,\n                hasAcceptedRules: participation?.acceptedRules || false,\n                isFinished: participation?.isFinished || false,\n                requiresPassword,\n                contestPassword: null, // Never return plain password\n                sessionId: participation?.sessionId // Return sessionId for protection\n            }\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch contest detail:\", error);\n        return { success: false, error: \"Failed to fetch contest\" };\n    }\n}\n\n// ... existing code ...\n\n// ... existing code ...\n\n// ... existing code ...\n\nexport async function createContest(data: z.infer<typeof contestSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestSchema.parse(data);\n\n        // Generate a more robust unique slug\n        const baseSlug = validatedData.title.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/(^-|-$)/g, \"\");\n        const uniqueSlug = `${baseSlug}-${Date.now()}`;\n\n        const contest = await prisma.contest.create({\n            data: {\n                title: validatedData.title,\n                slug: uniqueSlug,\n                description: validatedData.description,\n                startTime: validatedData.startTime,\n                endTime: validatedData.endTime,\n                visibility: validatedData.visibility as any,\n                institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                creatorId: currentUser.id,\n                contestPassword: validatedData.contestPassword || null,\n                randomizeQuestions: validatedData.randomizeQuestions || false,\n                problems: {\n                    create: validatedData.problems.map((problemId, index) => ({\n                        problemId,\n                        order: index,\n                    })),\n                },\n            },\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error: any) {\n        console.error(\"Failed to create contest:\", error);\n        // Return clearer error messages\n        let errorMessage = \"Failed to create contest\";\n        if (error instanceof z.ZodError) {\n             errorMessage = (error as any).errors.map((e: any) => e.message).join(\", \");\n        } else if (error instanceof Error) {\n             errorMessage = error.message;\n        }\n        return { success: false, error: errorMessage };\n    }\n    }\n\n\nexport async function createContestWithProblems(data: z.infer<typeof contestWithProblemsSchema>) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    if (![\"ADMIN\", \"INSTITUTION_MANAGER\", \"CONTEST_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const validatedData = contestWithProblemsSchema.parse(data);\n\n        const contest = await prisma.$transaction(async (tx) => {\n            const contest = await tx.contest.create({\n                data: {\n                    title: validatedData.title,\n                    slug: validatedData.slug,\n                    description: validatedData.description,\n                    startTime: validatedData.startTime,\n                    endTime: validatedData.endTime,\n                    visibility: validatedData.visibility as any,\n                    hidden: validatedData.hidden,\n                    backgroundImage: validatedData.backgroundImage,\n                    prizes: validatedData.prizes,\n                    rules: validatedData.rules,\n                    institutionId: validatedData.visibility !== \"PUBLIC\" ? (validatedData.institutionId || null) : null,\n                    classroomId: validatedData.visibility === \"CLASSROOM\" ? (validatedData.classroomId || null) : null,\n                    creatorId: currentUser.id,\n                    contestPassword: validatedData.contestPassword || null,\n                    randomizeQuestions: validatedData.randomizeQuestions || false,\n                }\n            });\n\n            for (let i = 0; i < validatedData.problems.length; i++) {\n                const p = validatedData.problems[i];\n                // Generate unique slug by appending contest slug and index\n                const uniqueSlug = `${validatedData.slug}-${p.slug || p.title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}-${i}`;\n                const problem = await tx.problem.create({\n                    data: {\n                        title: p.title,\n                        description: p.description,\n                        difficulty: p.difficulty,\n                        slug: uniqueSlug,\n                        score: p.score || 10,\n                        domain: p.domain,\n                        type: \"CONTEST\", // Contest problems are marked separately\n                        hidden: true, // Contest problems are hidden from main bank\n                        testCases: {\n                            create: p.testCases,\n                        },\n                        tags: {\n                            connect: p.tags?.map((t: string) => ({ name: t })) || [],\n                        }\n                    }\n                });\n\n                await tx.contestProblem.create({\n                    data: {\n                        contestId: contest.id,\n                        problemId: problem.id,\n                        order: i,\n                    }\n                });\n            }\n\n            return contest;\n        });\n\n        revalidatePath(\"/dashboard/contests\");\n        revalidatePath(\"/contests\");\n        revalidatePath(\"/contest\");\n        revalidateTag(\"contests\", \"max\");\n        return { success: true, contestId: contest.id };\n    } catch (error) {\n        console.error(\"Failed to create contest with problems:\", error);\n        return { success: false, error: \"Failed to create contest\" };\n    }\n}\n\nexport async function getInstitutionalClassrooms(institutionId: string) {\n    try {\n        const classrooms = await prisma.classroom.findMany({\n            where: { institutionId },\n            select: { id: true, name: true, section: true },\n        });\n        return { success: true, classrooms };\n    } catch (error) {\n        console.error(\"Failed to fetch classrooms:\", error);\n        return { success: false, error: \"Failed to fetch classrooms\" };\n    }\n}\n\nexport async function getSelectableProblems(search: string) {\n    try {\n        const problems = await prisma.problem.findMany({\n            where: {\n                OR: [\n                    { title: { contains: search, mode: \"insensitive\" } },\n                    { slug: { contains: search, mode: \"insensitive\" } },\n                ],\n                hidden: false,\n            },\n            select: { id: true, title: true, difficulty: true, slug: true },\n            take: 10,\n        });\n        return { success: true, problems };\n    } catch (error) {\n        console.error(\"Failed to fetch problems:\", error);\n        return { success: false, error: \"Failed to fetch problems\" };\n    }\n}\n\nexport async function acceptContestRules(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: { acceptedRules: true },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to accept rules\" };\n    }\n}\n\nexport async function finishContestAction(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                isFinished: true,\n                finishedAt: new Date()\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                acceptedRules: true,\n                isFinished: true,\n                finishedAt: new Date()\n            }\n        });\n        revalidatePath(`/contest/${contestId}`);\n        revalidatePath(`/problems`);\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: \"Failed to finish contest\" };\n    }\n}\n\n/**\n * Finalize Contest & Award Badges\n * - Calculates leaderboard\n * - Awards Gold, Silver, Bronze to Top 3\n * - Marks contest as finalized\n */\nexport async function finalizeContest(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    // Only admins or contest managers can finalize\n    const currentUser = session.user as any;\n    if (![\"ADMIN\", \"CONTEST_MANAGER\", \"INSTITUTION_MANAGER\", \"TEACHER\"].includes(currentUser.role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const contest = await prisma.contest.findUnique({\n             where: { id: contestId },\n             select: { isFinalized: true, title: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n        if (contest.isFinalized) return { success: false, error: \"Contest is already finalized\" };\n\n        // Reuse leaderboard logic to get rankings\n        const leaderboard = await getContestLeaderboard(contestId);\n        if (!leaderboard.success || !leaderboard.students) {\n            return { success: false, error: \"Failed to fetch leaderboard\" };\n        }\n\n        const students = leaderboard.students as any[];\n\n        // At least 1 student needed\n        if (students.length === 0) {\n             await prisma.contest.update({\n                 where: { id: contestId },\n                 data: { isFinalized: true }\n             });\n             return { success: true, message: \"Contest finalized (no participants)\" };\n        }\n\n        // Top 3 IDs\n        const goldUserId = students[0]?.id;\n        const silverUserId = students[1]?.id;\n        const bronzeUserId = students[2]?.id;\n\n        await prisma.$transaction(async (tx) => {\n            // Award Gold\n            if (goldUserId) {\n                await tx.user.update({\n                    where: { id: goldUserId },\n                    data: { goldBadges: { increment: 1 } }\n                });\n            }\n            // Award Silver\n            if (silverUserId) {\n                await tx.user.update({\n                    where: { id: silverUserId },\n                    data: { silverBadges: { increment: 1 } }\n                });\n            }\n            // Award Bronze\n            if (bronzeUserId) {\n                await tx.user.update({\n                    where: { id: bronzeUserId },\n                    data: { bronzeBadges: { increment: 1 } }\n                });\n            }\n\n            // Mark Finalized\n            await tx.contest.update({\n                where: { id: contestId },\n                data: { isFinalized: true }\n            });\n        });\n\n        revalidatePath(`/dashboard`);\n        revalidatePath(`/profile/${goldUserId}`);\n        if(silverUserId) revalidatePath(`/profile/${silverUserId}`);\n        if(bronzeUserId) revalidatePath(`/profile/${bronzeUserId}`);\n        revalidatePath(`/contest/${contestId}`);\n        revalidateTag(`contest-${contestId}`, \"max\");\n        revalidateTag(`leaderboard-${contestId}`, \"max\");\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to finalize contest:\", error);\n        return { success: false, error: \"Failed to finalize contest\" };\n    }\n}\n\n/**\n * Verify contest password without starting session.\n */\nexport async function verifyContestPassword(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to verify contest password:\", error);\n        return { success: false, error: \"Failed to verify password\" };\n    }\n}\n\n\n/**\n * Start a contest session - validates time bounds and creates session ID\n */\nexport async function startContestSession(contestId: string, password?: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            select: { startTime: true, endTime: true, contestPassword: true }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        if (contest.contestPassword && contest.contestPassword !== password) {\n            return { success: false, error: \"Invalid contest password\" };\n        }\n\n        const now = new Date();\n\n        // Time bounds check\n        if (now < contest.startTime) {\n            return { success: false, error: \"Contest has not started yet\" };\n        }\n        if (now > contest.endTime) {\n            return { success: false, error: \"Contest has already ended\" };\n        }\n\n        // Generate unique session ID\n        const sessionId = `${session.user.id}-${contestId}-${Date.now()}`;\n\n        // Check for existing active session (multi-tab detection)\n        const existingParticipation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (existingParticipation?.isBlocked) {\n            return { success: false, error: \"You have been blocked from this contest due to violations\" };\n        }\n\n        if (existingParticipation?.isFinished) {\n            return { success: false, error: \"You have already finished this contest\" };\n        }\n\n        // Update or create participation with new session\n        const participation = await prisma.contestParticipation.upsert({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            update: {\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            },\n            create: {\n                userId: session.user.id,\n                contestId: contestId,\n                sessionId,\n                sessionStartedAt: now,\n                acceptedRules: true\n            }\n        });\n\n        return {\n            success: true,\n            sessionId,\n            participationId: participation.id,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to start contest session:\", error);\n        return { success: false, error: \"Failed to start contest session\" };\n    }\n}\n\n/**\n * Log a contest violation - records to database and updates counters\n */\nexport async function logContestViolation(\n    contestId: string,\n    type: \"TAB_SWITCH\" | \"FULLSCREEN_EXIT\" | \"COPY_PASTE\" | \"DEVTOOLS_OPEN\" | \"KEYBOARD_SHORTCUT\" | \"NAVIGATION_ATTEMPT\" | \"MULTI_TAB\" | \"SUSPICIOUS_INPUT\",\n    message?: string,\n    metadata?: Record<string, any>\n) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: false, error: \"No active participation found\" };\n        }\n\n        // Determine which counter to increment\n        const counterField = {\n            TAB_SWITCH: \"tabSwitchCount\",\n            FULLSCREEN_EXIT: \"fullscreenExitCount\",\n            COPY_PASTE: \"copyPasteCount\",\n            DEVTOOLS_OPEN: \"devToolsCount\",\n            KEYBOARD_SHORTCUT: \"keyboardCount\",\n            NAVIGATION_ATTEMPT: \"navigationCount\",\n            MULTI_TAB: \"tabSwitchCount\",\n            SUSPICIOUS_INPUT: \"copyPasteCount\"\n        }[type] as string;\n\n        // Use transaction to ensure atomic update\n        const result = await prisma.$transaction(async (tx) => {\n            // Check last violation time to prevent rapid-fire duplicates (Server-side debounce)\n            const lastViolation = await tx.contestViolation.findFirst({\n                where: { participationId: participation.id },\n                orderBy: { createdAt: 'desc' }\n            });\n\n            if (lastViolation) {\n                const timeDiff = Date.now() - lastViolation.createdAt.getTime();\n                // If less than 2 seconds since last violation, ignore this one\n                if (timeDiff < 2000) {\n                    return {\n                        ...participation, // Return existing state\n                        isFlagged: participation.isFlagged,\n                        isBlocked: participation.isBlocked,\n                        totalViolations: participation.totalViolations,\n                        permanentlyBlocked: participation.permanentlyBlocked,\n                        tempBlockedUntil: participation.tempBlockedUntil\n                    };\n                }\n            }\n\n            // Create violation record\n            await tx.contestViolation.create({\n                data: {\n                    participationId: participation.id,\n                    type: type as any,\n                    message,\n                    metadata: metadata ?? undefined\n                }\n            });\n\n            // Calculate new total and determine blocking tier\n            const newTotalViolations = participation.totalViolations + 1;\n            const shouldFlag = newTotalViolations >= 3;\n\n            // Tiered blocking logic\n            let tempBlockedUntil: Date | null = null;\n            let permanentlyBlocked = false;\n            let isBlocked = false;\n\n            if (newTotalViolations >= 6) {\n                // 6+ violations = permanent block\n                permanentlyBlocked = true;\n                isBlocked = true;\n            } else if (newTotalViolations >= 4) {\n                // 4-5 violations = 5 minute temp block\n                tempBlockedUntil = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\n                isBlocked = true;\n            }\n\n            const updated = await tx.contestParticipation.update({\n                where: { id: participation.id },\n                data: {\n                    [counterField]: { increment: 1 },\n                    totalViolations: { increment: 1 },\n                    isFlagged: shouldFlag || participation.isFlagged,\n                    isBlocked,\n                    tempBlockedUntil,\n                    permanentlyBlocked\n                }\n            });\n\n            return updated;\n        });\n\n        return {\n            success: true,\n            totalViolations: result.totalViolations,\n            isFlagged: result.isFlagged,\n            isBlocked: result.isBlocked,\n            tempBlockedUntil: result.tempBlockedUntil?.toISOString() || null,\n            permanentlyBlocked: result.permanentlyBlocked\n        };\n    } catch (error) {\n        console.error(\"Failed to log violation:\", error);\n        return { success: false, error: \"Failed to log violation\" };\n    }\n}\n\n/**\n * Validate contest session - checks if session is valid for submissions\n */\nexport async function validateContestSession(contestId: string, sessionId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, valid: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { success: true, valid: false, reason: \"No participation found\" };\n        }\n\n        // Check if blocked\n        if (participation.isBlocked) {\n            return { success: true, valid: false, reason: \"Blocked due to violations\" };\n        }\n\n        // Check if finished\n        if (participation.isFinished) {\n            return { success: true, valid: false, reason: \"Contest already finished\" };\n        }\n\n        // Check session ID (multi-tab detection)\n        if (participation.sessionId !== sessionId) {\n            // Log multi-tab violation\n            await logContestViolation(contestId, \"MULTI_TAB\", \"Multiple tabs detected\");\n            return { success: true, valid: false, reason: \"Session mismatch - possible multiple tabs\" };\n        }\n\n        // Check time bounds\n        const now = new Date();\n        if (now > participation.contest.endTime) {\n            return { success: true, valid: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            success: true,\n            valid: true,\n            totalViolations: participation.totalViolations,\n            isFlagged: participation.isFlagged\n        };\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return { success: false, valid: false, error: \"Failed to validate session\" };\n    }\n}\n\n/**\n * Check if user is eligible to submit - pre-submission validation\n */\nexport async function checkSubmissionEligibility(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { eligible: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            include: {\n                contest: {\n                    select: { startTime: true, endTime: true }\n                }\n            }\n        });\n\n        if (!participation) {\n            return { eligible: false, reason: \"No participation found\" };\n        }\n\n        // Check various conditions\n        if (participation.isBlocked) {\n            return { eligible: false, reason: \"Blocked due to excessive violations\" };\n        }\n\n        if (participation.isFinished) {\n            return { eligible: false, reason: \"You have already finished this contest\" };\n        }\n\n        const now = new Date();\n        if (now < participation.contest.startTime) {\n            return { eligible: false, reason: \"Contest has not started\" };\n        }\n\n        if (now > participation.contest.endTime) {\n            return { eligible: false, reason: \"Contest has ended\" };\n        }\n\n        return {\n            eligible: true,\n            warnings: participation.isFlagged ? [\"Your session has been flagged for review\"] : []\n        };\n    } catch (error) {\n        console.error(\"Failed to check eligibility:\", error);\n        return { eligible: false, error: \"Failed to check eligibility\" };\n    }\n}\n\n/**\n * Get participation status - for UI state\n */\nexport async function getParticipationStatus(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId: session.user.id,\n                    contestId: contestId\n                }\n            },\n            select: {\n                acceptedRules: true,\n                isFinished: true,\n                isFlagged: true,\n                isBlocked: true,\n                totalViolations: true,\n                sessionId: true,\n                tempBlockedUntil: true,\n                permanentlyBlocked: true\n            }\n        });\n\n        // Check if temp block has expired\n        if (participation?.tempBlockedUntil && new Date() > participation.tempBlockedUntil) {\n            // Temp block expired - unblock\n            await prisma.contestParticipation.update({\n                where: {\n                    userId_contestId: {\n                        userId: session.user.id,\n                        contestId: contestId\n                    }\n                },\n                data: {\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            });\n\n            return {\n                success: true,\n                participation: {\n                    ...participation,\n                    isBlocked: false,\n                    tempBlockedUntil: null\n                }\n            };\n        }\n\n        return {\n            success: true,\n            participation: participation || null\n        };\n    } catch (error) {\n        return { success: false, error: \"Failed to get participation status\" };\n    }\n}\n\n// ============================================\n// CONTEST MANAGER - PARTICIPANT MANAGEMENT\n// ============================================\n\n/**\n * Get all participants for a contest with violation details (for managers)\n */\nexport async function getContestParticipants(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check if user is contest manager/creator\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participants = await prisma.contestParticipation.findMany({\n            where: { contestId },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        email: true,\n                        image: true\n                    }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" },\n                    take: 10\n                }\n            },\n            orderBy: [\n                { permanentlyBlocked: \"desc\" },\n                { isBlocked: \"desc\" },\n                { totalViolations: \"desc\" }\n            ]\n        });\n\n        return { success: true, participants };\n    } catch (error) {\n        console.error(\"Failed to get participants:\", error);\n        return { success: false, error: \"Failed to get participants\" };\n    }\n}\n\n/**\n * Unblock a participant (manager only)\n */\nexport async function unblockParticipant(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.contestParticipation.update({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            data: {\n                isBlocked: false,\n                tempBlockedUntil: null,\n                permanentlyBlocked: false,\n                totalViolations: 0,\n                tabSwitchCount: 0,\n                fullscreenExitCount: 0,\n                copyPasteCount: 0,\n                devToolsCount: 0,\n                keyboardCount: 0,\n                navigationCount: 0,\n                isFlagged: false,\n                unblockedBy: currentUser.id,\n                unblockedAt: new Date()\n            }\n        });\n\n        revalidatePath(`/dashboard/contests/${contestId}/participants`);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to unblock participant:\", error);\n        return { success: false, error: \"Failed to unblock participant\" };\n    }\n}\n\n/**\n * Get detailed violations for a participant\n */\nexport async function getParticipantViolations(contestId: string, userId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    const currentUser = session.user as any;\n\n    // Check authorization\n    const contest = await prisma.contest.findUnique({\n        where: { id: contestId },\n        select: { creatorId: true }\n    });\n\n    if (!contest) return { success: false, error: \"Contest not found\" };\n\n    const isAuthorized =\n        currentUser.role === \"ADMIN\" ||\n        currentUser.role === \"CONTEST_MANAGER\" ||\n        currentUser.role === \"TEACHER\" ||\n        contest.creatorId === currentUser.id;\n\n    if (!isAuthorized) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        const participation = await prisma.contestParticipation.findUnique({\n            where: {\n                userId_contestId: {\n                    userId,\n                    contestId\n                }\n            },\n            include: {\n                user: {\n                    select: { id: true, name: true, email: true }\n                },\n                violations: {\n                    orderBy: { createdAt: \"desc\" }\n                }\n            }\n        });\n\n        return { success: true, participation };\n    } catch (error) {\n        return { success: false, error: \"Failed to get violations\" };\n    }\n}\n\n/**\n * Calculate contest leaderboard\n * - Fetches all participations\n * - Fetches all relevant submissions\n * - Calculates scores\n */\nexport async function getContestLeaderboard(contestId: string) {\n    \"use cache\"\n    cacheTag(`leaderboard-${contestId}`)\n    // @ts-ignore\n    cacheLife(\"leaderboard\")\n\n    try {\n        const participations = await prisma.contestParticipation.findMany({\n            where: {\n                contestId,\n                // startedAt: { not: null } // Only started participants (Fix if field exists, otherwise rely on created)\n            },\n            include: {\n                user: {\n                    select: {\n                        id: true,\n                        name: true,\n                        image: true\n                    }\n                }\n            }\n        });\n\n        const contest = await prisma.contest.findUnique({\n            where: { id: contestId },\n            include: {\n                problems: {\n                    include: {\n                        problem: {\n                            select: {\n                                id: true,\n                                title: true,\n                                difficulty: true,\n                                slug: true,\n                                score: true\n                            }\n                        }\n                    },\n                    orderBy: { order: \"asc\" }\n                }\n            }\n        });\n\n        if (!contest) return { success: false, error: \"Contest not found\" };\n\n        const leaderboard = await Promise.all(participations.map(async (p) => {\n            // Get valid submissions for this user in this contest\n            const submissions = await prisma.submission.findMany({\n                where: {\n                    userId: p.userId,\n                    contestId: contestId,\n                    createdAt: {\n                        gte: contest.startTime,\n                        lte: contest.endTime\n                    }\n                },\n                select: {\n                    id: true,\n                    status: true,\n                    problemId: true,\n                    createdAt: true,\n                    language: {\n                        select: {\n                            id: true,\n                            name: true\n                        }\n                    }\n                }\n            });\n\n            // Calculate total score\n            // Logic: Best submission per problem counts\n            const problemScores = new Map<string, number>();\n            const problemSolveTimes = new Map<string, Date>();\n            const problemSubmissionCounts = new Map<string, number>();\n            const problemBestSubmissions = new Map<string, any>();\n\n            submissions.forEach(sub => {\n                const currentCount = problemSubmissionCounts.get(sub.problemId) || 0;\n                problemSubmissionCounts.set(sub.problemId, currentCount + 1);\n\n                if (sub.status === \"ACCEPTED\") {\n                    const currentBest = problemScores.get(sub.problemId) || 0;\n                    const problemDef = contest.problems.find(cp => cp.problemId === sub.problemId);\n                    const maxScore = problemDef?.problem.score || 0;\n\n                    if (maxScore > currentBest) {\n                         problemScores.set(sub.problemId, maxScore);\n                         const currentBestTime = problemSolveTimes.get(sub.problemId);\n                         if (!currentBestTime || sub.createdAt < currentBestTime) {\n                             problemSolveTimes.set(sub.problemId, sub.createdAt);\n                             problemBestSubmissions.set(sub.problemId, sub);\n                         }\n                    }\n                }\n            });\n\n            let totalScore = 0;\n            let totalTimeMs = 0;\n\n            problemScores.forEach((score, problemId) => {\n                totalScore += score;\n                const solventTime = problemSolveTimes.get(problemId);\n                if (solventTime) {\n                    totalTimeMs += (solventTime.getTime() - contest.startTime.getTime());\n                }\n            });\n\n            // Map stats for each problem in the contest\n            const problemStats = contest.problems.map(cp => {\n                const bestSub = problemBestSubmissions.get(cp.problemId);\n                return {\n                    problemId: cp.problemId,\n                    title: cp.problem.title,\n                    slug: cp.problem.slug,\n                    score: problemScores.get(cp.problemId) || 0,\n                    maxScore: cp.problem.score,\n                    submissions: problemSubmissionCounts.get(cp.problemId) || 0,\n                    solved: problemScores.has(cp.problemId),\n                    solvedAt: problemSolveTimes.get(cp.problemId),\n                    language: bestSub?.language?.name || null,\n                    languageId: bestSub?.language?.id || null\n                };\n            });\n\n            return {\n                ...p.user,\n                score: totalScore,\n                timeTaken: totalTimeMs,\n                problemsSolved: problemScores.size,\n                problemStats\n            };\n        }));\n\n        // Sort: High score first, then low time taken\n        leaderboard.sort((a, b) => {\n            if (b.score !== a.score) return b.score - a.score;\n            return a.timeTaken - b.timeTaken;\n        });\n\n        return {\n            success: true,\n            students: leaderboard,\n            isFinalized: contest.isFinalized,\n            problems: contest.problems.map(cp => ({\n                id: cp.problemId,\n                title: cp.problem.title,\n                slug: cp.problem.slug,\n                maxScore: cp.problem.score\n            }))\n        };\n\n    } catch (error) {\n        console.error(\"Leaderboard error:\", error);\n        return { success: false, error: \"Failed to generate leaderboard\" };\n    }\n}\n\n/**\n * Get current user's ranking in a contest\n */\nexport async function getContestRanking(contestId: string) {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n\n    if (!session?.user) return { success: false, error: \"Unauthorized\" };\n\n    try {\n        const result = await getContestLeaderboard(contestId);\n\n        if (!result.success || !result.students) {\n            return { success: false, error: \"Failed to get ranking\" };\n        }\n\n        const rank = result.students.findIndex((s: any) => s.id === session.user.id) + 1;\n\n        return { success: true, rank: rank > 0 ? rank : null };\n    } catch (error) {\n         return { success: false, error: \"Failed to get ranking\" };\n    }\n}\n"],"names":[],"mappings":"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"}