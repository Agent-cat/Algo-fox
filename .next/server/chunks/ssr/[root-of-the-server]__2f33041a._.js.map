{"version":3,"sources":["../../../../actions/auth.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../lib/points.ts","../../../../core/services/user.service.ts","../../../../actions/user.action.ts","../../../../actions/platform.action.ts","../../../../.next-internal/server/app/%28main%29/dashboard/settings/platform/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n","\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n","\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n","\"use server\";\n\nimport { JSDOM } from \"jsdom\";\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport { headers } from \"next/headers\";\n\nexport async function checkCodeChefUser(handle: string, ignoreCache = false) {\n    try {\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } }; // Cache for 1 hour\n\n        const resdata = await fetch(\n            `https://www.codechef.com/users/${handle}`,\n            fetchOptions\n        );\n\n        if (resdata.status == 200) {\n\n            let d = await resdata.text();\n            let data = { data: d };\n\n            // Heatmap data extraction\n            let heatMapDataCursour1 =\n                data.data.search(\"var userDailySubmissionsStats =\") +\n                \"var userDailySubmissionsStats =\".length;\n            let heatMapDataCursour2 = data.data.search(\"'#js-heatmap\") - 34;\n            let heatDataString = data.data.substring(\n                heatMapDataCursour1,\n                heatMapDataCursour2\n            );\n\n            let headMapData = null;\n            try {\n                 headMapData = JSON.parse(heatDataString);\n            } catch (e) {\n                console.log(\"Error parsing heatmap data\", e);\n            }\n\n            // Rating data extraction\n            let allRating =\n                data.data.search(\"var all_rating = \") + \"var all_rating = \".length;\n            let allRating2 = data.data.search(\"var current_user_rating =\") - 6;\n\n            let ratingData = null;\n            try {\n                 ratingData = JSON.parse(data.data.substring(allRating, allRating2));\n            } catch (e) {\n                console.log(\"Error parsing rating data\", e);\n            }\n\n            let dom = new JSDOM(data.data);\n            let document = dom.window.document;\n\n            const name = document.querySelector(\".user-details-container\")?.children[0]\n                ?.children[1]?.textContent || \"\";\n\n            // Safe extraction with optional chaining\n            const profile = document.querySelector(\".user-details-container\")?.children[0]\n                ?.children[0]?.getAttribute(\"src\") || \"\";\n\n            const currentRatingText = document.querySelector(\".rating-number\")?.textContent;\n            const currentRating = currentRatingText ? parseInt(currentRatingText) : 0;\n\n            const highestRatingText = document.querySelector(\".rating-number\")?.parentNode?.children[4]?.textContent?.split(\"Rating\")[1];\n            const highestRating = highestRatingText ? parseInt(highestRatingText) : 0;\n\n            const countryFlag = document.querySelector(\".user-country-flag\")?.getAttribute(\"src\") || \"\";\n            const countryName = document.querySelector(\".user-country-name\")?.textContent || \"\";\n\n            const globalRankText = document.querySelector(\".rating-ranks\")?.children[0]?.children[0]\n                ?.children[0]?.children[0]?.innerHTML;\n            const globalRank = globalRankText ? parseInt(globalRankText) : 0;\n\n            const countryRankText = document.querySelector(\".rating-ranks\")?.children[0]?.children[1]\n                ?.children[0]?.children[0]?.innerHTML;\n            const countryRank = countryRankText ? parseInt(countryRankText) : 0;\n\n            const stars = document.querySelector(\".rating\")?.textContent || \"unrated\";\n\n            // Extract Fully Solved Count\n            let fullySolvedCount = 0;\n            const h5Elements = document.querySelectorAll(\"h5\");\n            for (const h5 of h5Elements) {\n                if (h5.textContent?.includes(\"Fully Solved\")) {\n                    const match = h5.textContent.match(/\\d+/);\n                    if (match) {\n                        fullySolvedCount = parseInt(match[0]);\n                    }\n                    break;\n                }\n            }\n\n            return {\n                success: true,\n                status: resdata.status,\n                profile,\n                name,\n                currentRating,\n                highestRating,\n                countryFlag,\n                countryName,\n                globalRank,\n                countryRank,\n                stars,\n                heatMap: headMapData,\n                ratingData,\n                fullySolvedCount\n            };\n        }\n        else {\n            return { success: false, status: resdata.status }\n        }\n    } catch (e) {\n        console.log(e)\n        return { success: false, status: 404 }\n    }\n}\n\nexport async function verifyCodeChefOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    // Bypass cache for verification\n    const result = await checkCodeChefUser(handle, true);\n\n    if (result.success && result.name) {\n        // Check if the verification code is present in the name\n        // The user edits their \"Name\" field to include the code\n        if (result.name.includes(verificationCode)) {\n             try {\n                await prisma.user.update({\n                    where: { id: session.user.id },\n                    data: {\n                        codeChefVerified: true,\n                        // Ensure the verified handle is the one stored\n                        codeChefHandle: handle\n                    }\n                });\n                revalidatePath(\"/dashboard/settings\"); // Revalidate settings pages\n                revalidateTag(`user-${session.user.id}`,\"max\"); // Invalidate user cache tag\n                return { success: true };\n            } catch (error) {\n                console.error(\"Database update error:\", error);\n                return { success: false, error: \"Failed to update verification status\" };\n            }\n        } else {\n             return { success: false, error: \"Verification code not found in CodeChef name. Please ensure you have updated your profile name.\" };\n        }\n    }\n\n    return { success: false, error: \"Failed to fetch CodeChef profile\" };\n}\n// ... (existing imports and functions)\n\nexport async function checkCodeforcesUser(handle: string, ignoreCache = false) {\n    try {\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } };\n\n        const [userInfoRes, userStatusRes] = await Promise.all([\n            fetch(`https://codeforces.com/api/user.info?handles=${handle}`, fetchOptions),\n            fetch(`https://codeforces.com/api/user.status?handle=${handle}`, fetchOptions)\n        ]);\n\n        if (userInfoRes.ok && userStatusRes.ok) {\n            const userData = await userInfoRes.json();\n            const statusData = await userStatusRes.json();\n\n            if (userData.status === \"OK\" && userData.result.length > 0) {\n                const user = userData.result[0];\n\n                // Calculate solved count and difficulty breakdown\n                const uniqueSolved = new Set<string>();\n                const solvedByDifficulty = {\n                    EASY: 0,\n                    MEDIUM: 0,\n                    HARD: 0,\n                    TOTAL: 0\n                };\n\n                if (statusData.status === \"OK\") {\n                    for (const submission of statusData.result) {\n                        if (submission.verdict === \"OK\") {\n                            const problemId = `${submission.problem.contestId}-${submission.problem.index}`;\n                            if (!uniqueSolved.has(problemId)) {\n                                uniqueSolved.add(problemId);\n                                const rating = submission.problem.rating;\n                                if (rating) {\n                                    if (rating < 1200) solvedByDifficulty.EASY++;\n                                    else if (rating < 1600) solvedByDifficulty.MEDIUM++; // Adjusted thresholds\n                                    else solvedByDifficulty.HARD++;\n                                } else {\n                                    // Treat unrated as easy or ignore? Let's add to Easy for now or just Total\n                                    // solvedByDifficulty.EASY++;\n                                }\n                            }\n                        }\n                    }\n                    solvedByDifficulty.TOTAL = uniqueSolved.size;\n                }\n\n                return {\n                    success: true,\n                    status: 200,\n                    firstName: user.firstName,\n                    // Check other fields if needed for existence or display\n                    rating: user.rating,\n                    rank: user.rank,\n                    maxRating: user.maxRating,\n                    maxRank: user.maxRank,\n                    avatar: user.titlePhoto || user.avatar,\n                    solvedByDifficulty\n                };\n            }\n        }\n        return { success: false, status: userInfoRes.status };\n    } catch (e) {\n        console.error(e);\n        return { success: false, status: 500 };\n    }\n}\n\nexport async function verifyCodeforcesOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    // Bypass cache for verification\n    const result = await checkCodeforcesUser(handle, true);\n\n    if (result.success) {\n        // Check if the verification code is present in the first name\n        // Codeforces allows changing First Name in settings\n        if (result.firstName && result.firstName.includes(verificationCode)) {\n             try {\n                await prisma.user.update({\n                    where: { id: session.user.id },\n                    data: {\n                        codeforcesVerified: true,\n                        // Ensure the verified handle is the one stored\n                        codeforcesHandle: handle\n                    }\n                });\n                revalidatePath(\"/dashboard/settings\"); // Revalidate settings pages\n                revalidateTag(`user-${session.user.id}`,\"max\"); // Invalidate user cache tag\n                return { success: true };\n            } catch (error) {\n                console.error(\"Database update error:\", error);\n                return { success: false, error: \"Failed to update verification status\" };\n            }\n        } else {\n             return { success: false, error: \"Verification code not found in Codeforces First Name. Please ensure you have updated it in your profile settings.\" };\n        }\n    }\n\n    return { success: false, error: \"Failed to fetch Codeforces profile\" };\n}\n\n// Check LeetCode User\nexport async function checkLeetCodeUser(handle: string, ignoreCache = false) {\n    // LeetCode library doesn't expose easy fetch options for caching,\n    // but the contest fetch we added uses fetch().\n    // We can't easily cache the library call 'leetcode.user(handle)' unless we wrap it or if it caches internally.\n    // However, for the graphql fetch we CAN control cache.\n\n    try {\n        const { LeetCode } = await import(\"leetcode-query\");\n        const leetcode = new LeetCode();\n        // This part is using the library, hard to optimize without forking/replacing library usage.\n        // Assuming library does standard fetch, maybe we can't touch it easily.\n        // But for the contest part:\n        const user = await leetcode.user(handle);\n\n        // Fetch Contest Data manually via GraphQL\n        const contestQuery = `\n            query userContestRankingInfo($username: String!) {\n                userContestRanking(username: $username) {\n                    attendedContestsCount\n                    rating\n                    globalRanking\n                    topPercentage\n                    badge {\n                        name\n                    }\n                }\n                userContestRankingHistory(username: $username) {\n                    attended\n                    rating\n                    contest {\n                        title\n                        startTime\n                    }\n                }\n            }\n        `;\n\n        const fetchOptions = ignoreCache\n            ? { cache: 'no-store' as RequestCache }\n            : { next: { revalidate: 3600 } };\n\n        const contestRes = await fetch('https://leetcode.com/graphql', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Referer': 'https://leetcode.com'\n            },\n            body: JSON.stringify({\n                query: contestQuery,\n                variables: { username: handle }\n            }),\n            ...fetchOptions\n        });\n\n        const contestData = await contestRes.json();\n        const contestStats = contestData.data?.userContestRanking;\n        const contestHistory = contestData.data?.userContestRankingHistory?.filter((c: any) => c.attended);\n\n\n        if (user && user.matchedUser) {\n            return {\n                success: true,\n                status: 200,\n                name: user.matchedUser.profile.realName,\n                avatar: user.matchedUser.profile.userAvatar,\n                submitStats: user.matchedUser.submitStats,\n                contestStats: contestStats || null,\n                contestHistory: contestHistory || []\n            };\n        }\n        return { success: false, status: 404 };\n    } catch (e) {\n        console.error(\"LeetCode check error:\", e);\n        return { success: false, status: 500 };\n    }\n}\n\n// Verify LeetCode Ownership\nexport async function verifyLeetCodeOwnership(handle: string, verificationCode: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session || !session.user) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        // Bypass cache\n        const result = await checkLeetCodeUser(handle, true);\n\n        if (result.success && result.name) {\n            // Check if verification code is in the name\n            if (result.name.includes(verificationCode)) {\n                try {\n                    await prisma.user.update({\n                        where: { id: session.user.id },\n                        data: {\n                            leetCodeVerified: true,\n                            leetCodeHandle: handle\n                        }\n                    });\n                    revalidatePath(\"/dashboard/settings\");\n                    revalidateTag(`user-${session.user.id}`,\"max\");\n                    return { success: true };\n                } catch (error) {\n                    console.error(\"Database update error:\", error);\n                    return { success: false, error: \"Failed to update verification status\" };\n                }\n            } else {\n                return { success: false, error: \"Verification code not found in LeetCode Name. Please ensure you have updated it in your profile.\" };\n            }\n        }\n    } catch (error) {\n         return { success: false, error: \"Failed to verify LeetCode profile\" };\n    }\n\n    return { success: false, error: \"Failed to fetch LeetCode profile or name is empty\" };\n}\n","export {checkSessionConflict as '00f4c838ce10f91796a39f1558a3b75432fa49882a'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '409bc5870257fe05de038549e85b0722c4e09c83d4'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80ee7282f708e60661ecc42477a6d2afba42f1d5ed'} from 'ACTIONS_MODULE1'\nexport {updateUserInfo as '401adb5bf0163fd65ff314479b20d5a44231d975ab'} from 'ACTIONS_MODULE1'\nexport {checkCodeChefUser as '6063cd483379a41c765892304ba2c4b6076f9fe25a'} from 'ACTIONS_MODULE2'\nexport {checkCodeforcesUser as '60f28e01956bf5c9d597a2fde65801b141c59b3d64'} from 'ACTIONS_MODULE2'\nexport {checkLeetCodeUser as '602e4c595e83925f2fb97d138792c6c901bc6651d1'} from 'ACTIONS_MODULE2'\nexport {verifyCodeChefOwnership as '6025b82b45ad39180ed262d4932bb5045a0e8415db'} from 'ACTIONS_MODULE2'\nexport {verifyCodeforcesOwnership as '60544a97665a44c2f404559d69526b2c7b9f0295a2'} from 'ACTIONS_MODULE2'\nexport {verifyLeetCodeOwnership as '601fb0da0dfc97022be5342d2cad339f22823cb918'} from 'ACTIONS_MODULE2'\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[1,2]}