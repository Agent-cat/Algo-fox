{"version":3,"sources":["../../../../actions/auth.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../lib/points.ts","../../../../core/services/user.service.ts","../../../../actions/user.action.ts","../../../../lib/cache-utils.ts","../../../../core/services/institution.service.ts","../../../../actions/admin/institution.ts","../../../../actions/institution/staff.ts","../../../../.next-internal/server/app/%28main%29/dashboard/institution/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { headers } from \"next/headers\";\n\nexport async function checkSessionConflict() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return { conflict: false };\n  }\n\n  const activeSessions = await prisma.session.findMany({\n    where: {\n      userId: session.user.id,\n    },\n    select: {\n      id: true,\n      expiresAt: true,\n      userAgent: true,\n      ipAddress: true,\n      token: true, // Need token to identify current session\n    },\n  });\n\n  // Filter out expired sessions just in case, though better-auth likely handles cleanup or assumes valid if in DB\n  const validSessions = activeSessions.filter(s => s.expiresAt > new Date());\n\n  if (validSessions.length > 1) {\n    return {\n      conflict: true,\n      currentSessionToken: session.session.token,\n      sessions: validSessions.map(s => ({\n        ...s,\n        isCurrent: s.token === session.session.token\n      }))\n    };\n  }\n\n  return { conflict: false };\n}\n\nexport async function resolveSessionConflict(action: \"LOGOUT_OTHERS\" | \"LOGOUT_CURRENT\") {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    throw new Error(\"No active session\");\n  }\n\n  if (action === \"LOGOUT_OTHERS\") {\n    // Delete all sessions for this user EXCEPT the current one\n    await prisma.session.deleteMany({\n      where: {\n        userId: session.user.id,\n        token: {\n          not: session.session.token\n        }\n      }\n    });\n    return { success: true, message: \"Other sessions terminated\" };\n  } else if (action === \"LOGOUT_CURRENT\") {\n    // Sign out the current session\n    // We can use auth.api.signOut or just delete the session manually\n    await prisma.session.delete({\n      where: {\n        token: session.session.token\n      }\n    });\n    return { success: true, message: \"Current session terminated\" };\n  }\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","import { Difficulty } from \"@prisma/client\";\n\nexport function getPointsForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n        case \"EASY\":\n            return 5;\n        case \"MEDIUM\":\n            return 10;\n        case \"HARD\":\n            return 15;\n        case \"CONCEPT\":\n            return 0;\n        default:\n            return 0;\n    }\n}\n\n\nexport function getPointsLabel(difficulty: Difficulty): string {\n    const points = getPointsForDifficulty(difficulty);\n    return `${points} pts`;\n}\n\n","\nimport { prisma } from \"@/lib/prisma\";\nimport { getPointsForDifficulty } from \"@/lib/points\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 30; // 30 seconds\n\nexport class UserService {\n\n    /*\n     * GETS USERS TOTAL SCORE (cached for 30 seconds)\n     * CACHE IS INVALIDATD WHEN USER SOLVES A PROBLEM\n    */\n    static async getUserScore(userId: string): Promise<number> {\n        const cacheKey = `user-score-${userId}`;\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return parseInt(cached, 10);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: { totalScore: true }\n        });\n\n        const score = user?.totalScore || 0;\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, score.toString());\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n\n        return score;\n    }\n\n\n    /**\n     * Recalculate user's total score based on their solved problems\n     * This fixes any incorrect scores in the database\n     */\n    static async recalculateUserScore(userId: string): Promise<{ success: boolean; newScore: number }> {\n        try {\n            // Get all unique problems the user has solved (ACCEPTED SUBMIT mode only)\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: {\n                    problemId: true,\n                    problem: {\n                        select: {\n                            difficulty: true\n                        }\n                    }\n                },\n                distinct: [\"problemId\"]\n            });\n\n            // Calculate total score based on difficulty\n            let totalScore = 0;\n            for (const submission of solvedSubmissions) {\n                const points = getPointsForDifficulty(submission.problem.difficulty);\n                totalScore += points;\n            }\n\n            // Update user's totalScore in the database\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    totalScore\n                }\n            });\n\n            // Invalidate cache\n            try {\n                await redis.del(`user-score-${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate user score cache:\", error);\n            }\n\n            return { success: true, newScore: totalScore };\n        } catch (error) {\n            console.error(\"Failed to recalculate user score:\", error);\n            throw new Error(\"Failed to recalculate user score\");\n        }\n    }\n\n    /*\n     * COMPLETE USER ONBOARDING PROCESS\n     * UPDATES USER PROFILE INFORMATION AND MARKS ONBOARDING AS COMPLETED\n    */\n    static async completeOnboarding(userId: string, data: {\n        name?: string;\n        bio?: string;\n        collegeId: string;\n        year?: string;\n        leetCodeHandle?: string;\n        codeChefHandle?: string;\n        hackerrankHandle?: string; // Kept for type compatibility if needed, but mapped to codeforces\n        codeforcesHandle?: string;\n        githubHandle?: string;\n    }): Promise<{ success: boolean; error?: string }> {\n        try {\n            await prisma.user.update({\n                where: { id: userId },\n                data: {\n                    name: data.name,\n                    collegeId: data.collegeId || null,\n                    year: data.year ? parseInt(data.year) : null,\n                    bio: data.bio || null,\n                    leetCodeHandle: data.leetCodeHandle || null,\n                    codeChefHandle: data.codeChefHandle || null,\n                    codeforcesHandle: data.codeforcesHandle || data.hackerrankHandle || null,\n                    githubHandle: data.githubHandle || null,\n                    onboardingCompleted: true\n                }\n            });\n\n            // Invalidate dashboard cache\n            try {\n                await redis.del(`dashboard:stats:${userId}`);\n            } catch (error) {\n                console.error(\"Failed to invalidate dashboard cache:\", error);\n            }\n\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to complete onboarding:\", error);\n            return { success: false, error: \"Failed to complete onboarding\" };\n        }\n    }\n}\n","\"use server\";\n\nimport { UserService } from \"@/core/services/user.service\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n/**\n * Get user's total score (cached for 5 minutes)\n * Cache is invalidated when user solves a problem via updateTag\n */\n\nexport async function getUserScore(): Promise<number> {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return 0;\n    }\n\n    const userId = session.user.id;\n\n    cacheTag(`user-score-${userId}`, `user-${userId}`);\n\n    return UserService.getUserScore(userId);\n}\n\n/**\n * Recalculate user's total score based on their solved problems\n * This fixes any incorrect scores in the database\n */\nexport async function recalculateUserScore(): Promise<{ success: boolean; newScore: number }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const userId = session.user.id;\n\n    return UserService.recalculateUserScore(userId);\n}\n\n/**\n * Complete user onboarding process\n * Updates user profile information and marks onboarding as complete\n */\nexport async function completeOnboarding(data: {\n    name?: string;\n    bio?: string;\n    collegeId: string;\n    year?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    const res = await UserService.completeOnboarding(userId, data);\n\n    if (res.success) {\n        // Invalidate Redis cache (redundant but good to have here too)\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n    }\n\n    return res;\n}\n\n/**\n * Update user profile information\n */\nexport async function updateUserInfo(data: {\n    name?: string;\n    bio?: string;\n    leetCodeHandle?: string;\n    codeChefHandle?: string;\n    hackerrankHandle?: string;\n    codeforcesHandle?: string;\n    githubHandle?: string;\n}): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Fetch current user to check for changes\n        const currentUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                codeChefHandle: true,\n                codeforcesHandle: true,\n                leetCodeHandle: true,\n            }\n        });\n\n        const updateData: any = {\n            name: data.name,\n            bio: data.bio,\n            leetCodeHandle: data.leetCodeHandle,\n            codeChefHandle: data.codeChefHandle,\n            codeforcesHandle: data.codeforcesHandle,\n            githubHandle: data.githubHandle,\n        };\n\n        // Reset verification if handle changed\n        if (currentUser) {\n            if (data.codeChefHandle !== undefined && data.codeChefHandle !== currentUser.codeChefHandle) {\n                updateData.codeChefVerified = false;\n            }\n            if (data.codeforcesHandle !== undefined && data.codeforcesHandle !== currentUser.codeforcesHandle) {\n                updateData.codeforcesVerified = false;\n            }\n            if (data.leetCodeHandle !== undefined && data.leetCodeHandle !== currentUser.leetCodeHandle) {\n                updateData.leetCodeVerified = false;\n            }\n        }\n\n        await prisma.user.update({\n            where: { id: userId },\n            data: updateData\n        });\n\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate dashboard redis cache:\", error);\n        }\n\n        revalidatePath(\"/dashboard\");\n        revalidatePath(\"/dashboard/settings\"); // Added to refresh settings page\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag(`dashboard-${userId}`);\n        updateTag('dashboard-stats');\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to update user info:\", error);\n        return { success: false, error: \"Failed to update profile\" };\n    }\n}\n\n/**\n * Sync user profile and stats\n * Clears all caches related to the user and revalidates dashboard\n */\nexport async function syncUserProfile(): Promise<{ success: boolean; error?: string }> {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const userId = session.user.id;\n\n    try {\n        // Invalidate Redis cache\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n            await redis.del(`user-score-${userId}`);\n        } catch (error) {\n            console.error(\"Failed to invalidate redis cache during sync:\", error);\n        }\n\n        // Revalidate Next.js cache\n        revalidatePath(\"/dashboard\");\n        updateTag(`user-${userId}`);\n        updateTag(`user-score-${userId}`);\n        updateTag('dashboard-stats');\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return { success: false, error: \"Failed to sync profile\" };\n    }\n}\n\n/**\n * Get user settings data (cached)\n */\nexport async function getUserSettings() {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session?.user?.id) {\n        return null;\n    }\n\n    const userId = session.user.id;\n    cacheTag(`user-${userId}`);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n            institution: true\n        }\n    });\n\n    if (!user) return null;\n\n    return {\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        image: user.image,\n        bio: user.bio,\n        institutionName: user.institution?.name\n    };\n}\n","import redis from \"./redis\";\n\n/**\n * Cache configuration for different data types\n */\nexport const CACHE_CONFIG = {\n  // Short-lived cache for frequently changing data\n  SHORT: { ttl: 30, stale: 15 },\n  // Medium cache for moderately changing data\n  MEDIUM: { ttl: 120, stale: 60 },\n  // Long cache for rarely changing data\n  LONG: { ttl: 600, stale: 300 },\n  // Very long cache for static-ish data\n  STATIC: { ttl: 3600, stale: 1800 },\n} as const;\n\n/**\n * Generate a consistent cache key\n */\nexport function cacheKey(prefix: string, ...parts: (string | number)[]): string {\n  return `algofox:${prefix}:${parts.join(\":\")}`;\n}\n\n/**\n * Get data from Redis cache with automatic JSON parsing\n */\nexport async function getFromCache<T>(key: string): Promise<T | null> {\n  try {\n    const data = await redis.get(key);\n    if (!data) return null;\n    return JSON.parse(data) as T;\n  } catch (error) {\n    console.error(\"[Cache] Get error:\", error);\n    return null;\n  }\n}\n\n/**\n * Set data in Redis cache with automatic JSON serialization\n */\nexport async function setInCache<T>(\n  key: string,\n  data: T,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<void> {\n  try {\n    await redis.setex(key, ttlSeconds, JSON.stringify(data));\n  } catch (error) {\n    console.error(\"[Cache] Set error:\", error);\n  }\n}\n\n/**\n * Delete a cache key\n */\nexport async function deleteFromCache(key: string): Promise<void> {\n  try {\n    await redis.del(key);\n  } catch (error) {\n    console.error(\"[Cache] Delete error:\", error);\n  }\n}\n\n/**\n * Delete multiple cache keys by pattern\n */\nexport async function deleteByPattern(pattern: string): Promise<void> {\n  try {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  } catch (error) {\n    console.error(\"[Cache] Delete pattern error:\", error);\n  }\n}\n\n/**\n * Get or set pattern - tries cache first, falls back to fetcher\n */\nexport async function cachedFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlSeconds: number = CACHE_CONFIG.MEDIUM.ttl\n): Promise<T> {\n  // Try cache first\n  const cached = await getFromCache<T>(key);\n  if (cached !== null) {\n    return cached;\n  }\n\n  // Fetch fresh data\n  const data = await fetcher();\n\n  // Cache the result (don't await to not block response)\n  setInCache(key, data, ttlSeconds).catch(() => {});\n\n  return data;\n}\n\n/**\n * Invalidate cache keys for an entity\n */\nexport async function invalidateCache(\n  prefix: string,\n  ...ids: (string | number)[]\n): Promise<void> {\n  const pattern = `algofox:${prefix}:${ids.length > 0 ? ids.join(\":\") : \"*\"}`;\n  await deleteByPattern(pattern);\n}\n","import { prisma } from \"@/lib/prisma\";\n\nexport class InstitutionService {\n    /**\n     * Get all institutions with counts of users and classrooms\n     */\n    static async getInstitutions() {\n        const institutions = await prisma.institution.findMany({\n            include: {\n                _count: {\n                    select: {\n                        users: true,\n                        classrooms: true,\n                    },\n                },\n                users: {\n                    where: {\n                        role: \"INSTITUTION_MANAGER\",\n                    },\n                    select: {\n                        name: true,\n                    },\n                    take: 1,\n                },\n            },\n            orderBy: {\n                createdAt: \"desc\",\n            },\n        });\n\n        return institutions.map((inst) => ({\n            ...inst,\n            managerName: inst.users[0]?.name || \"Unassigned\",\n        }));\n    }\n\n    /**\n     * Get an institution by ID with users and classrooms\n     */\n    static async getInstitutionById(id: string) {\n        return prisma.institution.findUnique({\n            where: { id },\n            include: {\n                users: {\n                    where: {\n                        role: \"INSTITUTION_MANAGER\",\n                    },\n                },\n                classrooms: true,\n                _count: {\n                    select: {\n                        users: true,\n                        classrooms: true,\n                    },\n                },\n            },\n        });\n    }\n\n    /**\n     * Update institution details\n     */\n    static async updateInstitution(id: string, data: {\n        name?: string;\n        logo?: string | null;\n        domain?: string | null;\n    }) {\n        return prisma.institution.update({\n            where: { id },\n            data,\n        });\n    }\n\n    /**\n     * Delete an institution\n     */\n    static async deleteInstitution(id: string) {\n        return prisma.institution.delete({\n            where: { id },\n        });\n    }\n\n    /**\n     * Get detailed stats for an institution\n     */\n    static async getInstitutionStats(id: string) {\n        const stats = await prisma.user.groupBy({\n            by: ['role'],\n            where: {\n                institutionId: id,\n            },\n            _count: true,\n        });\n\n        const classroomCount = await prisma.classroom.count({\n            where: { institutionId: id },\n        });\n\n        const roleCounts = stats.reduce((acc, curr) => {\n            acc[curr.role as string] = curr._count;\n            return acc;\n        }, {} as Record<string, number>);\n\n        return {\n            students: roleCounts[\"STUDENT\"] || 0,\n            teachers: roleCounts[\"TEACHER\"] || 0,\n            contestManagers: roleCounts[\"CONTEST_MANAGER\"] || 0,\n            classrooms: classroomCount,\n        };\n    }\n}\n","\"use server\";\n\nimport { InstitutionService } from \"@/core/services/institution.service\";\nimport { z } from \"zod\";\nimport { revalidatePath, revalidateTag } from \"next/cache\";\nimport redis from \"@/lib/redis\";\n\nconst institutionSchema = z.object({\n    name: z.string().min(2, \"Name must be at least 2 characters\"),\n    slug: z.string().min(2, \"Slug must be at least 2 characters\").regex(/^[a-z0-9-]+$/, \"Slug must be lowercase alphanumeric and hyphens\"),\n    logo: z.string().url().optional().or(z.literal(\"\")),\n    domain: z.string().optional().or(z.literal(\"\")),\n});\n\nconst updateInstitutionSchema = institutionSchema.partial();\n\nexport async function getInstitutions() {\n    try {\n        const institutions = await InstitutionService.getInstitutions();\n        return { success: true, institutions };\n    } catch (error) {\n        console.error(\"Failed to fetch institutions:\", error);\n        return { success: false, error: \"Failed to fetch institutions\" };\n    }\n}\n\nexport async function getInstitutionById(id: string) {\n    try {\n        const institution = await InstitutionService.getInstitutionById(id);\n        if (!institution) return { success: false, error: \"Institution not found\" };\n        return { success: true, institution };\n    } catch (error) {\n        console.error(\"Failed to fetch institution:\", error);\n        return { success: false, error: \"Failed to fetch institution\" };\n    }\n}\n\n\n// Redefining create in Service for clarity\nexport async function createInstitutionAction(data: z.infer<typeof institutionSchema>) {\n    try {\n        const validatedData = institutionSchema.parse(data);\n        // Directly use prisma for create if not in service yet\n        const { prisma } = await import(\"@/lib/prisma\");\n        const institution = await prisma.institution.create({\n            data: {\n                name: validatedData.name,\n                slug: validatedData.slug,\n                logo: validatedData.logo || null,\n                domain: validatedData.domain || null,\n            },\n        });\n\n        revalidatePath(\"/admin/institutions\");\n        return { success: true, data: institution };\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return { success: false, error: error.issues[0].message };\n        }\n        console.error(\"Failed to create institution:\", error);\n        return { success: false, error: \"Failed to create institution\" };\n    }\n}\n\nexport async function updateInstitutionAction(id: string, data: z.infer<typeof updateInstitutionSchema>) {\n    try {\n        const validatedData = updateInstitutionSchema.parse(data);\n        const institution = await InstitutionService.updateInstitution(id, {\n            ...validatedData,\n            logo: validatedData.logo || undefined,\n            domain: validatedData.domain || undefined,\n        });\n\n        revalidatePath(\"/admin/institutions\");\n        revalidatePath(`/admin/institutions/${id}`);\n        return { success: true, data: institution };\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return { success: false, error: error.issues[0].message };\n        }\n        console.error(\"Failed to update institution:\", error);\n        return { success: false, error: \"Failed to update institution\" };\n    }\n}\n\nexport async function assignInstitutionManager(email: string, institutionId: string) {\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n        const user = await prisma.user.findUnique({\n            where: { email },\n        });\n\n        if (!user) {\n            return { success: false, error: \"User not found\" };\n        }\n\n        const updatedUser = await prisma.user.update({\n            where: { id: user.id },\n            data: {\n                role: \"INSTITUTION_MANAGER\",\n                institutionId: institutionId,\n            },\n        });\n\n        revalidatePath(\"/admin/users\");\n        revalidatePath(`/admin/institutions/${institutionId}`);\n        revalidateTag(`dashboard-${user.id}`, \"max\");\n        await redis.del(`dashboard:stats:${user.id}`);\n\n        return { success: true, data: updatedUser };\n    } catch (error) {\n        console.error(\"Failed to assign institution manager:\", error);\n        return { success: false, error: \"Failed to assign institution manager\" };\n    }\n}\n\nexport async function searchUsersByEmail(query: string) {\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n        const users = await prisma.user.findMany({\n            where: {\n                email: {\n                    contains: query,\n                    mode: \"insensitive\",\n                },\n            },\n            select: {\n                id: true,\n                email: true,\n                name: true,\n            },\n            take: 5,\n        });\n\n        return { success: true, users };\n    } catch (error) {\n        console.error(\"Failed to search users:\", error);\n        return { success: false, error: \"Failed to search users\" };\n    }\n}\n\nexport async function removeInstitutionManager(userId: string, institutionId: string) {\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n\n        // Downgrade to STUDENT and remove institution assignment\n        await prisma.user.update({\n            where: { id: userId },\n            data: {\n                role: \"STUDENT\",\n                institutionId: null,\n            },\n        });\n\n        revalidatePath(`/admin/institutions/${institutionId}`);\n        revalidateTag(`dashboard-${userId}`, \"max\");\n        await redis.del(`dashboard:stats:${userId}`);\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to remove manager:\", error);\n        return { success: false, error: \"Failed to remove administrative access\" };\n    }\n}\n\nexport async function deleteInstitutionAction(id: string) {\n    try {\n        // First disconnect all users from this institution\n        const { prisma } = await import(\"@/lib/prisma\");\n\n        // This is a safety measure to avoid orphan institution IDs on users\n        await prisma.user.updateMany({\n            where: { institutionId: id },\n            data: { institutionId: null },\n        });\n\n        await InstitutionService.deleteInstitution(id);\n\n        revalidatePath(\"/admin/institutions\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to delete institution:\", error);\n        return { success: false, error: \"Failed to delete institution. Ensure it has no active classrooms.\" };\n    }\n}\n\nexport async function getInstitutionUsers(institutionId: string, page: number = 1, searchQuery: string = \"\") {\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n        const limit = 20;\n        const skip = (page - 1) * limit;\n\n        const where: any = {\n            institutionId,\n        };\n\n        if (searchQuery) {\n            where.OR = [\n                { name: { contains: searchQuery, mode: \"insensitive\" } },\n                { email: { contains: searchQuery, mode: \"insensitive\" } },\n            ];\n        }\n\n        const [users, total] = await Promise.all([\n            prisma.user.findMany({\n                where,\n                skip,\n                take: limit,\n                orderBy: { createdAt: \"desc\" },\n                select: {\n                    id: true,\n                    name: true,\n                    email: true,\n                    role: true,\n                    createdAt: true,\n                },\n            }),\n            prisma.user.count({ where }),\n        ]);\n\n        return { success: true, users, total };\n    } catch (error) {\n        console.error(\"Failed to fetch institution users:\", error);\n        return { success: false, error: \"Failed to fetch institution users\" };\n    }\n}\n\nexport async function removeUserFromInstitution(userId: string) {\n    try {\n        const { prisma } = await import(\"@/lib/prisma\");\n\n        const user = await prisma.user.update({\n            where: { id: userId },\n            data: {\n                institutionId: null,\n                // If they were a manager, teacher, etc. specifically for this institution,\n                // we might want to downgrade them to STUDENT, but for now we'll just remove the link.\n            },\n        });\n\n        revalidateTag(`user-${userId}`, \"max\");\n        revalidateTag(`dashboard-${userId}`, \"max\");\n\n        // Clear redis if it exists\n        try {\n            const redis = (await import(\"@/lib/redis\")).default;\n            await redis.del(`dashboard:stats:${userId}`);\n        } catch (e) {}\n\n        return { success: true };\n    } catch (error) {\n        console.error(\"Failed to remove user from institution:\", error);\n        return { success: false, error: \"Failed to remove user from institution\" };\n    }\n}\n","\"use server\";\n\nimport { z } from \"zod\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath, revalidateTag, unstable_cache } from \"next/cache\";\nimport { cacheKey, cachedFetch, CACHE_CONFIG } from \"@/lib/cache-utils\";\n\nconst staffSchema = z.object({\n  email: z.email(),\n  role: z.enum([\"TEACHER\", \"CONTEST_MANAGER\"]),\n  institutionId: z.string(),\n});\n\nexport async function addStaffMember(data: z.infer<typeof staffSchema>) {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) {\n      return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    // Security check: Only institution managers or admins can add staff\n    if (currentUser.role !== \"ADMIN\") {\n      if (\n        currentUser.role !== \"INSTITUTION_MANAGER\" ||\n        currentUser.institutionId !== data.institutionId\n      ) {\n        return { success: false, error: \"Unauthorized\" };\n      }\n    }\n\n    const validatedData = staffSchema.parse(data);\n\n    const targetUser = await prisma.user.findUnique({\n      where: { email: validatedData.email },\n    });\n\n    if (!targetUser) {\n      return {\n        success: false,\n        error: \"User not found. They must sign up first.\",\n      };\n    }\n\n    const updatedUser = await prisma.user.update({\n      where: { id: targetUser.id },\n      data: {\n        role: validatedData.role,\n        institutionId: validatedData.institutionId,\n      },\n    });\n\n    // Invalidate caches\n    revalidateTag(`institution-staff-${validatedData.institutionId}`, \"max\");\n    revalidateTag(`institution-stats-${validatedData.institutionId}`, \"max\");\n    revalidateTag(`user-${targetUser.id}`, \"max\");\n    revalidatePath(\"/dashboard/institution\");\n\n    return { success: true, user: updatedUser };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, error: error.issues[0].message };\n    }\n    console.error(\"Failed to add staff member:\", error);\n    return { success: false, error: \"Failed to add staff member\" };\n  }\n}\n\n/**\n * Get institution staff members (CACHED)\n */\nexport async function getInstitutionStaff(institutionId: string) {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) {\n      return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    // Security check\n    if (currentUser.role !== \"ADMIN\") {\n      if (\n        currentUser.role !== \"INSTITUTION_MANAGER\" ||\n        currentUser.institutionId !== institutionId\n      ) {\n        return { success: false, error: \"Unauthorized\" };\n      }\n    }\n\n    const fetchStaff = unstable_cache(\n      async () => {\n        return await prisma.user.findMany({\n          where: {\n            institutionId,\n            role: {\n              in: [\"TEACHER\", \"CONTEST_MANAGER\"],\n            },\n          },\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            role: true,\n            image: true,\n          },\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        });\n      },\n      [`institution-staff-${institutionId}`],\n      { tags: [`institution-staff-${institutionId}`], revalidate: 120 }\n    );\n\n    const staff = await fetchStaff();\n    return { success: true, staff };\n  } catch (error) {\n    console.error(\"Failed to fetch institution staff:\", error);\n    return { success: false, error: \"Failed to fetch staff\" };\n  }\n}\n\n/**\n * Get institution statistics (CACHED with Redis for hot data)\n */\nexport async function getInstitutionStatsAction(institutionId: string) {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) {\n      return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n\n    // Security check\n    if (currentUser.role !== \"ADMIN\") {\n      if (\n        currentUser.role !== \"INSTITUTION_MANAGER\" ||\n        currentUser.institutionId !== institutionId\n      ) {\n        return { success: false, error: \"Unauthorized\" };\n      }\n    }\n\n    // Use Redis cache for stats (frequently accessed, computed data)\n    const statsCacheKey = cacheKey(\"institution-stats\", institutionId);\n\n    const stats = await cachedFetch(\n      statsCacheKey,\n      async () => {\n        // Parallel queries for better performance\n        const [roleCounts, classroomCount] = await Promise.all([\n          prisma.user.groupBy({\n            by: ['role'],\n            where: { institutionId },\n            _count: true,\n          }),\n          prisma.classroom.count({\n            where: { institutionId },\n          })\n        ]);\n\n        const roleCountsMap = roleCounts.reduce((acc, curr) => {\n          acc[curr.role as string] = curr._count;\n          return acc;\n        }, {} as Record<string, number>);\n\n        return {\n          students: roleCountsMap[\"STUDENT\"] || 0,\n          teachers: roleCountsMap[\"TEACHER\"] || 0,\n          contestManagers: roleCountsMap[\"CONTEST_MANAGER\"] || 0,\n          classrooms: classroomCount,\n        };\n      },\n      CACHE_CONFIG.LONG.ttl // 10 minutes\n    );\n\n    return { success: true, stats };\n  } catch (error) {\n    console.error(\"Failed to fetch institution stats:\", error);\n    return { success: false, error: \"Failed to fetch stats\" };\n  }\n}\n\nexport async function deleteStaffMember(userId: string) {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    });\n\n    if (!session?.user) {\n      return { success: false, error: \"Unauthorized\" };\n    }\n\n    const currentUser = session.user as any;\n    const targetUser = await prisma.user.findUnique({ where: { id: userId } });\n\n    if (!targetUser) return { success: false, error: \"User not found\" };\n\n    // Security check\n    if (currentUser.role !== \"ADMIN\") {\n      if (\n        currentUser.role !== \"INSTITUTION_MANAGER\" ||\n        currentUser.institutionId !== targetUser.institutionId\n      ) {\n        return { success: false, error: \"Unauthorized\" };\n      }\n    }\n\n    const institutionId = targetUser.institutionId;\n\n    await prisma.user.update({\n        where: { id: userId },\n        data: {\n            institutionId: null,\n            role: \"STUDENT\"\n        }\n    });\n\n    // Invalidate caches\n    if (institutionId) {\n      revalidateTag(`institution-staff-${institutionId}`, \"max\");\n      revalidateTag(`institution-stats-${institutionId}`, \"max\");\n    }\n    revalidatePath(\"/dashboard/institution\");\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Failed to remove staff member:\", error);\n    return { success: false, error: \"Failed to remove member\" };\n  }\n}\n\n/**\n * Get institution users with pagination (CACHED)\n */\nexport async function getInstitutionUsers(\n    institutionId: string,\n    role: \"TEACHER\" | \"CONTEST_MANAGER\" | \"STUDENT\",\n    page: number = 1,\n    limit: number = 20\n) {\n    try {\n      const session = await auth.api.getSession({\n        headers: await headers(),\n      });\n\n      if (!session?.user) {\n        return { success: false, error: \"Unauthorized\" };\n      }\n\n      const currentUser = session.user as any;\n\n      if (currentUser.role !== \"ADMIN\") {\n        if (\n          currentUser.role !== \"INSTITUTION_MANAGER\" ||\n          currentUser.institutionId !== institutionId\n        ) {\n          return { success: false, error: \"Unauthorized\" };\n        }\n      }\n\n      const skip = (page - 1) * limit;\n\n      const fetchUsers = unstable_cache(\n        async () => {\n          const [users, total] = await Promise.all([\n            prisma.user.findMany({\n              where: {\n                institutionId,\n                role: role,\n              },\n              select: {\n                id: true,\n                name: true,\n                email: true,\n                role: true,\n                image: true,\n                createdAt: true,\n                _count: {\n                    select: {\n                        taughtClassrooms: true\n                    }\n                }\n              },\n              orderBy: {\n                createdAt: \"desc\",\n              },\n              skip,\n              take: limit\n            }),\n            prisma.user.count({\n                where: {\n                    institutionId,\n                    role: role\n                }\n            })\n          ]);\n\n          return { users, total };\n        },\n        [`institution-users-${institutionId}-${role}-page-${page}`],\n        { tags: [`institution-users-${institutionId}-${role}`], revalidate: 120 }\n      );\n\n      const { users, total } = await fetchUsers();\n\n      return {\n          success: true,\n          users,\n          pagination: {\n              total,\n              pages: Math.ceil(total / limit),\n              current: page,\n              limit\n          }\n      };\n    } catch (error) {\n      console.error(`Failed to fetch institution ${role}s:`, error);\n      return { success: false, error: \"Failed to fetch users\" };\n    }\n  }\n","export {checkSessionConflict as '00f4c838ce10f91796a39f1558a3b75432fa49882a'} from 'ACTIONS_MODULE0'\nexport {resolveSessionConflict as '409bc5870257fe05de038549e85b0722c4e09c83d4'} from 'ACTIONS_MODULE0'\nexport {getUserScore as '80ee7282f708e60661ecc42477a6d2afba42f1d5ed'} from 'ACTIONS_MODULE1'\nexport {addStaffMember as '4013a4d902d2a4a7f58cf6a44f5223e4d3eef11604'} from 'ACTIONS_MODULE2'\nexport {getInstitutionStaff as '40746d22ebe5805b14354bb221ceb84b19512bc8c4'} from 'ACTIONS_MODULE2'\nexport {getInstitutionStatsAction as '40a1f279a70ff23992b6df0c58ef1c770b37e4a109'} from 'ACTIONS_MODULE2'\nexport {deleteStaffMember as '40e4a75cb44b36f49c5b25207c30f03e98364fa02b'} from 'ACTIONS_MODULE2'\nexport {getInstitutionUsers as '7817dc0ea1b97a601e63ee51f7da7c87f2574923c7'} from 'ACTIONS_MODULE2'\nexport {addStaffMember as '4013a4d902d2a4a7f58cf6a44f5223e4d3eef11604'} from 'ACTIONS_MODULE2'\nexport {getInstitutionStaff as '40746d22ebe5805b14354bb221ceb84b19512bc8c4'} from 'ACTIONS_MODULE2'\nexport {searchUsersByEmail as '405e04aceede4e9292ab1f13da65c7c83541f66504'} from 'ACTIONS_MODULE3'\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[1,2]}