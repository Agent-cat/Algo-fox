{"version":3,"sources":["../../../../core/services/problem.service.ts","../../../../actions/problems.ts"],"sourcesContent":["\nimport { prisma } from \"@/lib/prisma\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport redis from \"@/lib/redis\";\n\nconst CACHE_TTL = 300; // 5 minutes\nconst PROBLEM_CACHE_TTL = 3600; // 1 hour\n\n// CACHE KEY HELPERS\nconst getProblemsCacheKey = (type: ProblemType, domain: ProblemDomain, page: number, diff?: Difficulty, tags: string[] = []) =>\n    `problems:list:${domain}:${type}:page:${page}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`;\nconst getAdminProblemsCacheKey = (domain: string | undefined, page: number) =>\n    `admin:problems:${domain || 'all'}:page:${page}`;\nconst getProblemCacheKey = (slug: string) => `problem:${slug}`;\n\nexport class ProblemService {\n\n    // CACHED FETCHER FOR PUBLIC PROBLEM LIST\n    private static async getCachedProblems(page: number, pageSize: number, type: ProblemType, domain: ProblemDomain = \"DSA\", diff?: Difficulty, tags: string[] = [], cursor?: string) {\n        // We use page for cache key primarily, but if cursor is used, it's for infinite scroll which often is bypass-cache or unique key\n        const cacheKey = cursor\n            ? `problems:list:${domain}:${type}:cursor:${cursor}:pageSize:${pageSize}:diff:${diff || 'all'}:tags:${tags.sort().join(',')}`\n            : getProblemsCacheKey(type, domain, page, diff, tags);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const query: any = {\n            where: {\n                type,\n                domain,\n                difficulty: diff,\n                hidden: false,\n                tags: tags.length > 0 ? {\n                    some: {\n                        slug: { in: tags }\n                    }\n                } : undefined\n            },\n            take: pageSize,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        };\n\n        if (cursor) {\n            query.cursor = { id: cursor };\n            query.skip = 1; // Skip the item already fetched\n        } else {\n            query.skip = (page - 1) * pageSize;\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany(query),\n            prisma.problem.count({\n                where: {\n                    type,\n                    domain,\n                    difficulty: diff,\n                    hidden: false,\n                    tags: tags.length > 0 ? {\n                        some: {\n                            slug: { in: tags }\n                        }\n                    } : undefined\n                }\n            })\n        ]);\n\n        const result = { problems, total };\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // GETTING PUBLIC PROBLEMS\n    static async getProblems(\n        page: number = 1,\n        pageSize: number = 10,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string,\n        diff?: Difficulty,\n        tags: string[] = [],\n        cursor?: string\n    ) {\n        // FETCHING PUBLIC DATA (CACHED)\n        const { problems, total } = await this.getCachedProblems(page, pageSize, type, domain, diff, tags, cursor);\n\n        // IF USER IS LOGGED IN, FETCHING THEIR SOLVED STATUS FOR THESE SPECIFIC PROBLEMS\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map((p: any) => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        // MERGING DATA\n        const problemsWithStats = problems.map((p: any) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return {\n            problems: problemsWithStats,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n    }\n\n    // GETTING ADMIN PROBLEMS\n    static async getAdminProblems(\n        page: number = 1,\n        pageSize: number = 50,\n        domain?: ProblemDomain,\n        excludeDifficulty?: Difficulty,\n        type?: ProblemType\n    ) {\n        const cacheKey = getAdminProblemsCacheKey(domain, page);\n        // Note: cache key doesn't include excludeDifficulty which could be an issue if we vary it often,\n        // but for now only one usage pattern exists per page.\n        // Ideally we should append it to cache key but let's keep it simple as per plan.\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n                // If we have cached data, we might need to filter it manually if the cache key doesn't support variations\n                // But for now let's assume cache key strategy needs update if we want perfect caching.\n                // However, user just wants filtering. Let's bypass cache if we have specific filter or update cache key.\n                // Actually, let's just proceed with fetching fresh if we use filters or rely on the query.\n                // Given the current cache implementation is simple, let's just do the query.\n\n                // return JSON.parse(cached); // Disabling cache return for filtered requests for safety or we update key\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const skip = (page - 1) * pageSize;\n        const where: any = domain ? { domain } : {};\n\n        if (type) {\n            where.type = type;\n        } else {\n            where.type = { not: \"CONTEST\" };\n        }\n\n        if (excludeDifficulty) {\n            where.difficulty = { not: excludeDifficulty };\n        }\n\n        const [problems, total] = await Promise.all([\n            prisma.problem.findMany({\n                where,\n                skip,\n                take: pageSize,\n                orderBy: { createdAt: 'desc' },\n                select: {\n                    id: true,\n                    title: true,\n                    slug: true,\n                    difficulty: true,\n                    hidden: true,\n                    score: true,\n                    type: true,\n                    domain: true,\n                    createdAt: true,\n                    updatedAt: true,\n                }\n            }),\n            prisma.problem.count({ where })\n        ]);\n\n        const result = {\n            problems,\n            totalPages: Math.ceil(total / pageSize),\n            currentPage: page,\n            total\n        };\n\n        try {\n            await redis.setex(cacheKey, CACHE_TTL, JSON.stringify(result));\n        } catch (error) {\n            console.error(\"Redis set error:\", error);\n        }\n        return result;\n    }\n\n    // SEARCHING FOR PROBLEMS\n    static async searchProblems(\n        term: string,\n        type: ProblemType = \"PRACTICE\",\n        domain: ProblemDomain = \"DSA\",\n        userId?: string\n    ) {\n        const problems = await prisma.problem.findMany({\n            where: {\n                type,\n                domain,\n                hidden: false,\n                title: {\n                    contains: term,\n                    mode: 'insensitive'\n                }\n            },\n            take: 10,\n            orderBy: { createdAt: 'desc' },\n            select: {\n                id: true,\n                title: true,\n                slug: true,\n                difficulty: true,\n                score: true,\n                solved: true,\n                createdAt: true,\n                type: true,\n                _count: {\n                    select: { submissions: true }\n                },\n                tags: {\n                    select: {\n                        name: true,\n                        slug: true\n                    }\n                }\n            }\n        });\n\n        let solvedSet = new Set<string>();\n        if (userId && problems.length > 0) {\n            const problemIds = problems.map(p => p.id);\n            const solvedSubmissions = await prisma.submission.findMany({\n                where: {\n                    userId,\n                    problemId: { in: problemIds },\n                    status: \"ACCEPTED\",\n                    mode: \"SUBMIT\"\n                },\n                select: { problemId: true },\n                distinct: [\"problemId\"]\n            });\n            solvedSet = new Set(solvedSubmissions.map(s => s.problemId));\n        }\n\n        const problemsWithStats = problems.map((p) => {\n            return {\n                ...p,\n                isSolved: solvedSet.has(p.id),\n                acceptance: p._count.submissions > 0\n                    ? ((p.solved || 0) / p._count.submissions) * 100\n                    : 0,\n            };\n        });\n\n        return { problems: problemsWithStats };\n    }\n\n    // CACHED FETCHER FOR SINGLE PROBLEM\n    private static async getCachedProblem(slug: string) {\n        const cacheKey = getProblemCacheKey(slug);\n\n        try {\n            const cached = await redis.get(cacheKey);\n            if (cached) {\n\n                return JSON.parse(cached);\n            }\n        } catch (error) {\n            console.error(\"Redis get error:\", error);\n        }\n\n        const problem = await prisma.problem.findUnique({\n            where: { slug },\n            include: {\n                testCases: true,\n                user: { select: { name: true, image: true } },\n                tags: { select: { name: true, slug: true } },\n                functionTemplates: true // Include for DSA function template boilerplates\n            }\n        });\n\n        if (problem) {\n            try {\n                await redis.setex(cacheKey, PROBLEM_CACHE_TTL, JSON.stringify(problem));\n            } catch (error) {\n                console.error(\"Redis set error:\", error);\n            }\n        }\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY SLUG CACHED\n    static async getProblem(slug: string) {\n        const problem = await this.getCachedProblem(slug);\n        return problem;\n    }\n\n    // GETTING A PROBLEM BY ID\n    static async getProblemById(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({\n                where: { id },\n                include: {\n                    testCases: true,\n                    tags: { select: { name: true, slug: true } },\n                    functionTemplates: true\n                }\n            });\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to get problem by id:\", error);\n            return { success: false, error: \"Failed to get problem by id\" };\n        }\n    }\n\n    // GETTING NEXT PROBLEM\n    static async getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const nextProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        lt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'desc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return nextProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get next problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING PREVIOUS PROBLEM\n    static async getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n        try {\n            const prevProblem = await prisma.problem.findFirst({\n                where: {\n                    domain,\n                    type,\n                    hidden: false,\n                    createdAt: {\n                        gt: currentCreatedAt\n                    }\n                },\n                orderBy: {\n                    createdAt: 'asc'\n                },\n                select: {\n                    slug: true\n                }\n            });\n            return prevProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get previous problem:\", error);\n            return null;\n        }\n    }\n\n    // GETTING RANDOM PROBLEM\n    static async getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n        try {\n           // efficient random selection using raw query or count-based skip\n           const count = await prisma.problem.count({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               }\n           });\n\n           if (count === 0) return null;\n\n           const skip = Math.floor(Math.random() * count);\n           const randomProblem = await prisma.problem.findFirst({\n               where: {\n                   domain,\n                   type,\n                   hidden: false\n               },\n               skip,\n               select: {\n                   slug: true\n               }\n           });\n\n           return randomProblem?.slug || null;\n        } catch (error) {\n            console.error(\"Failed to get random problem:\", error);\n            return null;\n        }\n    }\n\n    // CREATING A PROBLEM\n    static async createProblem(data: {\n        title: string;\n        description: string;\n        difficulty: Difficulty;\n        slug: string;\n        hidden: boolean;\n        hiddenQuery?: string | null;\n        domain?: ProblemDomain;\n        testCases: { input: string; output: string; hidden?: boolean }[];\n        tags?: string[];\n        useFunctionTemplate?: boolean;\n        functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n        solution?: string | null;\n    }) {\n        try {\n            const problem = await prisma.problem.create({\n                data: {\n                    title: data.title,\n                    description: data.description,\n                    difficulty: data.difficulty,\n                    slug: data.slug,\n                    score: 10,\n                    hidden: data.hidden,\n                    hiddenQuery: data.hiddenQuery || null,\n                    domain: data.domain || \"DSA\",\n                    useFunctionTemplate: data.useFunctionTemplate || false,\n                    solution: data.solution || null,\n                    testCases: {\n                        create: data.testCases.map(tc => ({\n                            input: tc.input,\n                            output: tc.output,\n                            hidden: tc.hidden ?? false\n                        }))\n                    },\n                    tags: data.tags ? {\n                        connect: data.tags.map(slug => ({ slug }))\n                    } : undefined,\n                    // Create function templates if provided and enabled\n                    functionTemplates: data.useFunctionTemplate && data.functionTemplates?.length ? {\n                        create: data.functionTemplates.map(ft => ({\n                            languageId: ft.languageId,\n                            functionTemplate: ft.functionTemplate,\n                            driverCode: ft.driverCode,\n                        }))\n                    } : undefined\n                },\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n\n            return { success: true, problem };\n        } catch (error) {\n            console.error(\"Failed to create problem:\", error);\n            return { success: false, error: \"Failed to create problem\" };\n        }\n    }\n\n    // UPDATING A PROBLEM\n    static async updateProblem(id: string, data: any) {\n        try {\n            const { testCases, tags, functionTemplates, ...problemData } = data;\n\n            const updateData: any = { ...problemData };\n            if (testCases) {\n                updateData.testCases = {\n                    deleteMany: {},\n                    create: testCases.map((tc: any) => ({\n                        input: tc.input,\n                        output: tc.output,\n                        hidden: tc.hidden ?? false\n                    }))\n                };\n            }\n\n            if (tags) {\n                updateData.tags = {\n                    set: [], // Disconnect all existing\n                    connect: tags.map((slug: string) => ({ slug }))\n                };\n            }\n\n            // Handle function templates\n            if (functionTemplates !== undefined) {\n                updateData.functionTemplates = {\n                    deleteMany: {}, // Delete all existing templates\n                    create: functionTemplates.map((ft: any) => ({\n                        languageId: ft.languageId,\n                        functionTemplate: ft.functionTemplate,\n                        driverCode: ft.driverCode,\n                    }))\n                };\n            }\n\n            // UPDATING THE PROBLEM\n            const problem = await prisma.problem.update({\n                where: { id },\n                data: updateData\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            await redis.del(getProblemCacheKey(problem.slug));\n            // Also invalidate function template cache\n            await redis.del(`problem-templates:${id}`);\n\n            return { success: true, data: problem };\n        } catch (error) {\n            console.error(\"Failed to update problem:\", error);\n            return { success: false, error: \"Failed to update problem\" };\n        }\n    }\n\n    // DELETING A PROBLEM\n    static async deleteProblem(id: string) {\n        try {\n            const problem = await prisma.problem.findUnique({ where: { id }, select: { slug: true } });\n\n            await prisma.problem.delete({\n                where: { id }\n            });\n\n            // INVALIDATING THE CACHE\n            await this.invalidateProblemCaches();\n            if (problem) {\n                await redis.del(getProblemCacheKey(problem.slug));\n            }\n\n            // RETURNING THE SUCCESS\n            return { success: true };\n        } catch (error) {\n            console.error(\"Failed to delete problem:\", error);\n            return { success: false, error: \"Failed to delete problem\" };\n        }\n    }\n\n    private static async invalidateProblemCaches() {\n        const cachePattern = \"problems:list:*\";\n        const keys = await redis.keys(cachePattern);\n        if (keys.length > 0) {\n            await redis.del(...keys);\n        }\n        const adminCachePattern = \"admin:problems:*\";\n        const adminKeys = await redis.keys(adminCachePattern);\n        if (adminKeys.length > 0) {\n            await redis.del(...adminKeys);\n        }\n    }\n}\n","\"use server\";\n\nimport { ProblemService } from \"@/core/services/problem.service\";\nimport { Difficulty, ProblemType, ProblemDomain } from \"@prisma/client\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nimport { revalidatePath, updateTag, cacheTag, cacheLife } from \"next/cache\";\n\n// GETTING PUBLIC PROBLEMS\n\nexport async function getProblems(\n    page: number = 1,\n    pageSize: number = 10,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\",\n    difficulty?: Difficulty,\n    tags?: string[],\n    cursor?: string\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `problems-${domain}-${type}${difficulty ? `-${difficulty}` : ''}${tags && tags.length > 0 ? `-${tags.join('-')}` : ''}${cursor ? `-cursor-${cursor}` : `-page-${page}`}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-list', `problems-${domain}-${type}`);\n\n    return ProblemService.getProblems(page, pageSize, type, domain, userId, difficulty, tags || [], cursor);\n}\n\n// GETTING ADMIN PROBLEMS\n\nexport async function getAdminProblems(\n    page: number = 1,\n    pageSize: number = 50,\n    domain?: ProblemDomain,\n    excludeDifficulty?: Difficulty,\n    type?: ProblemType\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    // CHECKING IF USER IS AUTHENTICATED\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const tagKey = `admin-problems-${domain || 'all'}${excludeDifficulty ? `-exclude-${excludeDifficulty}` : ''}${type ? `-type-${type}` : ''}-page-${page}`;\n    cacheTag(tagKey, 'admin-problems-list');\n\n    return ProblemService.getAdminProblems(page, pageSize, domain, excludeDifficulty, type);\n}\n\n// SEARCHING FOR PROBLEMS\n\nexport async function searchProblems(\n    term: string,\n    type: ProblemType = \"PRACTICE\",\n    domain: ProblemDomain = \"DSA\"\n) {\n    \"use cache: private\"; // Must be at top - allows headers() inside\n    cacheLife({ stale: 300, revalidate: 300 }); // 5 minutes for search results\n\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    const userId = session?.user?.id;\n\n    const tagKey = `search-${domain}-${type}-${term.toLowerCase().slice(0, 20)}${userId ? `-user-${userId}` : ''}`;\n    cacheTag(tagKey, 'problems-search');\n\n    return ProblemService.searchProblems(term, type, domain, userId);\n}\n\n// GETTING A PROBLEM BY SLUG CACHED\n\nexport async function getProblem(slug: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-${slug}`, 'problems-list');\n\n    return ProblemService.getProblem(slug);\n}\n\n\n// CREATING A PROBLEM --> ADMIN ONLY\n\nexport async function createProblem(data: {\n    title: string;\n    description: string;\n    difficulty: Difficulty;\n    slug: string;\n    hidden: boolean;\n    hiddenQuery?: string | null;\n    domain?: ProblemDomain;\n    testCases: { input: string; output: string; hidden?: boolean }[];\n    tags?: string[];\n    useFunctionTemplate?: boolean;\n    functionTemplates?: { languageId: number; functionTemplate: string; driverCode: string }[];\n    solution?: string | null;\n}) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.createProblem(data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(\"/admin/problems\");\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag('problems-SQL-PRACTICE');\n        updateTag('problems-DSA-PRACTICE');\n    }\n\n    return result;\n}\n\n\n// GETTING A PROBLEM BY ID\nexport async function getProblemById(id: string) {\n    \"use cache\";\n    cacheLife({ stale: 900, revalidate: 900 }); // 15 minutes default\n\n    cacheTag(`problem-id-${id}`, 'problems-list');\n\n    return ProblemService.getProblemById(id);\n}\n\n// NAVIGATION ACTIONS\n\nexport async function getNextProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getNextProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getPreviousProblem(currentCreatedAt: Date, domain: ProblemDomain, type: ProblemType) {\n    \"use cache: private\";\n    cacheLife({ stale: 300, revalidate: 300 });\n    return ProblemService.getPreviousProblem(currentCreatedAt, domain, type);\n}\n\nexport async function getRandomProblem(domain: ProblemDomain, type: ProblemType) {\n    // No cache for random\n    return ProblemService.getRandomProblem(domain, type);\n}\n\n\n// UPDATING A PROBLEM --> ADMIN ONLY\nexport async function updateProblem(id: string, data: any) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.updateProblem(id, data);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n        updateTag(`problems-${result.data?.domain || 'DSA'}-${result.data?.type || 'PRACTICE'}`);\n        updateTag(`problem-${result.data?.slug}`);\n    }\n\n    return result;\n}\n\n\n// DELETING A PROBLEM --> ADMIN ONLY\nexport async function deleteProblem(id: string) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n\n    // CHECKING IF USER IS ADMIN --> THROWING AN ERROR IF NOT ADMIN\n\n    if (!session || session.user.role !== \"ADMIN\") {\n        throw new Error(\"Unauthorized\");\n    }\n\n    const result = await ProblemService.deleteProblem(id);\n\n    if (result.success) {\n        revalidatePath(\"/problems\");\n        revalidatePath(\"/problems/dsa\");\n        revalidatePath(\"/problems/sql\");\n        revalidatePath(`/admin/problems`);\n        revalidatePath(\"/admin/dsa/problems\");\n        revalidatePath(\"/admin/sql/problems\");\n\n        updateTag('admin-problems-list');\n        updateTag('problems-list');\n    }\n\n    return result;\n}\n"],"names":[],"mappings":"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"}