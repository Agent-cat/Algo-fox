{"version":3,"sources":["../../../lib/sql-converter.ts"],"sourcesContent":["export function convertToSQLite(sql: string): string {\n    if (!sql || !sql.trim()) {\n        return sql;\n    }\n\n    let converted = sql;\n\n    // 1. Convert AUTO_INCREMENT to AUTOINCREMENT (SQLite syntax - one word, no underscore)\n    // This must be done first before other conversions\n    converted = converted.replace(/\\bAUTO_INCREMENT\\b/gi, 'AUTOINCREMENT');\n\n    // 2. Convert INT PRIMARY KEY AUTOINCREMENT to INTEGER PRIMARY KEY AUTOINCREMENT\n    // SQLite requires INTEGER (not INT) for PRIMARY KEY with AUTOINCREMENT\n    converted = converted.replace(/\\bINT\\s+PRIMARY\\s+KEY\\s+AUTOINCREMENT\\b/gi, 'INTEGER PRIMARY KEY AUTOINCREMENT');\n    converted = converted.replace(/\\bINT\\s+AUTOINCREMENT\\s+PRIMARY\\s+KEY\\b/gi, 'INTEGER PRIMARY KEY AUTOINCREMENT');\n\n    // 3. Convert INT PRIMARY KEY to INTEGER PRIMARY KEY (SQLite requires INTEGER for PRIMARY KEY)\n    // This handles cases without AUTOINCREMENT\n    converted = converted.replace(/\\bINT\\s+PRIMARY\\s+KEY\\b/gi, 'INTEGER PRIMARY KEY');\n\n    // 4. Convert INT AUTOINCREMENT to INTEGER AUTOINCREMENT (for non-PRIMARY KEY cases)\n    converted = converted.replace(/\\bINT\\s+AUTOINCREMENT\\b/gi, 'INTEGER AUTOINCREMENT');\n\n    // 5. Convert MySQL backticks to SQLite double quotes (optional, SQLite accepts both)\n    // But we'll keep backticks as SQLite 3.3+ supports them\n\n    // 6. Convert MySQL/PostgreSQL LIMIT syntax if needed\n    // SQLite supports: LIMIT n OFFSET m (same as MySQL)\n    // No conversion needed for LIMIT/OFFSET\n\n    // 7. Convert string concatenation\n    // MySQL: CONCAT(a, b) -> SQLite: a || b\n    // Handle nested CONCAT calls\n    converted = convertConcatToConcatOperator(converted);\n\n    // 8. Convert boolean handling\n    // MySQL: TRUE/FALSE -> SQLite: 1/0 (SQLite doesn't have native boolean)\n    converted = converted.replace(/\\bTRUE\\b/gi, '1');\n    converted = converted.replace(/\\bFALSE\\b/gi, '0');\n\n    // 9. Convert date functions (common differences)\n    // MySQL: NOW() -> SQLite: datetime('now')\n    converted = converted.replace(/\\bNOW\\(\\)\\b/gi, \"datetime('now')\");\n    // MySQL: CURDATE() -> SQLite: date('now')\n    converted = converted.replace(/\\bCURDATE\\(\\)\\b/gi, \"date('now')\");\n    // MySQL: CURTIME() -> SQLite: time('now')\n    converted = converted.replace(/\\bCURTIME\\(\\)\\b/gi, \"time('now')\");\n\n    // 10. Convert IFNULL to COALESCE (SQLite supports both, but COALESCE is standard)\n    // Actually, SQLite supports IFNULL, so no conversion needed\n\n    // 11. Remove MySQL-specific ENGINE and CHARSET clauses\n    converted = converted.replace(/\\s+ENGINE\\s*=\\s*\\w+/gi, '');\n    converted = converted.replace(/\\s+CHARSET\\s*=\\s*\\w+/gi, '');\n    converted = converted.replace(/\\s+COLLATE\\s*=\\s*\\w+/gi, '');\n\n    // 12. Convert MySQL-specific data types\n    // TINYINT -> INTEGER\n    converted = converted.replace(/\\bTINYINT\\b/gi, 'INTEGER');\n    // MEDIUMINT -> INTEGER\n    converted = converted.replace(/\\bMEDIUMINT\\b/gi, 'INTEGER');\n    // BIGINT -> INTEGER (SQLite stores all integers as INTEGER)\n    // Actually, keep BIGINT as SQLite handles it\n    // VARCHAR(n) -> TEXT (SQLite doesn't enforce length)\n    // Keep VARCHAR as SQLite accepts it\n    // TEXT -> TEXT (same)\n    // DATETIME -> TEXT (SQLite stores dates as TEXT)\n    // Keep DATETIME as SQLite accepts it\n\n    // 13. Remove MySQL-specific UNSIGNED keyword\n    converted = converted.replace(/\\bUNSIGNED\\b/gi, '');\n\n    // 14. Convert MySQL-specific ON DUPLICATE KEY UPDATE to SQLite INSERT OR REPLACE\n    // This is complex, so we'll handle it separately if needed\n    // For now, keep as is and let SQLite handle errors\n\n    // 15. Clean up extra whitespace and semicolons\n    converted = converted.trim();\n\n    return converted;\n}\n\n/**\n * Converts CONCAT() function calls to SQLite's || concatenation operator\n * Handles nested CONCAT calls efficiently with iterative approach\n */\nfunction convertConcatToConcatOperator(sql: string): string {\n    // Early return if no CONCAT found\n    if (!/\\bCONCAT\\s*\\(/i.test(sql)) {\n        return sql;\n    }\n\n    let result = sql;\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 20; // Prevent infinite loops\n\n    // Process CONCAT calls iteratively (handles nesting)\n    while (changed && iterations < maxIterations) {\n        iterations++;\n        changed = false;\n\n        // Find innermost CONCAT call (no nested CONCAT inside)\n        const concatMatch = result.match(/\\bCONCAT\\s*\\(([^()]+)\\)/i);\n\n        if (concatMatch) {\n            changed = true;\n            const args = concatMatch[1];\n            const argsList = splitConcatArgs(args);\n\n            // Join with || operator\n            const converted = argsList.map(arg => arg.trim()).join(' || ');\n\n            // Replace the CONCAT call\n            result = result.replace(concatMatch[0], `(${converted})`);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Splits CONCAT arguments while respecting nested parentheses\n */\nfunction splitConcatArgs(args: string): string[] {\n    const result: string[] = [];\n    let current = '';\n    let depth = 0;\n\n    for (let i = 0; i < args.length; i++) {\n        const char = args[i];\n\n        if (char === '(') {\n            depth++;\n            current += char;\n        } else if (char === ')') {\n            depth--;\n            current += char;\n        } else if (char === ',' && depth === 0) {\n            result.push(current.trim());\n            current = '';\n        } else {\n            current += char;\n        }\n    }\n\n    if (current.trim()) {\n        result.push(current.trim());\n    }\n\n    return result;\n}\n\n/**\n * Optimized batch conversion for multiple SQL statements\n */\nexport function convertBatchToSQLite(sql: string): string {\n    // Split by semicolon but keep them for SQLite\n    const statements = sql.split(';').filter(s => s.trim());\n\n    if (statements.length === 0) {\n        return sql;\n    }\n\n    // Convert each statement\n    const converted = statements.map(stmt => convertToSQLite(stmt.trim()));\n\n    // Join with semicolons\n    return converted.join(';\\n') + (sql.trim().endsWith(';') ? ';' : '');\n}\n\n"],"names":[],"mappings":"wCAAO,SAAS,EAAgB,CAAW,EACvC,GAAI,CAAC,GAAO,CAAC,EAAI,IAAI,GACjB,CADqB,MACd,EAGX,IAAI,EAAY,EA0EhB,MAFY,CAPZ,AASO,EATK,CAVZ,EAFA,AAEY,GAFA,CAJZ,EAAY,CADZ,EAAY,CADZ,EANA,AAMY,GANA,CAFZ,EAAY,AAFZ,GAAY,CAJZ,EAAY,CADZ,EAAY,CAJZ,EAAY,AAqDhB,SAAS,AAA8B,CAAW,EAE9C,GAAI,CAAC,cAvDqC,GAuDpB,IAAI,CAAC,GACvB,GAD6B,IACtB,EAGX,IAAI,EAAS,EACT,GAAU,EACV,EAAa,EAIjB,KAAO,GAAW,EAHI,IAAI,AAGoB,CAC1C,IACA,EAF2B,CAEjB,EAGV,IAAM,EAAc,EAAO,KAAK,CAAC,CARc,2BAU/C,GAAI,EAAa,CACb,EAAU,GAKV,IAAM,EAHW,AAGC,CAa9B,SAAS,AAAgB,CAAY,EACjC,GAjByC,CAiBnC,EAAmB,EAAE,CACvB,EAAU,GACV,EAAQ,EAEZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CAClC,IAAM,EAAO,CAAI,CAAC,EAAE,CAEP,KAAK,CAAd,GACA,IACA,GAAW,GACK,KAAK,CAAd,GACP,IACA,GAAW,GACK,MAAT,GAAgB,AAAU,GAAG,IACpC,EAAO,IAAI,CAAC,EAAQ,IAAI,IACxB,EAAU,IAEV,GAAW,CAEnB,CAMA,OAJI,EAAQ,IAAI,IAAI,AAChB,EAAO,IAAI,CAAC,EAAQ,IAAI,IAGrB,EACX,EA5CyB,CAAW,CAAC,EAAE,EAIA,GAAG,CAAC,GAAO,EAAI,IAAI,IAAI,IAAI,CAAC,QAGvD,EAAS,EAAO,OAAO,CAAC,CAAW,CAAC,EAAE,CAAE,CAAC,CAAC,EAAE,EAAU,CAAC,CAAC,CAC5D,CACJ,CAEA,OAAO,CACX,EAlGI,EAAY,AAHZ,GAJA,AAIY,GAJA,CADZ,EAAY,CAJZ,EAAY,EAAU,OAAO,CAAC,uBAAwB,gBAAA,EAIhC,OAAO,CAAC,4CAA6C,oCAAA,EACrD,OAAO,CAAC,4CAA6C,oCAAA,EAIrD,OAAO,CAAC,4BAA6B,sBAAA,EAGrC,OAAO,CAAC,4BAA6B,yBAYjB,EAIpB,OAAO,CAAC,aAAc,IAAA,EACtB,OAAO,CAAC,cAAe,IAAA,EAIvB,OAAO,CAAC,gBAAiB,kBAAA,EAEzB,OAAO,CAAC,oBAAqB,cAAA,EAE7B,OAAO,CAAC,oBAAqB,cAAA,EAM7B,OAAO,CAAC,wBAAyB,GAAA,EACjC,OAAO,CAAC,yBAA0B,GAAA,EAClC,OAAO,CAAC,yBAA0B,GAAA,EAIlC,OAAO,CAAC,gBAAiB,UAAA,EAEzB,OAAO,CAAC,kBAAmB,UAAA,EAU3B,OAAO,CAAC,iBAAkB,GAAA,EAO1B,IAAI,EAG9B,CA4EO,SAAS,EAAqB,CAAW,EAE5C,IAAM,EAAa,EAAI,KAAK,CAAC,KAAK,MAAM,CAAC,GAAK,EAAE,IAAI,WAEpD,AAA0B,GAAG,CAAzB,EAAW,MAAM,CACV,EAIO,AAGX,EAHsB,GAAG,CAAC,GAAQ,EAAgB,EAAK,IAAI,KAGjD,IAAI,CAAC,QAAU,CAAD,CAAK,IAAI,GAAG,QAAQ,CAAC,KAAO,IAAM,EAAA,CAAE,AACvE"}