generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//////////////////////////////////// Authentication Models //////////////////////////////////////////

model User {
  id        String  @id
  name      String
  collegeId String?
  email     String  @unique

  totalScore     Int @default(0)
  problemsSolved Int @default(0)

  goldBadges   Int @default(0)
  silverBadges Int @default(0)
  bronzeBadges Int @default(0)

  tags          String[] @default(["student"])
  emailVerified Boolean  @default(false)
  image         String?

  codeChefHandle   String?
  leetCodeHandle   String?
  hackerrankHandle String?
  githubHandle     String?

  role                Role    @default(STUDENT)
  onboardingCompleted Boolean @default(false)
  bio                 String?
  year                Int? // Academic year: 1, 2, 3, 4, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions      Session[]
  accounts      Account[]
  submissions   Submission[]
  institutionId String?
  institution   Institution? @relation(fields: [institutionId], references: [id])
  problems      Problem[]

  taughtClassrooms      Classroom[]            @relation("TeacherClassrooms")
  enrolledClassrooms    Classroom[]            @relation("StudentClassrooms")
  contests              Contest[]
  contestParticipations ContestParticipation[]

  @@index([collegeId])
  @@index([collegeId, totalScore])
  @@index([institutionId])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ipAddress String?
  userAgent String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id         String @id
  accountId  String
  providerId String
  userId     String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

////////////////////////////////////// Problem Models ///////////////////////////////////////////

model Problem {
  id          String @id @default(cuid())
  title       String
  description String

  hidden      Boolean       @default(true)
  slug        String        @unique
  score       Int
  solved      Int?          @default(0)
  difficulty  Difficulty    @default(EASY)
  type        ProblemType   @default(PRACTICE)
  domain      ProblemDomain @default(DSA)
  hiddenQuery String?

  useFunctionTemplate Boolean @default(false)
  solution            String? @db.Text

  // Aptitude / MCQ fields
  isMcq   Boolean @default(false)
  options Json? // Store options as JSON: [{"id": "1", "text": "Option A"}, ...]
  answer  String? // Correct option ID

  submissions       Submission[]
  testCases         ProblemTestCase[]
  categoryProblems  CategoryProblem[]
  functionTemplates ProblemFunctionTemplate[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User?   @relation(fields: [userId], references: [id])
  userId String?

  tags Tag[]

  contestProblems ContestProblem[]

  @@index([createdAt])
  @@index([domain, type, hidden, difficulty, createdAt])
  @@index([domain, type, hidden, createdAt])
}

model Tag {
  id   String @id @default(cuid())
  name String @unique
  slug String @unique

  problems Problem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
}

model ProblemTestCase {
  id        String  @id @default(cuid())
  problemId String
  problem   Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  input     String
  output    String
  hidden    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([problemId])
}

model ProblemFunctionTemplate {
  id         String @id @default(cuid())
  problemId  String
  languageId Int

  functionTemplate String @db.Text
  driverCode       String @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@unique([problemId, languageId])
  @@index([problemId])
}

model Language {
  id       Int    @id @default(autoincrement())
  name     String @unique
  judge0Id Int    @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  submissions Submission[]
}

////////////////////////////////////// Submission Models ////////////////////////////////////////

model Submission {
  id         String @id @default(cuid())
  problemId  String
  userId     String
  languageId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contestId String?

  code   String
  status SubmissionResult @default(PENDING)
  mode   SubmissionMode   @default(SUBMIT)

  testCases TestCase[]
  memory    Int?
  time      Float?

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  language Language @relation(fields: [languageId], references: [id], onDelete: Cascade)
  problem  Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)
  contest  Contest? @relation(fields: [contestId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([problemId, createdAt])
  @@index([userId, problemId])
  @@index([status])
  @@index([userId, status, mode, problemId])
  @@index([userId, status, createdAt])
  @@index([contestId])
}

model TestCase {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status TestCaseResult @default(PENDING)
  index  Int

  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId String

  memory Int?
  time   Float?

  judge0TrackingId String? @unique
  errorMessage     String?
  stdout           String?

  @@index([submissionId])
}

////////////////////////////////////// Category Models ////////////////////////////////////////

model Category {
  id          String        @id @default(cuid())
  name        String
  description String?
  slug        String        @unique
  order       Int           @default(0)
  domain      ProblemDomain @default(DSA)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categoryProblems CategoryProblem[]

  @@index([order])
  @@index([slug])
  @@index([domain, order])
}

model CategoryProblem {
  id         String @id @default(cuid())
  categoryId String
  problemId  String
  order      Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  problem  Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@unique([categoryId, problemId])
  @@index([categoryId, order])
  @@index([problemId])
}

////////////////////////////////////// Enums ////////////////////////////////////////////

enum Role {
  ADMIN
  INSTITUTION_MANAGER
  CONTEST_MANAGER
  TEACHER
  STUDENT
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  CONCEPT
}

enum ProblemType {
  PRACTICE
  LEARN
  CONTEST
}

enum ProblemDomain {
  DSA
  SQL
  APTITUDE
  OOPS
  WEBDEV
}

enum SubmissionMode {
  RUN
  SUBMIT
}

enum SubmissionResult {
  PENDING
  ACCEPTED
  WRONG_ANSWER
  TIME_LIMIT_EXCEEDED
  MEMORY_LIMIT_EXCEEDED
  RUNTIME_ERROR
  COMPILE_ERROR
}

enum TestCaseResult {
  PENDING
  ACCEPTED
  WRONG_ANSWER
  TIME_LIMIT_EXCEEDED
  MEMORY_LIMIT_EXCEEDED
  RUNTIME_ERROR
  COMPILE_ERROR
}

enum ContestVisibility {
  PUBLIC
  INSTITUTION
  CLASSROOM
}

model Institution {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  logo      String?
  domain    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users      User[]
  classrooms Classroom[]
  contests   Contest[]

  @@map("institution")
}

model Classroom {
  id            String      @id @default(cuid())
  name          String
  section       String?
  subject       String?
  joinCode      String      @unique
  institutionId String
  institution   Institution @relation(fields: [institutionId], references: [id], onDelete: Cascade)

  teacherId String
  teacher   User   @relation("TeacherClassrooms", fields: [teacherId], references: [id])

  contests Contest[]
  students User[]    @relation("StudentClassrooms")

  isTrackingActive  Boolean   @default(false)
  trackingStartedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([institutionId])
  @@index([teacherId])
  @@map("classroom")
}

model Contest {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  description String?  @db.Text
  startTime   DateTime
  endTime     DateTime

  // Customization fields
  backgroundImage String? @db.Text
  prizes          String? @db.Text
  rules           String? @db.Text
  hidden          Boolean @default(false)
  isFinalized     Boolean @default(false)

  visibility    ContestVisibility @default(PUBLIC)
  institutionId String?
  institution   Institution?      @relation(fields: [institutionId], references: [id], onDelete: Cascade)

  classroomId String?
  classroom   Classroom? @relation(fields: [classroomId], references: [id], onDelete: Cascade)

  creatorId String
  creator   User   @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  problems     ContestProblem[]
  participants ContestParticipation[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submissions Submission[]

  @@index([institutionId])
  @@index([classroomId])
  @@index([creatorId])
  @@index([slug])
  @@map("contest")
}

model ContestProblem {
  id        String @id @default(cuid())
  contestId String
  problemId String
  order     Int    @default(0)

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([contestId, problemId])
  @@index([contestId, order])
  @@map("contest_problem")
}

model ContestParticipation {
  id        String @id @default(cuid())
  userId    String
  contestId String

  acceptedRules Boolean   @default(false)
  isFinished    Boolean   @default(false)
  finishedAt    DateTime?

  // Session tracking for multi-tab detection
  sessionId        String?
  sessionStartedAt DateTime?

  // Violation counts (denormalized for quick access)
  tabSwitchCount      Int @default(0)
  fullscreenExitCount Int @default(0)
  copyPasteCount      Int @default(0)
  devToolsCount       Int @default(0)
  keyboardCount       Int @default(0)
  navigationCount     Int @default(0)
  totalViolations     Int @default(0)

  // Status flags
  isFlagged Boolean @default(false)
  isBlocked Boolean @default(false)

  // Tiered blocking
  tempBlockedUntil   DateTime? // When temp block expires (null = not temp blocked)
  permanentlyBlocked Boolean   @default(false) // Requires manager to unblock
  unblockedBy        String? // Manager who unblocked
  unblockedAt        DateTime? // When they were unblocked

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  contest    Contest            @relation(fields: [contestId], references: [id], onDelete: Cascade)
  violations ContestViolation[]

  @@unique([userId, contestId])
  @@index([contestId])
  @@index([userId])
  @@index([sessionId])
  @@map("contest_participation")
}

model ContestViolation {
  id              String        @id @default(cuid())
  participationId String
  type            ViolationType
  message         String?
  metadata        Json?

  createdAt DateTime @default(now())

  participation ContestParticipation @relation(fields: [participationId], references: [id], onDelete: Cascade)

  @@index([participationId])
  @@index([type])
  @@map("contest_violation")
}

// Course Allocation - Maps which courses/domains are available to which academic years
model CourseAllocation {
  id     String        @id @default(cuid())
  year   Int // Academic year: 1, 2, 3, 4, etc.
  domain ProblemDomain // Course/Domain: DSA, SQL, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([year, domain]) // Prevent duplicate allocations
  @@index([year])
  @@index([domain])
  @@map("course_allocation")
}

enum ViolationType {
  TAB_SWITCH
  FULLSCREEN_EXIT
  COPY_PASTE
  DEVTOOLS_OPEN
  KEYBOARD_SHORTCUT
  NAVIGATION_ATTEMPT
  MULTI_TAB
  SUSPICIOUS_INPUT
}
